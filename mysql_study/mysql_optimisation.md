# MySQL Optimisation

* [MySQL Optimisation](#mysql-optimisation)
* [游标](#游标)
* [触发器](#触发器)
  * [语法](#语法)
  * [例子](#例子)
  * [删除触发器](#删除触发器)
  * [查看触发器](#查看触发器)
* [mysql - b+](#mysql---b)
* [概述](#概述)
* [安装相关](#安装相关)
* [配置文件](#配置文件)
* [mysql逻辑架构介绍](#mysql逻辑架构介绍)
* [mysql存储引擎](#mysql存储引擎)
  * [MyISAM vs InnoDB](#myisam-vs-innodb)
  * [MEMORY & MERGE引擎](#memory--merge引擎)
  * [选择](#选择)
* [SQL性能下降原因](#sql性能下降原因)
* [常见通用的Join查询](#常见通用的join查询)
  * [7种JOIN](#7种join)
* [索引](#索引)
  * [定义](#定义)
  * [优点缺点](#优点缺点)
  * [索引分类](#索引分类)
  * [索引增删改查](#索引增删改查)
  * [索引结构 & 检索原理](#索引结构--检索原理)
  * [何时建立索引](#何时建立索引)
  * [何时不建立索引](#何时不建立索引)
* [性能分析](#性能分析)
  * [MySQL Query Optimizer](#mysql-query-optimizer)
  * [MySQL常见瓶颈](#mysql常见瓶颈)
* [覆盖索引](#覆盖索引)
* [Explain - 执行计划](#explain---执行计划)
  * [字段](#字段)
* [例子](#例子-1)
* [索引单表优化例子](#索引单表优化例子)
* [索引双表优化例子](#索引双表优化例子)
* [三表索引优化例子](#三表索引优化例子)
* [JOIN优化](#join优化)
* [索引失效（应该避免）](#索引失效应该避免)
  * [最佳左前缀法则](#最佳左前缀法则)
  * [不在索引列上作任何操作](#不在索引列上作任何操作)
  * [存储引擎不能使用索引中范围条件右边的列](#存储引擎不能使用索引中范围条件右边的列)
  * [尽量使用覆盖索引](#尽量使用覆盖索引)
  * [减少!=或<>](#减少或)
  * [is null，is not null](#is-nullis-not-null)
  * [like](#like)
  * [字符串不加单引号索引失效](#字符串不加单引号索引失效)
  * [少用or](#少用or)
  * [总结](#总结)
* [面试例子](#面试例子)
  * [一般性建议](#一般性建议)
* [查询截取分析](#查询截取分析)
* [查询优化](#查询优化)
* [Exist vs In](#exist-vs-in)
* [ORDER BY优化](#order-by优化)
  * [filesort](#filesort)
  * [总结](#总结-1)
* [GROUP BY优化](#group-by优化)
* [慢查询日志](#慢查询日志)
  * [查看是否开启](#查看是否开启)
  * [什么样的SQL会被记录](#什么样的sql会被记录)
  * [记录慢SQL并后续分析](#记录慢sql并后续分析)
  * [配置版](#配置版)
* [日志分析工具mysqldumpslow](#日志分析工具mysqldumpslow)
  * [工作常用参考](#工作常用参考)
* [批量数据脚本](#批量数据脚本)
  * [创建函数报错（开启过慢查询日志导致）](#创建函数报错开启过慢查询日志导致)
  * [创建函数](#创建函数)
  * [删除函数](#删除函数)
  * [创建存储过程](#创建存储过程)
  * [调用存储过程](#调用存储过程)
* [SHOW PROFILE](#show-profile)
  * [分析步骤](#分析步骤)
  * [参数备注](#参数备注)
  * [日常开发需要注意的参数（结论](#日常开发需要注意的参数结论)
* [全局查询日志](#全局查询日志)
* [应用优化](#应用优化)
* [查询缓存](#查询缓存)
  * [流程](#流程)
  * [配置](#配置)
  * [开启查询缓存](#开启查询缓存)
  * [SELECT选项](#select选项)
  * [失效情况](#失效情况)
* [内存管理&优化](#内存管理优化)
  * [内存优化原则](#内存优化原则)
  * [MyISAM 内存优化](#myisam-内存优化)
  * [InnoDB 内存优化](#innodb-内存优化)
* [Mysql 并发参数调整](#mysql-并发参数调整)
  * [max_connections](#max_connections)
  * [back_log](#back_log)
  * [table_open_cache](#table_open_cache)
  * [thread_cache_size](#thread_cache_size)
  * [innodb_lock_wait_timeout](#innodb_lock_wait_timeout)
* [锁问题](#锁问题)
  * [锁分类](#锁分类)
  * [Mysql不同引擎锁机制](#mysql不同引擎锁机制)
* [事务 & ACID属性](#事务--acid属性)
  * [事务隔离级别](#事务隔离级别)
* [MyISAM 表锁](#myisam-表锁)
  * [myISAM表锁模式](#myisam表锁模式)
  * [MyIsam锁结论](#myisam锁结论)
  * [MyISAM锁争用情况](#myisam锁争用情况)
* [InnoDB 行锁](#innodb-行锁)
  * [InnoDB 的行锁模式](#innodb-的行锁模式)
  * [例子](#例子-2)
  * [行锁升级表锁](#行锁升级表锁)
  * [间隙锁危害](#间隙锁危害)
  * [InnoDB 行锁争用情况](#innodb-行锁争用情况)
  * [总结 & 建议](#总结--建议)
* [主从复制](#主从复制)
  * [优势](#优势)
  * [搭建](#搭建)
  * [验证同步](#验证同步)

# 游标

![](/static/2021-08-24-11-49-43.png)

* **用来存储查询结果集**的数据类型，在存储过程和函数中可以用光标对结果集进行循环处理
* fetch移动指针

---

例子 - 查询 emp 表中数据 , 并逐行获取进行展示

![](/static/2021-08-24-11-52-29.png)
![](/static/2021-08-24-11-55-59.png)
![](/static/2021-08-24-11-56-37.png)

例子 - 通过循环结构 , 获取游标中的数据 :

![](/static/2021-08-24-11-59-24.png)

# 触发器

触发器是与表有关的数据库对象，指**在 i nsert/update/delete 之前或之后，触发并执行触发器中定义的 SQL 语句集 合**。 **触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作** 。

使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持 行级触发，不支持语句级触发。

触发器类型

![](/static/2021-08-24-12-01-06.png)

## 语法

![](/static/2021-08-24-12-02-31.png)

## 例子

通过触发器记录 emp 表的数据变更日志 , 包含增加 , 修改 , 删除（CUD时插入日志） ;

![](/static/2021-08-24-12-03-23.png)

3个触发器

![](/static/2021-08-24-12-11-45.png)
![](/static/2021-08-24-12-14-26.png)
![](/static/2021-08-24-12-14-43.png)
![](/static/2021-08-24-12-14-53.png)

## 删除触发器

![](/static/2021-08-24-12-15-36.png)

如果没有指定 schema_name ， 默认为当前数据库

## 查看触发器

![](/static/2021-08-24-12-16-06.png)

可以通过执行 SHOW TRIGGERSd 命令查看触发器的状态、 语法等信息。

# mysql - b+

![](/static/2021-08-23-20-49-34.png)

# 概述

![](/static/2021-08-22-13-13-12.png)

# 安装相关

查看MySQL安装时创建的mysql用户和mysql组

* `cat /etc/passwd|grep mysql`
* `cat /etc/group|grep mysql`
* `mysqladmin --version`

MySQL的安装位置

* `/var/lib/mysql`：mysql**数据库文件**的存放路径
* `/usr/share/mysql`：配置文件目录
* `/usr/bin`：相关命令目录
* `/etc/init.d/mysql`：启停相关脚本

mysql服务启动后，开始连接

* 首次连接成功：mysql（不需要输入密码）
* 给root用户设置密码：/usr/bin/mysqladmin -u root password 123456
* 自启动mysql服务

* 设置开机自启动mysql：chkconfig mysql on
* 查看mysql的等级：chkconfig --list | grep mysql
* 查看不同等级代表的含义：cat /etc/inittab
* 查看开机自动服务有哪些：ntsysv

---

修改字符集和数据存储路径

* 查看字符集
  * show variables like ‘character%’;
  * show variables like ‘%char%’;
  * 由于默认的是客户端和服务器都使用的latin1，所以都是乱码
* 修改
  * ![](/static/2021-08-22-13-47-39.png)
  * 重新连接后，原来的库由于建立于修改字符集之前，所以中文依然是乱码，而新建表中文不是乱码

# 配置文件

主要配置文件

* **二进制日志log-bin**
  * 主从复制
* **错误日志log-error**
  * 默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等。
* **查询日志log**
  * 默认关闭，记录查询的sql语句，如果开启会降低mysql的整体性能，因为记录日志也是需要消耗系统资源的。
* **数据文件**
  * 两系统
    * windows：D:\devSoft\MySQLServer5.5\data目录下可以挑选很多库
    * linux
      * 看看当前系统中的全部库后再进去
      * 默认路径：/var/lib/mysql
  * **frm文件**：存放表结构
  * **myd文件**：存放表数据
  * **myi文件**：存放表索引
* 如何配置
  * windows：`my.ini`文件
  * Linux：`/etc/my.cnf`文件

# mysql逻辑架构介绍

和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，**插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离**。这种架构可以根据业务的需求和时机需要选择合适的存储引擎。

![](/static/2021-08-22-13-55-41.png)

从上到下，连接层，服务层，引擎层，存储层

![](/static/2021-08-22-14-03-18.png)

# mysql存储引擎

存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。 存储引擎是基于表的，而不是基于库的。 所以存储引擎也可被称为表类型。

---

如何用命令查看

* 看你的mysql现在已提供什么存储引擎：`show engines;`
* 看你的mysql当前默认的存储引擎：`show variables like ‘%storage_engine%’;`

## MyISAM vs InnoDB

![](/static/2021-08-24-12-24-46.png)
![](/static/2021-08-22-14-06-26.png)
![](/static/2021-08-22-14-09-30.png)

## MEMORY & MERGE引擎

![](/static/2021-08-24-12-31-49.png)

## 选择

![](/static/2021-08-24-12-35-30.png)

# SQL性能下降原因

执行时间长，等待时间长

* 查询语句写的烂
* 索引失效
  * 单值索引
  * 复合索引
* 关联查询太多join（设计缺陷或不得已的需求）
* 服务器调优及各个参数设置（缓冲、线程数等）

# 常见通用的Join查询

![](/static/2021-08-22-14-18-42.png)

手写（从上到下写）

![](/static/2021-08-22-14-19-02.png)

解析顺序

![](/static/2021-08-22-14-20-11.png)

总结

![](/static/2021-08-22-14-21-17.png)

## 7种JOIN

Mysql 的内外连接 (inner join，默认内连接) 外连接（left join，right join)

![](/static/2021-08-22-14-22-29.png)

# 索引

## 定义

MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。可以得到索引的本质：索引是数据结构。

* 可以简单理解为“排好序的快速查找数据结构“
  * B，B+

![](/static/2021-08-22-14-57-41.png)

* 数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引
* 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。

**我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。**其中聚集索引(cluster)，次要索引(secondary)，覆盖索引，复合索引，前缀索引，唯一索引默认的都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引（hash index）等

## 优点缺点

优势

* 类似大学图书馆建书目索引，**提高数据检索的效率，降低数据库的IO成本**。
* 通过索引列对数据**进行排序，降低数据排序的成本，降低了CPU的消耗**。

劣势

* 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以**索引列也是要占用空间的**。
* 虽然索引大大提高了查询速度，同时却会**降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息**。
* 索引只是提高效率的一个因素，如果你的MySQL有<font color="deeppink">大数据量的表，就需要花时间研究建立最优秀的索引，或者优化查询。</font>

## 索引分类

一张表最多不要建超过5个索引

* **单值索引**：即一个索引只包含单个列，一个表可以有多个单列索引
  * 一般复合，，除非某频繁使用的
* **唯一索引**：索引列的值必须唯一，但允许有空值
* **复合索引**：即一个索引包含多个列

## 索引增删改查

创建：

* `create [unique] index indexname on mytable(columnname(length));`
* `alter mytable add [unique] index [indexname] on (columnname(length))`

如果是char，varchar类型，length可以小于字段实际长度；如果是blob和text类型，必须指定length。

删除：

* `drop index [indexname] on mytable;`

查看：

* `show index from table_name;`

ALTER（创建

![](/static/2021-08-22-16-26-37.png)

## 索引结构 & 检索原理

* B+树索引
  * 索引原理
* Hash索引
* full-text全文索引
* R-Tree索引

---

检索原理

![](/static/2021-08-22-16-31-54.png)
![](/static/2021-08-22-16-36-23.png)

## 何时建立索引

哪些情况需要创建索引

* **主键自动建立唯一索引**
* **频繁作为查询条件的字段**应该创建索引
* 查询中**与其它表关联的字段，外键关系建立索引**
* **频繁更新的字段不适合创建索引**，因为每次更新不单单是更新了记录，还会更新索引，加重IO负担
* **where条件里用不到的字段不创建索引**
* **单键/组合索引**的选择问题，who？（在高并发下倾向创建组合索引）
* 查询中排序的字段，**排序字段**若通过索引去访问将大大提高排序速度
* 查询中**统计或者分组字段**

## 何时不建立索引

哪些情况不需要创建索引

* **表记录太少**
* **经常增删改**的表
  * Why：提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。**因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件**。
* **数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引**。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
  * ![](/static/2021-08-22-16-40-44.png)

# 性能分析

## MySQL Query Optimizer

![](/static/2021-08-22-16-42-14.png)

## MySQL常见瓶颈

* CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候
* IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候
* 服务器硬件的性能瓶颈：top，free，iostat和vmstat来查看系统的性能状态

# 覆盖索引

覆盖索引![](/static/2021-08-22-20-13-18.png)

# Explain - 执行计划

`explain SQL` (加`\G`能垂直显示)

* 使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。
* **执行计划包含的信息**
  * ![](/static/2021-08-22-16-46-31.png)

作用

* 表的读取顺序
  * `id`
* 数据读取操作的操作类型
  * `select_type`
* 哪些索引可以使用
* 哪些索引被实际使用
* 表之间的应用
* 每张表有多少行被优化器查询
  * `rows`

## 字段

id, type, key, rows

**执行计划包含的信息**

![](/static/2021-08-22-16-46-31.png)

* `id`
  * select查询的序列号，包含一组数字，**表示查询中执行select子句或操作表的顺序**
  * 三种情况：
    * **id相同，执行顺序由上至下**
    * id不同，如果是**子查询**，id的序号会递增，**id值越大优先级越高，越先被执行**
    * id相同不同，同时存在
      * 衍生：DERIVED
      * ![](/static/2021-08-22-16-52-52.png)
* `select_type`
  * 查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询
  * ![](/static/2021-08-22-16-54-09.png)
  * **SIMPLE**：简单的select查询，查询中不包含子查询或者UNION。
  * **PRIMARY**：查询中包含任何复杂的子部分，**最外层查询**则被标记为PRIMARY。
  * **SUBQUERY**：在SELECT或WHERE列表中包含了**子查询**
  * **DERIVED**：在FROM列表中包含的**子查询**被标记为DERIVED（衍生）。MySQL会**递归执行这些子查询，把结果放在临时表里**。
  * **UNION**：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED。
  * **UNION RESULT**：从UNION表中获取结果的SELECT
* `table`
  * 显示这一行的数据是关于哪些表的
* `type`
  * 访问类型排序(8)
  * ![](/static/2021-08-22-16-58-38.png)
  * type显示的是**访问类型**，是较为重要的一个指标，结果值从最好到最坏依次是：
  * system>const>eq_ref>ref>fulltext>ref_or_null>index_merge>unique_subquery>index_subquery>range>index>All
    * 常见的，**system>const>eq_ref>ref>range>index>All**
    * **system**：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计。
    * **const**：表示通过索引一次就找到了，**const用于比较primary key或则unique索引**。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。
    * **eq_ref**：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于**主键或唯一索引扫描**。
      * <font color="deeppink">简单地说是const是直接按主键或唯一键读取，eq_ref用于联表查询的情况，按联表的主键或唯一键联合查询</font>
    * **ref**：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它**返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体**。
    * **range**：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。**一般就是在你的where语句中出现了between、<、>、in等的查询**。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不会扫描全部索引。
    * **index**：Full Index Scan，index与All区别为index类型只遍历索引树。这通常比All快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）
    * **all**：Full Table Scan，将遍历全表以找到匹配的行。
  * <font color="deeppink">一般来说，得保证查询至少达到range级别，最好能达到ref。</font>
* `possible_keys`
  * **显示可能应用在这张表中的索引，一个或多个**。查询涉及到的字段上若存在索引，则该索引将被列出。**但不一定被查询实际使用**
* `key`
  * key：**实际使用的索引**。如果为NULL，则没有使用索引。**查询中若使用了覆盖索引，则该索引仅出现在key列表中，不会出现在possible_keys列表中**。（覆盖索引：<font color="deeppink">查询的字段与建立的复合索引的个数一一吻合）</font>
* `key_len`
  * **表示索引中使用的字节数**，可通过该列计算查询中使用的索引的长度。**在不损失精确性的情况下，长度越短越好**。
    * 这里的key_len计算是根据字段名所占的字节数来计算的，索引用到的字段越多，key_len就会越长
    * 能用1个索引字段查出来的，就不要用2个，，，
  * key_len显示的值为索引字段的**最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的**
* `ref`
  * **显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值**。查询中与其它表关联的字段，外键关系建立索引
  * ![](/static/2021-08-22-19-46-35.png)
  * ![](/static/2021-08-22-19-50-00.png)
    * ref是索引命中但结果不唯一所以要走一遍索引，eq_ref是索引唯一值就不用找了
* `rows`
  * 根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。
* `Extra`
  * 包含不适合在其他列中显示，但十分重要的额外信息(**前3个重要**)
  * **Using filesort**：说明mysql会对数据**使用一个外部的索引排**序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作成为“文件排序”。
    * 这类SQL语句性能极差，需要进行优化。 典型的，在一个没有建立索引的列上进行了order by，就会触发filesort，常见的优化方案是，在order by的列上添加索引，避免每次查询都全量排序
  * **Using temporary**：**使用了临时表保存中间结果**，MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。
    * 这类SQL语句性能较低，往往也需要进行优化。 典型的，group by和order by同时存在，且作用于不同的字段时，就会建立临时表，以便计算出最终的结果集
  * **Using index**：表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错！**如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作**。
    * 覆盖索引![](/static/2021-08-22-20-13-18.png)
      * 覆盖索引 - select能从索引中取得，不用读取数据行
    * ![](/static/2021-08-22-20-19-00.png)
  * **Using where**：表明使用了where过滤。
  * **Using join buffer**：使用了连接缓存。
  * **impossible where**：where子句的值总是false，不能用来获取任何元组。（查询语句中where的条件不可能被满足，恒为False）
  * **select tables optimized away**：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。
  * **distinct**：优化distinct操作，在找到第一匹配的元组后即停止找相同值的动作。

# 例子

![](/static/2021-08-22-20-29-40.png)

# 索引单表优化例子

建表，insert，查询

![](/static/2021-08-23-13-23-04.png)
![](/static/2021-08-23-13-23-48.png)

索引（只有一个PK，别的索引没有）
![](/static/2021-08-23-13-28-20.png)

查1
![](/static/2021-08-23-13-27-23.png)

* `type` - `ALL`，最坏情况，Extra中出现Using filesort，必须优化

---

开始优化

策略1
![](/static/2021-08-23-13-30-04.png)
![](/static/2021-08-23-13-31-31.png)
![](/static/2021-08-23-13-36-40.png)

策略2
![](/static/2021-08-23-13-39-41.png)
![](/static/2021-08-23-13-39-56.png)

* 重点是using where ：表示Using where：表示优化器需要通过索引回表查询数据；categrory_id通过左前缀索引,中间范围回表查了，之后最后排序再回来查索引
  * 中间夹断了的那个范围,不走索引，而是回表查，回表查完了，排序再回来走索引，所以不会出现ut和uf

# 索引双表优化例子

总结：**左连接建右表，右连接建左表**。理由：以左连接为例，左表的信息全都有，所以右表需要查找，所以建立右表index

---

建表
![](/static/2021-08-23-13-51-20.png)
![](/static/2021-08-23-13-51-59.png)
![](/static/2021-08-23-13-52-29.png)
![](/static/2021-08-23-13-55-50.png)

优化

策略1（左连右表加索引）
![](/static/2021-08-23-13-56-15.png)

策略2（左连左表加索引，意义不大，因为左表结果全要）
![](/static/2021-08-23-13-58-08.png)
![](/static/2021-08-23-13-59-50.png)
![](/static/2021-08-23-13-57-55.png)

策略3（右连接，右表上索引）
![](/static/2021-08-23-14-08-11.png)
![](/static/2021-08-23-14-08-38.png)

# 三表索引优化例子

---

建表
![](/static/2021-08-23-14-10-02.png)

ALL
![](/static/2021-08-23-14-13-09.png)

phone，book上建索引
![](/static/2021-08-23-14-14-03.png)
![](/static/2021-08-23-14-14-30.png)

# JOIN优化

结论：JOIN语句的优化

* 尽可能减少join语句中NestedLoop的循环总次数：“**永远用小结果集驱动大的结果集**”
* 优先优化NestedLoop的内层循环
* 保证join语句中被驱动表上join条件字段已被索引
* 当无法保证被驱动表的join条件字段被索引且内存资源充足的前提下，不要太吝啬joinbuffer的设置

# 索引失效（应该避免）

参考 https://juejin.cn/post/6884036191205720077

& https://www.zhihu.com/question/431438631/answer/1986901539

---

建表SQL
![](/static/2021-08-23-14-26-09.png)
![](/static/2021-08-23-14-26-37.png)
![](/static/2021-08-23-14-27-29.png)

全值匹配（全部使用，部分使用）
![](/static/2021-08-23-14-31-38.png)
![](/static/2021-08-23-14-31-47.png)

## 最佳左前缀法则

**违背最佳左前缀法则** （断了，全表扫，索引失效
![](/static/2021-08-23-15-04-31.png)

* 如果索引了多列，要遵守最左前缀法则。**指的是查询从索引的最左前列开始【并且不跳过索引中的列】**
* 在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边

## 不在索引列上作任何操作

**不在索引列上作任何操作**（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描

![](/static/2021-08-23-15-13-37.png)

## 存储引擎不能使用索引中范围条件右边的列

![](/static/2021-08-23-15-14-36.png)

* 中间主要用于排序产生结果集
* 范围查询确定的情况下，，导致后面字段无序，无法利用索引二分定位（无法在无序的索引B+上定位后面字段）

## 尽量使用覆盖索引

尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *

![](/static/2021-08-23-15-33-47.png)

* 按需取数据，用多少取多少，尽量与索引一致
* Extra中出现了using index很好！

## 减少!=或<>

mysql在使用不等于（！=或者<>）的时候无法使用索引会导致全表扫描

![](/static/2021-08-23-15-36-21.png)

## is null，is not null

is null，is not null也无法使用索引

![](/static/2021-08-23-15-37-38.png)

## like

like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作

![](/static/2021-08-23-15-39-58.png)

* 推荐前缀查询 `xxx%`

问题：解决like ‘%字符串%’时索引不被使用的方法？

![](/static/2021-08-23-15-44-37.png)
![](/static/2021-08-23-15-45-33.png)
![](/static/2021-08-23-15-46-02.png)
![](/static/2021-08-23-15-46-33.png)
![](/static/2021-08-23-15-53-08.png)

* 利用覆盖索引解决两边%的优化问题
* https://segmentfault.com/q/1010000022763847

## 字符串不加单引号索引失效

字符串不加单引号索引失效

![](/static/2021-08-23-16-04-17.png)

## 少用or

少用or，用它来连接时会索引失效

![](/static/2021-08-23-16-04-54.png)

## 总结

![](/static/2021-08-23-16-05-15.png)

# 面试例子

建表，索引
![](/static/2021-08-23-16-14-32.png)
![](/static/2021-08-23-16-15-31.png)
![](/static/2021-08-23-16-15-47.png)

根据一下sql分析索引使用情况
![](/static/2021-08-23-16-16-14.png)
![](/static/2021-08-23-16-16-44.png)
![](/static/2021-08-23-16-16-53.png)

* 全值匹配

全值匹配打乱顺序，仍可以用索引（mysql底层优化
![](/static/2021-08-23-16-18-51.png)

range
![](/static/2021-08-23-16-21-47.png)
![](/static/2021-08-23-16-23-01.png)

order by

* ![](/static/2021-08-23-16-23-43.png)
  * (严格来说c3索引用到了)
* ![](/static/2021-08-23-16-25-10.png)
* ![](/static/2021-08-23-16-26-02.png)
  * 外部排序
* ![](/static/2021-08-23-16-28-09.png)
  * c1查，c2,3用于排序
* ![](/static/2021-08-23-16-29-22.png)
  * order by顺序严格
* ![](/static/2021-08-23-17-30-03.png)
* ![](/static/2021-08-23-17-30-23.png)
* ![](/static/2021-08-23-17-34-53.png)
* ![](/static/2021-08-23-17-32-16.png)
  * 一般都会产生filesort（如果orderby不按顺序，除非先filter出常量了）

group by
![](/static/2021-08-23-17-35-36.png)
![](/static/2021-08-23-17-36-32.png)

* 定值、范围还是排序，一般order by是给个范围
* group by基本上都需要进行排序，会有临时表产生

## 一般性建议

* 对于单键索引，尽量选择针对当前query过滤性更好的索引
* 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好
* 在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引
* 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的

# 查询截取分析

分析

* 观察，至少跑1天，看看生产的慢SQL情况。
* 开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。
* explain+慢SQL分析
* show profile
* 运维经理 or DBA，进行SQL数据库服务器参数调优。

总结

* 慢查询的开启并捕获
* explain+慢SQL分析
* show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况
* SQL数据库服务器的参数调优

# 查询优化

# Exist vs In

永远小表驱动大表，类似嵌套循环Nested Loop

![](/static/2021-08-23-18-22-58.png)
![](/static/2021-08-23-18-26-37.png)

`Exists`

![](/static/2021-08-23-18-31-03.png)

* `SELECT...FROM table WHERE EXISTS(subquery)`
  * 将主查询的数据放到子查询中做条件验证。根据验证结果（True、False）来决定主查询的数据结果是否保留
* **EXISTS（subquery）只返回TRUE或FALSE，因此子查询中的SELECT *也可以是SELECT 1或SELECT ‘X’**，官方说法是实际执行时会忽略SELECT清单，因此没有区别。
* EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担心效率问题，可进行实际检验以确定是否有效率问题。
* EXISTS子查询往往也可以用条件表达式/其他子查询或者JOIN来替代，何种最优需要具体问题具体分析。

exist，in
![](/static/2021-08-23-18-36-50.png)
![](/static/2021-08-23-18-38-50.png)

# ORDER BY优化

ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序

* 参考 https://database.51cto.com/art/201912/607944.htm

---

age,birth索引
![](/static/2021-08-23-18-41-39.png)
![](/static/2021-08-23-18-49-23.png)
![](/static/2021-08-23-18-51-00.png)

---

MySQL支持两种方式的排序

* **FileSort**效率较低。
* **Using Index**，它指MySQL扫描索引本身完成排序。
  * **索引覆盖**
    * 不要用select *

ORDER BY满足两种情况，会使用Index方式排序：

* **ORDER BY语句使用索引最左前列**
* 使用Where子句与ORDER BY子句条件列**组合满足索引最左前列**
* 多字段时要么同升序，要么同降序

**尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀**

* 如果不在索引列上，filesort有两种算法：

## filesort

mysql就要启动双路排序和单路排序

**双路排序**

* MySQL4.1之前是使用双路排序，**字面意思就是两次扫描磁盘，最终得到数据。读取行指针和order by列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对应的数据输出**。
  * **根据条件取出排序字段和行指针信息**，然后在排序区sort buffer中排序，如果buffer不够，则在临时表temporary table中存储排序结果，**完成排序之后，再根据行指针回表读取记录**，该操作可能会导致大量随机I/O操作
* 从磁盘取排序字段，在buffer进行排序，再从磁盘读取其他字段。
* 取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序

**单路排序**

* 从磁盘读取查询需要的所有列，**按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据**。并且把随机IO变成了顺序IO，但是它会使用更多的空间。

:bulb: mysql选择哪个？

* 通过比较系统变量`max_length_for_sort_data`大小和Query语句取出的字段总大小，来判断是否那种算法，如果系统变量更大使用单路；否则多路；
* 因此可以适当提高sort_buffer_size和max_length_for_sort_data系统变量，来增大排序区大小，提高排序效率

**结论及引申出的问题**

* 由于单路是后出的，总体而言好过双路
* 但是用单路有问题
  * ![](/static/2021-08-23-19-13-03.png)
  * 本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。（原因：数据的总大小超过sort_buffer的容量）

## 总结

优化策略

* 少写`select *`
* **增大sort_buffer_size参数的设置**
* **增大max_length_for_sort_data参数的设置**
* Why
* ![](/static/2021-08-23-19-14-24.png)

---

![](/static/2021-08-23-19-59-36.png)
![](/static/2021-08-23-20-22-24.png)

失效
![](/static/2021-08-23-20-32-26.png)

# GROUP BY优化

* group by实质是**先排序后进行分组**，**遵照索引建的最佳左前缀**。
* 当无法使用索引列，增大`max_length_for_sort_data`参数的设置+增大`sort_buffer_size`参数的设置。
* where高于having，能写在where限定的条件就不要去having限定了。

# 慢查询日志

* MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。
* long_query_time的默认值是10，意思是运行10秒以上的语句。
* 由它来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前的explain进行全面分析。

注意

* **默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数**。
* 当然，**如果不是调优需要的话，一般不建议启动该参数**，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。

## 查看是否开启

![](/static/2021-08-23-21-10-38.png)

* 查看是否开启及如何开启
  * `SHOW VARIABLES LIKE ‘%slow_query_log%’;`

开启

* `set global slow_query_log=1;`
  * ![](/static/2021-08-23-21-11-20.png)
  * 只对当前数据库生效，mysql重启后失效
* 永久生效
  * ![](/static/2021-08-23-21-11-51.png)

## 什么样的SQL会被记录

那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢

![](/static/2021-08-23-21-13-15.png)

* 设置慢的阈值时间：set global long_query_time=3;
* 查看当前多少秒算慢：SHOW VARIABLES LIKE ‘long_query_time%’;
* ![](/static/2021-08-23-21-25-03.png)

为什么设置后看不出变化（设置3之后，查询依然显示10）：

* 需要重新连接或新开一个会话才能看到修改值。
* SHOW VARIABLES LIEK ‘long_query_time%’;
* show global variables like ‘long_query_time’;

## 记录慢SQL并后续分析

查询当前系统中有多少条慢查询记录：

![](/static/2021-08-23-21-28-23.png)
![](/static/2021-08-23-21-28-54.png)

* `show global status like ‘%Slow_queries%’;`

## 配置版

![](/static/2021-08-23-21-29-21.png)

# 日志分析工具mysqldumpslow

在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。

**查看mysqldumpslow的帮助信息**

* `mysqldumpslow --help`
* s：是表示按照何种方式排序
* c：访问次数
* I：锁定时间
* r：返回记录
* t：查询时间
* al：平均锁定时间
* ar：平均返回记录数
* at：平均查询时间
* t：即为返回前面多少条的数据
* g：后边搭配一个正则匹配模式，大小写不敏感

## 工作常用参考

![](/static/2021-08-23-21-30-42.png)

# 批量数据脚本

![](/static/2021-08-23-21-32-52.png)

* 存储过程可以有/无返回值

---

建表sql

![](/static/2021-08-23-21-33-43.png)
![](/static/2021-08-23-21-34-10.png)

## 创建函数报错（开启过慢查询日志导致）

![](/static/2021-08-23-21-34-59.png)

设置参数log_bin_trust_function_creators

## 创建函数

自定义函数，保证每条数据都不同

随机产生字符串
![](/static/2021-08-23-21-35-35.png)

随机产生部门编号
![](/static/2021-08-23-21-36-16.png)

## 删除函数

![](/static/2021-08-23-21-36-33.png)

## 创建存储过程

![](/static/2021-08-23-22-01-30.png)
![](/static/2021-08-23-22-01-46.png)

## 调用存储过程

![](/static/2021-08-23-22-02-07.png)

# SHOW PROFILE

是什么：是mysql提供的可以用来**分析当前会话中语句执行的资源消耗情况**。可以用于SQL的调优的测量（单纯用来测量性能的

默认情况下，参数处于关闭状态，并保存最近15次的运行结果

## 分析步骤

是否支持，**看看当前的mysql版本是否支持**

![](/static/2021-08-23-22-06-26.png)

* `show variables like ‘profiling’;`
  * 默认关闭

**开启功能**，默认是关闭，使用前需要开启

![](/static/2021-08-23-22-07-03.png)

* `set profiling = on;`

**运行SQL**

* `select * from emp group by id%10 limit 150000;`
* `select * from emp group by id%20 order by 5;`

**查看结果（所有执行的SQL**，

![](/static/2021-08-23-22-09-44.png)

* `show profiles;`

**诊断SQL**，

![](/static/2021-08-23-22-11-07.png)

* `show profile cpu, block io for query [上一步前面的问题SQL数字号码(query_id)];`
  * 如`show profile cpu,block io for query 3`

## 参数备注

![](/static/2021-08-23-22-13-43.png)

## 日常开发需要注意的参数（结论

![](/static/2021-08-23-22-14-34.png)

**converting HEAP to MyISAM**：查询结果太大，内存都不够用了往磁盘上搬了

**Creating tmp table**：创建临时表

* 拷贝数据到临时表
* 用完再删除

**Copying to tmp table on disk**：把内存中临时表复制到磁盘，危险！！

**locked**

# 全局查询日志

**永远不要在生产环境开启这个功能**

配置启动

![](/static/2021-08-23-22-18-21.png)

编码启用

![](/static/2021-08-23-22-18-40.png)

# 应用优化

绍了很多数据库的优化措施。 但是在实际生产环境中，由于数据库本身的性能局限，就必须要对 前台的应用进行一些优化，来降低数据库的访问压力。

* **使用连接池**
  * 对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有 必要建立 数据库连接池，以提高访问的性能。
* **减少对 MySQL 的访问**
  * ![](/static/2021-08-24-12-38-36.png)
  * 能够一次连接就获取到结果的，就不用两次连接，这样可 以大大减少对数据库无用的重复请求。
  * **增加cache层**
    * 在应用中，我们可以在应用中增加 缓存 层来达到减轻数据库负担的目的。 缓存层有很多种，也有很多实现方式， 只要能达到降低数据库的负担又能满足应用需求就可以。 因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架 (Mybatis, Hibernate) 提供的一 级缓存 / 二级缓存，或者使用 redis 数据库来缓存数据 。
      * 缓存中有数据就减少了访问关系型数据库的需求
* **负载均衡** （多台mysql
  * **利用 MySQL 复制分流查询**
    * ![](/static/2021-08-24-12-40-39.png)
    * 主从读写分离
  * **采用分布式数据库架构**
    * 分布式数据库架构适合大数据量、 负载高的情况，它有良好的拓展性和高可用性。 通过在多台服务器之间分布数 据，可以实现在多台服务器之间的负载均衡，提高访问效率。
    * 均匀分布到各个节点

# 查询缓存

开启 Mysql 的查询缓存，**当执行完全相同的 SQL 语句的时候，服务器就会直接从缓存中读取结果**，当数据被**修改， 之前的缓存会失效**，修改比较频繁的表不适合做查询缓存。

## 流程

![](/static/2021-08-24-12-43-11.png)

## 配置

![](/static/2021-08-24-12-44-05.png)
![](/static/2021-08-24-12-44-30.png)

变量含义

![](/static/2021-08-24-12-44-41.png)

## 开启查询缓存

MySQL 的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。 query_cache_type 该参数的可取值有三个 ：

![](/static/2021-08-24-12-45-44.png)

配置开启
![](/static/2021-08-24-12-45-51.png)

* 然后就可以在命令行执行 SQL 语句进行验证 ， 执行一条比较耗时的 SQL 语句，然后再多执行几次，查看后面几次的 执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。

## SELECT选项

控制当前select语句是否做缓存

可以在 SELECT 语句中指定两个与查询缓存相关的选项 ： 

* `SQL_CACHE` : **如果查询结果是可缓存的，并且 `query_cache_type` 系统变量的值为 ON 或 DEMAND** ， 则缓存查询 结果 
* `SQL_NO_CACHE` : **服务器不使用查询缓存。 它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果**。 

```sql
SELECT SQL_CACHE i d, name FROM customer; 
SELECT SQL_NO_CACHE i d, name FROM customer;
```

## 失效情况

SQL 语句不一致的情况， 要想命中查询缓存，查询的 SQL 语句必须一致。

* ![](/static/2021-08-24-12-50-09.png)

当查询语句中有一些不确定的时，则不会缓存。 如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database()

* ![](/static/2021-08-24-12-50-25.png)

不使用任何表查询语句。

* `select ' A' ;`

查询 mysql ， i nformation_schema 或 performance_schema 数据库中的表时，不会走查询缓存。

* select * from i nformation_schema.engines;

在存储的函数，触发器或事件的主体内执行的查询

如果**表更改**，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。 这包括使用 MERGE 映射到 已更改表的表的查询。 一个表可以被许多类型的语句，如被改变 I NSERT ， UPDATE ， DELETE ， TRUNCATE TABLE ， ALTER TABLE ， DROP TABLE ， 或 DROP DATABASE

# 内存管理&优化

## 内存优化原则

1 ） **将尽量多的内存分配给 MySQL 做缓存**，但要给操作系统和其他程序预留足够内存。

2 ） MyISAM 存储引擎的数据文件读取依赖于操作系统自身的 I O 缓存，因此，**如果有 MyISAM 表，就要预留更多的 内存给操作系统做 I O 缓存**。

3 ） **排序区、 连接区等缓存是分配给每个数据库会话（ session ） 专用的，其默认值的设置要根据最大连接数合理 分配**，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。

## MyISAM 内存优化

myisam 存储引擎使用 key_bufer 缓存索引块，加速 myisam 索引的读写速度。 对于 myisam 表的数据块， mysql 没 有特别的缓存机制，完全依赖于操作系统的 I O 缓存。

`key_bufer_size`

* ![](/static/2021-08-24-12-56-10.png)

`read_bufer_size`

* ![](/static/2021-08-24-12-56-28.png)

`read_rnd_bufer_size`

* ![](/static/2021-08-24-12-56-56.png)

## InnoDB 内存优化

innodb 用一块内存区做 I O 缓存池，**该缓存池不仅用来缓存 i nnodb 的索引块，而且也用来缓存 i nnodb 的数据块**。（都存储在IO缓存池）

`innodb_bufer_pool_size`

* ![](/static/2021-08-24-12-58-13.png)

`i nnodb_log_bufer_size`

* ![](/static/2021-08-24-12-58-24.png)

# Mysql 并发参数调整

从实现上来说， MySQL Server 是多线程结构，包括后台线程和客户服务线程。 多线程可以有效利用服务器资源， 提高数据库的并发性能。 在 Mysql 中，控制并发连接和线程的主要参数包括 max_connections 、 back_log 、 thread_cache_size 、 table_open_cahce 。

## max_connections

![](/static/2021-08-24-13-01-30.png)

## back_log

![](/static/2021-08-24-13-02-59.png)

## table_open_cache

![](/static/2021-08-24-13-03-45.png)

## thread_cache_size

![](/static/2021-08-24-13-04-26.png)

## innodb_lock_wait_timeout

![](/static/2021-08-24-13-05-23.png)

# 锁问题

锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。

在数据库中，除传统的计算资源（如 CPU 、 RAM 、 I /O 等）的争用以外，数据也是一种供许多用户共享的资源。如 何保证数据并发访问的一致性、 有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的 一个重要因素。 从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

## 锁分类

从对数据操作的粒度分

* 1 ） **表锁**：操作时，会锁定整个表。
* 2 ） **行锁**：操作时，会锁定当前操作行。

从对数据操作的类型分：

* 1 ） **读锁**（共享锁） ： 针对同一份数据，多个读操作可以同时进行而不会互相影响。
* **写锁**（排它锁） ： 当前操作没有完成之前，它会阻断其他写锁和读锁

## Mysql不同引擎锁机制

相对其他数据库而言，
MySQL 的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。 下表中罗 列出了各存储引擎对锁的支持情况

![](/static/2021-08-24-13-09-57.png)

# 事务 & ACID属性

事务是由一组 SQL 语句组成的逻辑处理单元。 

* 事务具有以下 4 个特性，简称为事务 ACID 属性。
* ![](/static/2021-08-24-13-26-58.png)

并发事务处理带来的问题

![](/static/2021-08-24-13-27-21.png)

## 事务隔离级别

![](/static/2021-08-24-13-29-14.png)
![](/static/2021-08-24-13-29-27.png)

# MyISAM 表锁

MyISAM 存储引擎只支持表锁，这也是 MySQL 开始几个版本中唯一支持的锁类型。

## myISAM表锁模式

**MyISAM 在执行查询语句（ SELECT ） 前，会自动给涉及的所有表加读锁，在执行更新操作（ UPDATE 、 DELETE 、 I NSERT 等）前，会自动给涉及的表加写锁**，这个过程并不需要用户干预，因此，用户一般**不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁**。

显示加表锁语法

* ![](/static/2021-08-24-13-11-24.png)

---

例子 - 读锁（共享锁）查

![](/static/2021-08-24-13-11-53.png)
![](/static/2021-08-24-13-14-55.png)
![](/static/2021-08-24-13-15-46.png)

例子  - 读锁写

![](/static/2021-08-24-13-16-47.png)

---

例子 - 写锁（其他客户端不能读也不能写）

![](/static/2021-08-24-13-18-59.png)
![](/static/2021-08-24-13-19-18.png)

## MyIsam锁结论

![](/static/2021-08-24-13-21-01.png)

## MyISAM锁争用情况

`show open tables ；`

![](/static/2021-08-24-13-22-24.png)

* 可以看那张表被锁

`show status l i ke ' Table_locks%' ;`

![](/static/2021-08-24-13-23-04.png)

* 如果wait参数比较大，，征用情况严重，可以考虑优化

# InnoDB 行锁

行锁特点 ： 

* 偏向 I nnoDB 存储引擎，**开销大，加锁慢；会出现死锁**；
* **锁定粒度最小，发生锁冲突的概率最低 , 并发度 也最高**。 

I nnoDB 与 MyISAM 的最大不同有两点：一是**支持事务（因为行级锁**；二是 **采用了行级锁**。

## InnoDB 的行锁模式

![](/static/2021-08-24-13-30-43.png)

* 对于 UPDATE 、 DELETE 和 I NSERT 语句， I nnoDB 会自动给涉及数据集加排他锁（ X) ； 
* 对于普通 SELECT 语句， I nnoDB 不会加任何锁；

---

显式加锁

![](/static/2021-08-24-13-31-12.png)

## 例子

![](/static/2021-08-24-13-31-57.png)
![](/static/2021-08-24-13-36-03.png)

## 行锁升级表锁

操作不当，如果不通过索引条件检索数据，那么 I nnoDB 将对表中的所有记录加锁，实际效果跟表锁一样。

![](/static/2021-08-24-13-37-58.png)
![](/static/2021-08-24-13-40-20.png)

## 间隙锁危害

当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时， I nnoDB 会给符合条件的已有数据进 行加锁； **对于键值在条件范围内但并不存在的记录，叫做 " 间隙（ GAP**） " ， I nnoDB 也会对这个 " 间隙 " 加锁，这 种锁机制就是所谓的 间隙锁（ Next-Key 锁）

![](/static/2021-08-24-13-56-31.png)

* 尽量精确这个范围，避免这个危害

## InnoDB 行锁争用情况

![](/static/2021-08-24-13-57-47.png)

* `show status l i ke ' i nnodb_row_lock%' ;`
* avg & waits

## 总结 & 建议

![](/static/2021-08-24-14-00-56.png)

# 主从复制

复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行 （ 也叫重做） ， 从而使得从库和主库的数据保持同步。

MySQL 支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。

原理 - 3步
![](/static/2021-08-24-14-04-26.png)

## 优势

MySQL
复制的有点主要包含以下三个方面：

* **主库出现问题，可以快速切换到从库提供服务**。
* 可以在从库上执行查询操作，从主库中更新，**实现读写分离，降低主库的访问压力**。
* 可以在**从库中执行备份，以避免备份期间影响主库的服务**。

## 搭建

master

![](/static/2021-08-24-14-06-03.png)
![](/static/2021-08-24-14-06-19.png)

* `server-id=1`
* 开启二进制日志
* ...
* 创建账户（用来完成复制

slave

![](/static/2021-08-24-14-08-08.png)
![](/static/2021-08-24-14-08-22.png)

## 验证同步

![](/static/2021-08-24-14-09-56.png)