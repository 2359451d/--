# Build, Release and Dependency Management

## 为什么：WHY use Build, Release and Dependency Management

为什么要使用构建、发行版和依赖管理？

![](/static/2020-11-10-21-37-47.png)

* 所有项目依赖于其他软件
* 依赖**编译过程可能慢&非自动化**
* 启用“oven ready components”的缓存

## 构建工具：Tooling

构建工具

![](/static/2020-11-10-21-40-27.png)

## 构建管理：Build Management

构建管理

### 自动化构建术语：Terminology - Auto Build Management

management包含build configuration files

* mixture of statements
* targets
  * abstract goals within the software management life cycle
  * example: resolving the dependencies, downloading the necessary files, compile the produced code, testing binary produced reports
  * 1 target may depend on other targets
* mappings
  * relationships between source & generated artefacts （.java->.class）
  * useful for automating the build process
* tasks
  * actions: build management system will take to satisfy the mappings

<font color="red">build process should be repeatable</font>

![](/static/2020-11-10-21-41-41.png)

![](/static/2020-11-10-21-42-36.png)

### 典型目标？指令：Typical Targets

![](/static/2020-11-10-21-44-03.png)

* resolve
  * collecting the dependencies for projects
* compile
  * source code tend to be the binary files generated by the results produced
* test
  * units or integration suits are executed to compile code
* package
  * compile binary formats(already compiled artifacts from build process) for suitable distribution
* **Install**
  * install the packages to local system & infrastructure
* **deploy**
  * package is published to a remote release repositry
* clean
  * removes generated binary files (of build process)
  * intermidate files are generated. from one of the target between test~install
* cleanall
  * removes all the artefacts generated
  * return working copy to presisting only contain the configuration items

### 惯例优先原则: Configuration by Convention

![](/static/2020-11-10-21-46-34.png)
![](/static/2020-11-10-21-49-35.png)

* 许多软件项目（框架）有相似结构
* 用于管理发布的工作流程任务也是类似的
* **遵循构建/发行版工具的规范**
  * 允许例外，不用严格遵守（只要规范允许）
  * developers should follow the convention set out by the release tool of organisation of softwares project
* **好处**
  * 尽量减少需要维护的配置代码
  * 促进对于项目的理解 & 可读性

---

> When the convention implemented by the tool matches the desired behavior, it behaves as expected without having to write configuration files. Only when the desired behavior deviates from the implemented convention is explicit configuration required.

**当工具实现的约定与所需的行为匹配时，它就会按照预期的方式运行，而无需编写配置文件。只有当期望的行为偏离实现的约定时，才需要显式配置**。

> Ruby on Rails' use of the phrase is particularly focused on its default project file and directory structure, which prevent developers from having to write XML configuration files to specify which modules the framework should load, which was common in many earlier frameworks.

Ruby on Rails 对这个短语的使用主要集中在默认的项目文件和目录结构上，这使得开发者不必编写 XML 配置文件来指定框架应该加载哪些模块，这在许多早期的框架中都很常见。

#### 例子：CbyC Maven Project Layout

![](/static/2020-11-10-21-57-29.png)
![](/static/2020-11-10-21-57-55.png)
![](/static/2020-11-10-21-58-08.png)

## 依赖-发行版管理：Dependency & Release Management

![](/static/2020-11-10-21-58-42.png)
![](/static/2020-11-10-22-04-40.png)

* 依赖类型
  * **环境型依赖** - conditions must exist surrounding software infrastructures in order to particular software to work
    * **显式依赖** - explictly specified in the configuration & being checked by the system
      * 显式依赖原则指出: 方法和类应该显式地需要(通常通过方法参数或构造函数参数)任何他们需要的合作对象，以便正确地运行
    * **隐式依赖** - assume to exist, but not explicitly documented within the configuration scripts
      * JDK version xxx might exist
  * **应用型依赖** - dependecy on other software within the software build artefacts
    * java libray ...
* 仓库种类
  * 公开
    * standard third party libray
  * 私有/本地
    * internal network to organisation
    * a stable version of component
* 任务
  * 创建要求
  * 获取每个依赖项的可用版本列表
  * 选择和检查版本组合的可行性
  * 找回丢失的artefacts

### 发行版/依赖控制：Release/Dependency versioning

![](/static/2020-11-10-22-11-32.png)

* **标签制度 labelling scheme**
  * 来描述同一component的不同发行版是有用的
* 包含在依赖性规范中
  * 为了以后其他组件整合，用于筛选发行版
* 每个版本标签
  * 是**对版本控制存储库中的commit的引用**
* 可以**包含关于发布的信息**
  * 与前一版本和未来版本的时间关系
  * 发布的内容
  * 发布的目的

### 指明依赖项：Specify dependencies

![](/static/2020-11-10-22-13-44.png)

* 一个项目总是有**有传递特性的依赖**
  * 如果组件A依赖组件B，组件B依赖组件C，那么A就会自动产生对C的依赖，以此类推。这使我们不必再关心众多依赖背后的关系，只需要着眼于自己需要的组件，很方便
* 依赖的关系图可能是循环的
  * one project depends on another project depends on the original one,,complicated resolution
* 依赖解析是NPC问题
* 使用**不同策略**来找到满意的依赖组合
  * ‘Nearest’ version wins (e.g. Maven, PIP)最近依赖优先(nearest definition wins)
  * 允许在同一程序集中使用多个版本依赖

🍊 良好实践

![](/static/2020-11-10-22-18-44.png)

* 依赖解析优化 how to constraint the dependencies
  * 确保成功的依赖解析是一种艺术形式
* **受限制的规范**可能导致不兼容的依赖组合
* 过于受限的规范限制了灵活性
  * 需要更多的努力来维护，并且可能会持续使用较旧的、错误较多的依赖版本
* **可用时迁移到依赖新版本**
* 不要依赖**传递性依赖关系**

---

传递依赖会使得项目依赖空间逐渐扩展。当依赖非常多时，不可避免地会出现相同组件版本不同的情况。Maven内置了依赖仲裁（dependency mediation）机制来处理该问题，具体来说有以下两条。

* 最近依赖优先（nearest definition wins）
* 最先声明优先（first declaration wins）

### 发行版类型：Types of Release

![](/static/2020-11-10-22-25-12.png)

* 组成Release
  * 核心可执行文件 - convert binary ifles
  * 定制可执行文件 - exetuable platform?
  * 可选的扩展 - a customer requires
  * 资料来源
  * 文档
  * 数据集
  * 完成release
    * all of the core binary & ... above
* 目的Release
  * 前沿，**快照**
    * release of each commit of this project
  * 增量式
  * 夜间建立
    * server to run integration tests as
    * too slow to run at every commit
  * 测试版本
    * package release which could be provided to trusted third party to undertake user tests(prior to publish to generic public or wide variety of customers)
  * 发行版候选
    * special kind of beta tests
    * have the potential to be the final version of release
  * 生产版本
    * general release to introduced to customers

> 版本存储库保存版本，快照存储库保存快照。在 maven 中，快照被定义为以 -SNAPSHOT 结尾的版本的工件。部署时，快照将转换为时间戳。根据定义，快照是可变的，版本是不可变的。这就是为什么 Nexus 让你把它们分开存储，因为通常你不在乎丢失快照，但是你会在乎丢失发行版。这使得快照清理更容易处理。
>
> Snapshot Repository vs Release Repository

### 发行版分支：Release Branches

![](/static/2020-11-10-22-30-42.png)
![](/static/2020-11-10-22-30-57.png)

* 允许开发团队为客户准备一个，**新的稳定发行版**
* 在发行版分支中，**只允许支持错误修复的更改**
  * **only bug fixed are merged in release branches** -- 这种时候才能创建新release branche?
* 发行版中的 **Bug 修复可以合并到master分支**中
* 新的特性继续在master中开发

### 不同类型API的更改：Changes to different types of APIs

![](/static/2020-11-10-22-34-06.png)

API的可见性决定了，API如何被documented & communicated

* private
  * 外部不可访问
  * document could be minimum: would have a set of nodes, implementation details?
  * 不应该对依赖有任何影响，因为它不能访问
* public
  * 外部可以访问
  * 文档类似published，可能造成误会
* published
  * 内部团队特殊用途，
  * how the impact of change will affect users
  * and how integrate new ways

### 版本语义控制：Semantic Versioning

![](/static/2020-11-10-22-36-47.png)

* 标签
  * 表示发布状态、类型或其他信息
* 补丁/快照增量 Patch Increment
  * 表示一个不破坏 bug 的修复更改,【不应该影响依赖】
  * non-breaking
* 次要的增量 Minor Increment
  * 表示不破坏的特性增加更改
  * non-breaking
* 主要增量 Major Increment
  * 某些方面可能对依赖有影响
  * 表示对已公布的 API 进行突发性更改
  * breaking

### 过时特性：Deprecating Features

![](/static/2020-11-10-22-41-40.png)
![](/static/2020-11-10-22-42-06.png)

> 定义: 出于兼容性原因而保留的特性，但将从更广泛系统的未来版本中删除

过时API - 文档描述

![](/static/2020-11-10-22-42-35.png)

* **废弃作用域**
* **包含新机制的软件发布版本**
* 一个schedule，
  * **何时废弃的功能将被删除**
* 解释**为什么这个功能被废弃了**
* 关于如何更改相关代码的描述

## 迁移计划和脚本: Migration Plans & Scripts

![](/static/2020-11-10-22-48-18.png)

* 迁移计划
  * 一种估计迁移需要多长时间的方法
  * 软件新版本已知问题的摘要
  * 数据迁移，包括必要的备份和数据格式的更改
  * 更改的软件的任何依赖项的升级
  * 如何调整现有源代码以适用使用新published的api

## Summary

![](/static/2020-11-10-22-50-01.png)

构建、发布和依赖管理以及相互依赖的工作流，通过允许对变更进行整理和缓存，从而简化组件间变更管理的过程。

## 什么是测试发行版？

> 测试阶段通常开始于软件功能完成，但可能包含一些已知或未知的错误。向用户提供测试版本的过程称为测试版本发布，这通常是该软件第一次在**开发组织之外可用**
> A Beta phase generally begins when the software is feature complete but likely to contain a number of known or unknown bugs. ... The process of delivering a beta version to the users is called beta release and this is typically the first time that the software is available outside of the organization that developed it.

What is Beta Testing?
什么是 Beta 测试？
Beta testing is the final round of testing before a product is finally released to a wide audience. The objective is to uncover as many bugs or usability issues as possible in this controlled setting.

Beta 测试是产品最终发布给广大用户之前的最后一轮测试。我们的目标是在这个受控的设置中发现尽可能多的 bug 或者可用性问题。

Beta testers are “real” users and conduct their testing in a production environment running on the same hardware, networks, etc., as the final release. This also means it’s the first chance for full security and reliability testing because those tests can’t be conducted in a lab or stage environment.

Beta 测试人员是“真正的”用户，他们在与最终版本相同的硬件、网络等上运行的生产环境中进行测试。这也意味着这是第一次进行全面的安全性和可靠性测试，因为这些测试不能在实验室或阶段性环境中进行。

Beta tests can either be open or closed. In an open beta test, anyone is able to use the product and is usually presented with some messaging that the product is in beta and given a method for submitting feedback. In a closed beta, the testing is limited to a specific set of testers, who may be composed of current customers, early adopters and/or paid beta testers. Sometimes they are conducted by diverting a certain percentage of users to the beta site instead of the current release.

测试可以是开放的，也可以是封闭的。在公开测试中，任何人都可以使用该产品，并且通常会收到一些信息，告诉他们该产品还处于测试阶段，并且提供了一种提交反馈的方法。在封闭测试版中，测试仅限于一组特定的测试人员，他们可能由现有客户、早期使用者和/或付费测试人员组成。有时候他们是通过将一定比例的用户转移到 beta 站点而不是当前版本来实现的。

