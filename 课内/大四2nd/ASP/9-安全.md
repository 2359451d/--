# Content

第9讲讨论了系统编程中的安全考虑。它讨论了内存安全在安全软件中的关键作用，并强调了由于缺乏内存安全而导致的未定义行为，以及可能导致的安全漏洞。讲座强调了使用强类型、内存安全语言编程的好处。讲座的后面部分讨论了安全处理和解析从网络接收的数据的方法，以及类型驱动设计对安全的可能好处。

* [Content](#content)
* [1内存安全：Memory Safety](#1内存安全memory-safety)
* [内存安全(语言)定义：Memory Safety in Programming Languages](#内存安全语言定义memory-safety-in-programming-languages)
* [未定义行为：Undefined Behaviour](#未定义行为undefined-behaviour)
* [未定义行为-类型不安全的分配: Type unsafe allocation](#未定义行为-类型不安全的分配-type-unsafe-allocation)
* [未定义行为-分配前使用: Use before allocation](#未定义行为-分配前使用-use-before-allocation)
* [未定义行为-显式释放后使用:use after explicit free()](#未定义行为-显式释放后使用use-after-explicit-free)
* [未定义行为-隐式释放后使用:use after implicit free](#未定义行为-隐式释放后使用use-after-implicit-free)
* [未定义行为-错误类型转换：Use of memory as the wrong type](#未定义行为-错误类型转换use-of-memory-as-the-wrong-type)
* [未定义行为-在非字符串值上使用字符串函数：Use of string functions on non-string values](#未定义行为-在非字符串值上使用字符串函数use-of-string-functions-on-non-string-values)
* [未定义行为-堆分配溢出：Heap Allocation Overflow](#未定义行为-堆分配溢出heap-allocation-overflow)
* [未定义行为-数组越界(溢出))：Array Bounds overflow](#未定义行为-数组越界溢出array-bounds-overflow)
* [未定义行为-指针算术：Arbitrary pointer arithmetic](#未定义行为-指针算术arbitrary-pointer-arithmetic)
* [未定义行为-使用未初始化内存：Use of uninitialised memory](#未定义行为-使用未初始化内存use-of-uninitialised-memory)
* [未定义行为-通过空指针使用内存：•	Use of memory via null pointer](#未定义行为-通过空指针使用内存use-of-memory-via-null-pointer)
* [其他未定义行为](#其他未定义行为)
* [非内存安全语言影响: Impact of Memory Unsafe Languages](#非内存安全语言影响-impact-of-memory-unsafe-languages)
* [内存不安全-对安全影响：Security](#内存不安全-对安全影响security)
* [内存不安全缓解：Mitigations for memory unsafe languages](#内存不安全缓解mitigations-for-memory-unsafe-languages)
* [以内存安全语言渐进式重写代码:Gradually Rewrite Code into a memory Safe Language](#以内存安全语言渐进式重写代码gradually-rewrite-code-into-a-memory-safe-language)
* [==================](#)
* [2解析和网络安全:Parsing and Network Security](#2解析和网络安全parsing-and-network-security)
* [可远程利用的漏洞:Remotely Exploitable Vulnerabilities](#可远程利用的漏洞remotely-exploitable-vulnerabilities)
* [解析未信任输入：Parsing Untrusted Input](#解析未信任输入parsing-untrusted-input)
* [健壮性原则（Postel's Law): The Robustness Principle](#健壮性原则postels-law-the-robustness-principle)
* [定义合法输入&失败响应：Define Legal Inputs and Failure Responses](#定义合法输入失败响应define-legal-inputs-and-failure-responses)
* [生成解析器：Generate the Parser](#生成解析器generate-the-parser)
* [定义可解析协议：Define Parsable Protocols](#定义可解析协议define-parsable-protocols)
* [Parsing and LangSec](#parsing-and-langsec)
* [==================](#-1)
* [3现代类型系统&安全：Modern Type Systems and Security](#3现代类型系统安全modern-type-systems-and-security)
* [安全漏洞原因：Causes of Security Vulnerabilities](#安全漏洞原因causes-of-security-vulnerabilities)
* [显式类型：Prefer Explicit Types](#显式类型prefer-explicit-types)
* [谨慎数据转换：Convert Data Carefully](#谨慎数据转换convert-data-carefully)
* [幻像类型添加语义标签：Use Phantom Types to add semantic Tags](#幻像类型添加语义标签use-phantom-types-to-add-semantic-tags)
* [No Silver Bullet](#no-silver-bullet)
* [责任与道德:Liability and Ethics](#责任与道德liability-and-ethics)
* [==================](#-2)
* [Reading](#reading)

# 1内存安全：Memory Safety

讲座的第一部分讨论了内存安全的重要性，以及缺乏内存安全在安全漏洞中所起的作用。参照语言的类型系统，它描述了什么是内存安全，并介绍了非内存安全语言中未定义行为的概念。随后描述了C语言程序中可能出现的与缺乏内存安全有关的各种类型的未定义行为。讲座最后强调了多年来系统代码中普遍存在的与内存安全有关的安全漏洞的一些统计数据，并提出了各种缓解措施和方法，以帮助摆脱内存不安全代码。

# 内存安全(语言)定义：Memory Safety in Programming Languages

![](/static/2022-05-08-19-44-11.png)

- **内存安全语言是一种确保唯一被访问的内存是由程序拥有的，并且这种访问是以符合数据声明类型的方式进行的语言**。•	A memory safe language is one that ensures that the only memory accessed is that owned by the program, and that such access is done in a manner consistent of the declared type of the data
  - 程序可以通过其全局变量和局部变量，或通过对它们的显式引用来访问内存。•	The program can access memory through its global and local variables, or through explicit references to them
  - 程序可以通过对堆内存的显式引用来访问它所分配的堆内存•	The program can access heap memory it allocated via an explicit reference to that memory
  - 所有的访问都要遵守语言的类型规则•	All accesses obey the type rules of the language
- **内存不安全的语言不能阻止破坏类型规则的访问**。•	Memory unsafe languages fail to prevent accesses that break the type rules
  - C和C++声明这种行为是未定义的，但没有做任何事情来防止它发生•	C and C++ declare such behaviour to be undefined, but do nothing to prevent it from occurring

> 内存安全语言是一种保证唯一可以被访问的内存是程序所拥有的，并且所有对该内存的访问都是以符合数据类型的方式进行的语言。因此，程序只能通过它的全局变量、局部变量或通过它们的显式引用来访问内存。它不能访问不在任何变量中的内存，也不能从任何变量中被引用。它只能访问堆内存，如果它有对该内存的显式引用，并且它访问内存的方式与该内存的类型一致。例如，如果数值以整数形式写入内存，就不能以浮点值形式读回，除非在范围内有一个显式转换。它不能对不同类型的数据进行不一致的处理。a memory safe language is a language that assures that the only memory that can be accessed is that which is owned by the program, and that all access to that memory are done in a manner which is consistent with the types of data. So the program can only access memory through its global variables, through its local variables, or through explicit references from them. It can't access memory which isn't in any of its variables, or isn't referenced from any of those variables. It can only access heap memory if it's got an explicit reference to that memory, and the way in which it accesses memory is consistent with the type of the memory. If the value is written into memory as an integer, it can’t be read back as a floating point value, for example, unless there's an explicit conversion in scope. It can't treat the data inconsistently for different types. 
> 内存不安全的语言是一种不能防止破坏这些类型规则的访问的语言。内存不安全的语言是一种允许访问程序没有明确拥有的内存的语言，或者允许以不安全类型的方式访问内存。A memory unsafe language is a language which fails to prevent accesses which break these typing rules. A memory unsafe language is a language which allows access to memory which the program doesn't explicitly own, or which allows memory to be accessed in a type unsafe way. 
> 现在有很多安全语言的例子，内存安全语言。Java、Scala、Rust、Go、Python、Ruby、Tcl、FORTRAN、COBOL、Modula-2、Occam、Erlang、Ada、Pascal、Haskell等等，还有一大堆。Now there are many examples of safe languages, memory safe languages: Java, and Scala, and Rust, and Go, and Python, and Ruby, and Tcl, and FORTRAN, and COBOL, and Modula-2, and Occam, Erlang, and Ada, and Pascal, and Haskell and a whole bunch more. 
> 那些不安全的语言是一个更小的集合：汇编语言。C、C++和Objective C，据我所知，就这些了。而这些语言并不阻止破坏类型规则的访问，比如说它们有。他们所做的是，相反，宣布这种行为是未定义的。他们说 "你不应该这样做"，他们说 "这样做是不合法的"，但在这些情况下，如果执行了未定义的访问，程序将继续进行，只是不清楚行为会是什么。它没有说明行为将是什么。The ones which are unsafe are a much smaller set: assembly language. C, C++, and Objective C. As far as I know, that's it. And these languages don't prevent accesses which break the type rules, such that they have. What they do is, rather, declare such behaviour to be undefined. They say “you shouldn't do this”, they say “it's not legal to do this”, but in these cases the program will continue if the undefined accesses are performed, it's just not clear what the behaviour will be. It doesn't specify what the behaviour will be.

# 未定义行为：Undefined Behaviour

在C和C++中会出现哪些类型的内存不安全行为？•	What types of memory unsafe behaviour can occur in C and C++?

# 未定义行为-类型不安全的分配: Type unsafe allocation

类型不安全的分配

```c
double *d = malloc(sizeof(float));
```

* 调用malloc()时，不检查分配的内存量是否与存储类型所需的大小一致A call to malloc() does not check if the amount of memory allocated corresponds to the size required to store the type
* 一个内存安全的语言在编译时要求分配的大小与被分配类型的大小相匹配。A memory safe language will require the size of the allocation to match the size of the allocated type at compile time
* 操作应该是 "为T类型的对象分配足够的内存并返回对T的引用"，而不是 "分配n个字节的内存并返回一个未定型的引用"Operation ought to be “allocate enough memory for an object of type T and return a reference-to-T” and not “allocate n bytes of memory and return an untyped reference”

> 什么类型的行为是未定义的？也许是类型不安全的分配。有可能像我们在幻灯片上看到的那样写C语言代码，我们分配内存来保存浮点值的大小，并把它当作一个双精度的浮点值来引用。在这种情况下，我们看到的是，对malloc()的调用并没有检查分配的内存量是否与被访问的类型相一致。What types of behaviour are undefined? maybe it's a type unsafe allocation. It’s possible to write C code like we see on the slide here, where we allocate memory to hold the size of floating point value, and we reference it as if it was a double precision float. And in this case, what we see is that the call to malloc() does not check if the amount of memory allocated corresponds to the type by which it's being accessed. 
> 在一个典型的64位机器上，这是为32位浮点类型分配内存，然后当它被访问时，它被当作64位类型来访问，并溢出了空间。一个内存安全的语言会要求分配的大小与将被存储在其中的值的大小相匹配。如果你为一个浮点值分配空间，你就在其中存储浮点值。如果你试图为一个浮点值分配空间，并把它作为一个双数来访问，它不应该被编译。On a typical 64-bit machine, this is allocating memory for a 32-bit floating point type, and then when it's accessed, it’s accessed as a 64 bit-type, and overflows the space. A memory safe language would require that the size of the allocation match the size of the value which will be stored in it. If you're allocating space for a floating point value, you store floating point values in it. If you try to access to allocate space for a floating point value and access it as a double, it shouldn't compile. 
> 所以操作应该是，为一个T类型的对象分配足够的内存，并返回一个T类型的引用，该引用只能被分配给一个持有该类型引用的变量。So the operation ought to be, allocate enough memory for an object of type T, and return a reference to type T, which can only be assigned to a variable which holds a reference of that type. 
> 但在C语言中，我们所拥有的是一个分配一定数量内存的函数，并返回一个未定型的引用。这就是缺乏安全性的地方；分配没有类型化。C语言不知道malloc()的值中会存储什么，因此它不能检查它是否足够大以容纳被存储的值。What we have in C, though, is a function which allocates a certain amount of memory and a returns an untyped reference. And that's where the lack of safety comes in; there's no typing of the allocations. And C doesn't know what's going to be stored in a malloc()-ed value, and therefore it can't check that it's big enough to hold the values that are being stored there.

# 未定义行为-分配前使用: Use before allocation

```c
char *buffer;

int rc = recv(fd, buffer, BUFLEN, 0);
 if (rc < 0) {
    perror(“Cannot receive”);
} else {
    // Handle data
}
```

* **将一个指向缓冲区的指针传递给recv()函数，但忘记了malloc()内存--或者假设它将在recv()中被分配**。Passes a pointer to the buffer to the recv() function, but forgets to malloc() the memory – or assumes it’ll be allocated in recv()
* **内存安全语言要求所有的引用都被初始化并指向有效的数据--好的C语言编译器也会对此提出警告** Memory safe languages require that all references be initialised and refer to valid data – good C compilers warn about this too

> 我们可能在做一个先用后分配的操作。在这种情况下，我们看到从文件描述符中读取的代码，例如从网络中读取，它有一个`char*`指针，用于读取的缓冲区，它调用recv()函数来读入该缓冲区，但它从未为该缓冲区分配过内存。所以它向recv()函数传递了一个指向缓冲区的指针，但是它忘记了分配内存，或者程序员认为recv()函数会替他们分配。其结果是，它写到了一个任意的位置，这取决于这个未初始化的指针中刚好有什么值。We could be doing a use-before-allocation. In this case, we see code which reads from a file descriptor, for example reading from a network, and it has a `char*` pointer for a buffer into which it is reading, and it calls the recv() call to read into that buffer, but it never allocates the memory for the buffer. So it passes a pointer to the buffer to the recv() function, but it's forgotten to allocate memory, or the programmer has assumed that the recv() function will do the allocation for them. And the result is that it writes to an arbitrary location, depending on what value happens to be in this uninitialised pointer. 
> 一个内存安全的语言会要求引用被初始化，并要求它们指向一个有效的数据。所以不应该有一个未初始化的引用，一个什么都不指向的引用。而像Rust这样的语言就会强制执行这一点。在Rust中你不可能得到一个未初始化的引用，它总是指向一个有效的值。而且，公平地说，好的C语言编译器会对这种行为提出警告。如果你打开了警告，在大多数情况下，他们会警告你，你正在访问一个未初始化的指针。但是C语言不需要这种警告，它允许你访问任意的指针，不管它们是否指向有效的内存。A memory-safe language would require that references are initialised, and require that they refer to a valid data. So it shouldn't be possible to have an uninitialised reference, a reference that points to nothing. And languages like Rust enforce this. You can't get a reference which is uninitialised in Rust, it always points to a valid value. And, to be fair, good to C compilers will warn about this behaviour. If you turn on the warnings, they’ll warn you, in most cases, that you're accessing and uninitialised pointer. But the C language doesn't require that warning, and allows you to access arbitrary pointers, whether or not they point to valid memory.

# 未定义行为-显式释放后使用:use after explicit free()

use after explicit free()

```c
#include <stdlib.h> 
#include <stdio.h>

int main() {
char *x = malloc(14);
 sprintf(x, "Hello, world!");
  free(x);
printf("%s\n", x);
}
```

* **访问已经被明确释放的内存，因此不再可以访问**。Accesses memory that has been explicitly freed, and hence is no longer accessible
* **自动内存管理消除了这一类的错误** Automatic memory management eliminates this class of bug

> **同样地，C和C++允许你在释放内存后使用它。而这是一个简单的例子。它分配了14个字节的空间，将字符串 "Hello, world!"写入其中，释放了该内存，然后打印出该值。而且，在大多数情况下，这将是有效的，因为没有其他东西在使用这些内存，因为这只是一个简单的测试函数，里面有main()。但是，如果这是一个更大的程序，并且有并发访问，那么该内存可能被另一个线程重新使用，并且它可能打印出谁也不知道的东西。而发生的事情是完全没有定义的**。imilarly, C and C++ allow you to use memory after you freed it. And this is a simple example. It allocates 14 bytes of space, writes the string “Hello, world!” into it, frees that memory, and then prints out the value. And, in most cases, this will work, because nothing else is using that memory, because this is only a simple test function with main() in it. But it's this was a larger program with concurrent accesses going on, that memory could have been reused by another thread, and it could print out who knows what. And what happens is entirely undefined. 
> **具有自动内存管理的现代语言可以避免这个问题。它们要么不编译，要么确保内存被保留适当的时间**。SModern languages, with automatic memory management, avoid this problem. They either fail to compile, or they ensure the memory is held for the appropriate amount of time.

# 未定义行为-隐式释放后使用:use after implicit free

use after implicit free

```c
int *foo() { 
    int n = 42; 
    return &n;
```

* 返回对堆栈分配的内存的引用，该内存在堆栈框架被销毁后被使用Return reference to stack allocated memory that is used after the stack frame has been destroyed
* 自动内存管理消除了这一类的错误Automatic memory management eliminates this class of bug

> **同样地，我们可以在内存被释放后隐式访问它。这里的典型例子是一个函数返回对堆栈分配的内存的引用，一旦函数返回，堆栈框架就会被销毁，现在的引用指向未分配的内存。而且，你已经有了一个任意的引用，而且不清楚这个引用所指向的内存中是什么。再说一遍，有自动内存管理的语言可以消除这种类型的错误。如果是堆分配的语言，他们会抓住这个值，这样它就不会消失；如果是有box值的语言，或者是像Rust这样的语言，如果你返回一个超出范围的引用，他们就不会进行编译**。 Equally, we can access memory implicitly after it’s been freed. The typical example here is a function which returns a reference to stack allocated memory, and once the function returns the stack frame is destroyed, and the reference now points to unallocated memory. And, again, you've got an arbitrary reference, and it's not clear what’s in the memory which is being referred by that reference. And, again, languages with automatic memory management eliminate this type of bug. Their either hold onto the value so that it can't go away if it's heap allocated, if it's a language with boxed values, or if it's a language like Rust they just won’t compile if you're returning a reference which goes out of scope.

# 未定义行为-错误类型转换：Use of memory as the wrong type

```c
char *buffer = malloc(BUFLEN);
int re =recv ( fa, buffer,BUFLEN,o);
if(re < o){
    ...
}else{
    struct pkt *p =( struct pkt * )buffer;
    if(p->version !=1) {
        ...
    }
}
```

* **在C代码中，常见的是将char *缓冲区转换为更具体的类型（例如，转换为代表网络数据包格式的结构**）。Common in C code to see casts from char * buffers to more specific types (e.g., to a struct representing a network packet format)
* **高效--没有内存拷贝--但不安全，因为要假设内存中的结构布局和被投块的大小** Efficient – no memory copies – but unsafe since makes assumptions of struct layout in memory, size of block being cast
* **内存安全语言不允许任意转换--明确编写转换函数；消除了未定义行为** Memory safe language disallow arbitrary casts – write conversion functions instead; eliminates undefined behaviour

> 内存不安全的语言可以允许内存作为错误的类型被访问。这一点比较微妙。**我们这里的代码为一个缓冲区分配了空间，并将数据读入该缓冲区，例如，它可能是从一个套接字中读取数据。假设它成功地读入了该缓冲区，那么它就将该缓冲区转换为一个指向不同类型的指针。这在C语言代码中是一个很常见的习惯**。Memory unsafe languages can allow memory to be accessed as the wrong type. This is a bit more subtle. The code we have here allocates space for a buffer and reads data into that buffer, for example it could be reading from a socket. And, assuming it successfully reads into that buffer, it then casts the buffer to be a pointer to a different type. And this is quite a common idiom in C code. 
> 你可以看到从**代表缓冲区的`char*`指针到某个结构的转换**，例如，代表网络数据包格式或代表文件格式的头。**人们这样做的原因是它非常有效。没有内存拷贝。而且，假设该结构的布局与你想要的数据的布局相匹配，这是一种非常有效的方法，可以获得对适当格式数据的引用**。You see casts from char* pointers representing buffers, to a certain struct, for example, representing a network packet format or representing the header of a file format. And the reason people do this is because it's very efficient. There’s no memory copies. And, assuming that the layout of the struct matches the layout of the data you want, it's a really efficient way of getting a reference to data in the appropriate format. 
> 问题是，**这是不安全的。它假设内存中结构的布局与数据的格式相匹配。它还假设被投的块的大小与结构的大小一致。而这些假设随着时间的推移往往会变得不真实。他们倾向于在程序员编写代码时发挥作用，否则就会失败，而且最初也不会通过测试**。The problem is that it's unsafe. It makes assumptions that the layout of the struct in memory matches the format of the data. And it makes assumptions that the size of the block being cast, matches the size of the struct. And these assumptions have a habit of becoming untrue over time. They tend to work at the point the programmer writes the code, otherwise it would it would fail, and wouldn't it wouldn't pass the tests initially. 
> 但问题是，**编译器往往会改变结构的布局方式。编译器的变化，或处理器的变化，会在结构元素之间插入填充物。这意味着结构的布局不再匹配，程序就会默默地失败，并产生不可预测的行为。或者，事实证明，程序运行在大编码机器和小编码机器上，默默地给你错误的值**。But the problem is that compilers tend to change the way structs are laid out. Changes in the compiler, or changes in the processor, can insert padding between struct elements. And that means that the layout of the struct no longer matches, and the program silently fails and gives unpredictable behaviours. Or, it turn out, the program is run on a big-endian versus a little-endian machine, and silently gives you the wrong values.
> 而且，**因为类型系统被覆盖，因为程序本质上是在说 "相信我，我知道我在做什么"，"假装这组字节是另一种类型的值"，这种布局上的变化，行为上的变化，往往不会被发现，当在不同的编译器上，或在不同类型的机器上使用时，程序会无声地失败**。 And, because the type system is being overridden, because the program is essentially saying “trust me, I know what I’m doing”, "pretend this set of bytes is a value of this other type”, such changes in layout, changes in behaviour, tend not to get detected, and the program fails silently when used on a different compiler, or on a different type of machine. 
> **而内存安全语言不允许这种任意的转换。它们让你明确地编写转换函数，并明确地将缓冲区解析到结构中。这样做会稍微慢一些，因为你必须明确地进行复制，但它消除了未定义的行为，而且是一致的。它避免了在发生变化时出现无声的故障**。And memory safe languages disallow such arbitrary casts. They make you explicitly write the conversion functions, and explicitly parse the buffer into the struct. And this is slightly slower, because you have to explicitly go through and make the copy, but it eliminates the undefined behaviour and it's consistent. It avoids silent failures when something changes.

# 未定义行为-在非字符串值上使用字符串函数：Use of string functions on non-string values

Use of string functions on non-string values

```rust
// Send the requested file
while ((rlen = read(inf, buf, BUFLEN)) > 0) {
    if (send_response(fd, buf, strlen(buf)) == -1) { 
        return -1;
    }
}
```

* **C语言中的字符串是零结尾的，但read()结果没有添加结尾；导致缓冲区溢出** Strings in C are zero terminated, but read() does not add a terminator; buffer overflow results
* **内存安全语言应用字符串边界检查--运行时异常；安全失败，没有未定义行为** Memory safe languages apply string bounds checks – runtime exception; safe failure, no undefined behaviour

> **内存不安全的语言允许你在非字符串值上应用字符串函数。这是C语言程序中一个非常常见的安全漏洞，C语言假定字符串是NUL终止的，在字符串的末尾有一个终止的零值，但是recv()函数在从文件或网络中读取数据时，并没有添加这个终止的零。因此，在C语言中，想要把从网络上读取的数据或从文件中读取的数据当作字符串处理的程序，必须明确地在read()函数返回的值的末尾添加终止零。如果你忘记了，并在此基础上调用一个字符串函数，在这种情况下，我们以这种方式调用strlen()，字符串长度函数就会一直读，直到它找到内存中的第一个零，谁知道它在内存中读到了什么**。Memory unsafe languages allow you to apply string functions on non string values. And this is a really common security vulnerability in C programs, where the C language assumes strings are NUL terminated, there's a terminating zero value at the end of a string, but the recv() function, for reading from a file or reading from the network, doesn't add that terminating zero. So program that's wanting to treat data read from the network, or read from a file, as a string, in C, has to explicitly add at terminating zero on to the end of the values returned by the read() call. And if you forget, and call a string function on that, and in this case we're calling strlen() in such a way, the string length function just keeps reading until it finds the first zero in memory, and who knows what it reads in memory. 
> **也许，在最好的情况下，这只是泄露了内存的内容，也许暴露了一些敏感数据。而在最坏的情况下，它会继续下去，直到它遇到一些未分配的内存而使程序崩溃**。And, maybe, in the best case that just leaks the contents of memory, maybe exposes some sensitive data. And in the worst case, it keeps going until it runs into some unallocated memory and crashes the program. 
> **而内存安全语言应用了字符串边界检查。它们确保类型匹配，确保你不能访问字符串的末尾，而且它们要么成功，要么，如果它们要失败，它们会以运行时异常的方式失败，从而干净利落地关闭程序，而不会出现未定义行为**。And memory safe languages apply string bounds checks. They make sure that the types match, they make sure you can't access over the end of the string, and they either succeed or, if they’re going to fail, they fail with a runtime exception which closes the program cleanly without undefined behaviour.

# 未定义行为-堆分配溢出：Heap Allocation Overflow

```c
#define BUFSIZE 256
int main(int argc, char *argv[]) { 
    char *buf;
    buf = malloc(sizeof(char) * BUFSIZE); 
    strcpy(buf, argv[1]);
}
```

* **内存安全语言对堆分配的内存进行边界检查--运行时异常；安全失败，没有未定义行为** Memory safe languages apply bounds checks to heap allocated memory – runtime exception; safe failure, no undefined behaviour

> **内存不安全语言没有要求你只访问你所分配的内存。在内存不安全的语言中，你可以分配256字节的内存，但复制一个任意大小的缓冲区。这种语言，strcpy()的调用，以及C语言中数组和指针的工作方式，意味着没有检查被复制到缓冲区的值是否符合分配的256字节。它可以覆盖数组的末端，并且可以破坏下一个内存中的东西**。Memory unsafe languages put no requirements that you only access the memory you've allocated. In a memory unsafe language you can allocate, in this case, memory for 256 bytes of memory, but copying-in an arbitrary sized buffer. And the language, the strcpy() call, and the way arrays and pointers work in C, means there’s no checks that the value that's being copied into that buffer, fits in within the 256 bytes allocated. And it can overwrite the end of the array, and it can corrupt whatever happens to be in memory next. 
> **而内存安全语言会应用边界检查。如果你在C语言中试图覆盖一个数组的末尾，它就会破坏下一个内存中的东西。如果你试图在Java或Rust中覆盖一个数组的末端，程序会失败，但会出现异常，或在Rust中出现恐慌，从而干净地关闭程序。它不会以一种未定义的方式失败；它有定义的失败语义。它不会泄露信息，不会破坏状态，它只是干净地关闭了程序**。And memory safe languages apply bounds checks. If you try to overwrite the end of an array in C, it will just corrupt whatever's next memory. If you try to overwrite the end of an array in Java, or in Rust, the program will fail, but it will fail with an exception, or a panic in Rust, which closes down the program cleanly. Which doesn't fail in an undefined way; it has defined failure semantics. It doesn't leak information, it doesn't corrupt the state, it just cleanly shuts the program down.

# 未定义行为-数组越界(溢出))：Array Bounds overflow

```c
int main(int argc, char *argv[]) { 
    char buf[256];
    strcpy(buf, argv[1]);
}
```

* **内存安全语言应用阵列边界检查--运行时异常；安全失败，没有未定义行为** Memory safe languages apply array bounds checks – runtime exception; safe failure, no undefined behaviour

> **你也可以用数组做同样的事情。在C或C++中，内存不必在堆上分配就可以溢出，而且，没有边界检查，而在安全语言中应该有**。 And you can do the same thing with arrays. The memory doesn't have to be allocated on the heap for you to be able to overflow it in C or C++ and, again, there's no bounds checks, whereas in a safe language there should be.

# 未定义行为-指针算术：Arbitrary pointer arithmetic

```c
int buf[INTBUFSIZE]; 
int *buf_ptr = buf;

while (havedata() && (buf_ptr < (buf + sizeof(buf)))) {
    *buf_ptr++ = parseint(getdata());
}
```

* sizeof()返回以字节为单位的大小，对`int *`指针的算术是对指针大小的值进行的。sizeof() returns size in bytes, arithmetic on int *
* **指针上的算术是在指针大小的值上进行的；边界检查太宽松了** pointers is on pointer sized values; bounds check is too lax
* **内存安全语言不允许任意的指针算术** Memory safe languages disallow arbitrary pointer arithmetic

> 或者你可以进行任意的指针运算。这个C程序在计算，它在看缓冲区的大小，所以检查buf_ptr小于buf+sizeof(buf)，看起来它在检查指针是否在范围内，看起来它是手动实现了关于边界检查。但是这里的问题是，buf_ptr是一个指针和int，而sizeof()返回的是字节大小，而这个程序在增加buf_ptr的时候，是按int大小的块增加的，而不是按字节大小的块，所以大小不一致。它最终导致了缓冲区溢出，因为它正在对指针进行算术，但它没有错误地进行算术。而且，语言不应该允许类型不匹配的访问。 Or you can perform arbitrary pointer arithmetic. This C program is calculating, it's looking at the size of the buffer, so the check for buf_ptr is less than buf+sizeof(buf), looks like it's checking the pointer is within range, it looks like it's manually implemented about a bounds check. But the bug here is that the buf_ptr is a pointer and int, and sizeof() returns a size in bytes, and what this program is doing, when it increments buf_ptr, is incrementing by int sized chunks, rather than byte sized chunks, so the sizes don't match-up. And it ends up with a buffer overflow because it's doing arithmetic on pointers, but it's not doing the arithmetic incorrectly. And, again, the language shouldn't allow accesses where the types don't match up.

# 未定义行为-使用未初始化内存：Use of uninitialised memory

![](/static/2022-05-08-20-52-04.png)

* 用malloc()分配的内存有 未定义的内容 Memory allocated with malloc() has undefined contents
* 内存安全语言要求对内存进行初始化，或要求运行时用已知的值来填充。Memory safe languages require memory to be initialised, or mandate that the runtime fills with known value

> 而内存不安全的语言允许未初始化的内存被访问。在这个例子中，我们正在分配空间，分配一个字节的内存来存储头文件。And memory unsafe languages allow uninitialised memory to be accessed. In this example, we're allocating space, allocating one byte of memory to store the headers. 
> 这是一个例子，它可能是在读取HTTP的头文件，并且正在增长一个缓冲区，逐个字节地读取头文件，并在每次read()之后检查它是否收到了完整的头文件，如果它们以双回车换行结束。And this is an example, it might be reading HTTP headers, and is growing a buffer, and reading the headers in, byte-by-byte, and checking after each read() to see whether it's received the complete set of headers, if they end with a double carriage return newline. 
> 问题是最初的分配只是分配了一个字节的空间，但并没有填入该内存。它没有一个字符串结束的标记在那里，说这是一个空字符串。The problem is the initial allocation allocation just allocates space one byte, but doesn't fill in that memory. It doesn't have an end-of-string marker there, to say that this is an empty string. 
> 所以第一个strstr()的调用只是在未初始化的内存的末端运行，并继续寻找零。这和我们之前看到的错误类似，字符串没有以零结尾，但它的发生是因为语言允许你引用未初始化的内存。该语言允许你引用没有定义值的内存。So the first strstr() call just runs off the end of the uninitialised memory, and keep searching for the zero. And it's similar to the bug we saw earlier, with strings not being zero terminated, but it happens because the language lets you reference uninitialised memory. The language lets you reference memory that hasn't got a defined value. 
> 一个内存安全的语言会要求所有的内存都被初始化。它要求任何分配，任何堆分配，都有已知的内容。而不安全的语言不会这样做，它们让你在任意的、不可预测的数值上进行计算。And a memory safe language would require that all the memory is initialised. It would require that any allocation, any heap allocation, has known contents. Whereas the unsafe languages don't do that, and they let you perform computations on arbitrary, unpredictable, values.

# 未定义行为-通过空指针使用内存：•	Use of memory via null pointer

```c
struct user *u = lookup(db, key);
 printf(“%s\n”, u->name);
```

* 调用lookup()可能失败，返回空指针 lookup() call may fail, returning null pointer
* 内存安全语言要么是：用异常安全地失败；要么使用Option<>类型来强制执行空指针的检查。 Memory safe languages either: fail safely with an exception; or use Option<> types to enforce that the null pointer check is done

> **我们有一些语言允许你通过悬空指针和空指针来访问内存，这些语言可以访问指针指向一些未知的、不可预测的值。你可能会得到一个从lookup()返回的空指针，并试图解引，这将失败。或者你可能有一个指向不再存在的东西的指针，这也可能会失败**。 And we have languages which allow you to access memory via dangling pointers, via null pointers. which can access values where the pointer points to some unknown, unpredictable, value. And you may get a null pointer returned from lookup(), and try to dereference it, and that will fail. Or you may have a pointer to something which is no longer existing and it may fail.

# 其他未定义行为

- C和C++中会出现哪些类型的内存不安全行为？•	What types of memory unsafe behaviour can occur in C and C++?
- ...以及更多https://cwe.mitre.org/data/definitions/658.html

# 非内存安全语言影响: Impact of Memory Unsafe Languages

- **缺乏内存安全打破了机器的抽象性**•	Lack of memory safety breaks the machine abstraction
- **运气好的话，程序会崩溃--违反分段规定**•	With luck, program crashes – segmentation violation
- **如果不走运，内存不安全行为会破坏程序拥有的其他数据**•	If unlucky, memory unsafe behaviour corrupts other data owned by program
  - 出现未定义行为•	Undefined behaviour occurs
  - 如果不知道内存中程序的精确布局，就无法预测•	Cannot predict without knowing precise layout of program in memory
  - 难以调试•	Difficult to debug
  - **潜在的安全风险** - 破坏程序状态，强制执行任意代码•	Potential security risk – corrupt program state to force arbitrary code execution

> 而这里的问题是，缺乏内存安全就会破坏抽象的东西。这意味着程序开始做不可预知的事情。And the issue here is that lack of memory safety breaks the abstractions. It means the program starts doing unpredictable things. 
> 如果你幸运的话，程序只是崩溃了，而且是早期的、明显的崩溃，你可以知道有一个内存安全的错误，你可以修复它。And, if you're lucky, the program just crashes, and crashes early and visibly, and you can tell that there's a memory safety bug, and you can fix it. 
> 如果你不走运，程序就会访问它不拥有的内存，或者以一种不符合类型的方式访问内存，它就会悄悄地破坏其他一些值。它悄悄地破坏了存储在内存中的其他一些值。也许那是没有被使用的内存，而腐败没有影响。但是，也许那是正在使用的内存，并且在程序中存储着其他的值，而你只是默默地破坏了另一个变量的值，并且没有办法知道何时何地发生了这种变化。如果不知道内存中程序的确切布局，你就无法预测会发生什么。而且，如果是多线程程序，还要知道所有不同线程的确切执行顺序。调试这种行为非常困难，而且有潜在的安全风险，因为通过破坏程序的状态，攻击者可以使程序做一些不打算做的事情，并有可能强迫执行任意代码。If you're unlucky, the program accesses memory which it doesn't own, or accesses memory in a way that doesn't match the types, and it silently corrupts some other value. It silently corrupts some other value stored in memory. And maybe that's memory which isn't being used, and the corruption has no effect. But maybe it's memory which is being used, and is storing some other value in the program, and you've just silently corrupted the value of another variable, with no way of knowing when, or where, that change happened. And you can't predict what's going to happen without knowing the exact layout of the program in memory. And, if it's a multi-threaded program, knowing the exact order of execution of all the different threads. It’s very difficult to debug such behaviours, and it’s potentially a security risk because by corrupting the program state, ab attacker can cause the program to do something which wasn't intended, and potentially force arbitrary code execution.

# 内存不安全-对安全影响：Security

![](/static/2022-05-08-21-01-11.png)

- 一**半的安全漏洞是违反内存安全的行为，应该被现代类型系统所捕获**•	Half of all security vulnerabilities are memory safety violations that should be caught by a modern type system
  - 缓冲区溢出•	Buffer overflows
  - 内存损坏•	Memory corruption
  - 将数据视为可执行代码•	Treating data as executable code
- **使用基于类型的问题域建模可以帮助解决其他问题--通过对假设进行更严格的检**查•	Use of type-based modelling of the problem domain can help address others – by more rigorous checking of assumptions

> 而这是一个真正的问题。我们左边的图表，也许有点难看，是在看20年内报告的安全漏洞的数量。这是一个所有CVE的列表，即通用漏洞数据库，它是一个20年内所有软件的所有安全漏洞报告的列表。突出显示的那一栏显示的是由于缓冲区溢出、内存损坏或将数据作为可执行代码处理的漏洞。**它强调的是由于内存不安全造成的漏洞。如果你看一下这些数字，我们会发现所有安全漏洞中大约有一半是内存不安全的漏洞。它们是由于语言中缺乏内存安全而产生的问题，现代类型系统应该能够捕捉到这些问题。编译器应该能够发现这些问题。我认为，通过对类型中的问题域进行建模，即使它们与内存不安全没有直接关系，编译器也可以帮助检查这些类型的问题。像SQL注入错误、解析错误，类型系统可以帮助检查一致性，可以帮助检查这些问题是否发生**。And this is a real problem. The chart we have on the left, which is a little hard to read perhaps, is looking at the number of reported security vulnerabilities, for a 20 year period. And this is a list of all the CVEs, the common vulnerability database, and it's a list of all of the security vulnerabilities reported, in all software, over a 20 year period. And the column highlighted is showing the vulnerabilities which are due to buffer overflows, memory corruption, or treating data as executable code. It’s highlighting vulnerabilities which are due to memory unsafety. If you look at the numbers, we see that about half of all security vulnerabilities are memory unsafety vulnerabilities. They are problems due to lack of memory safety in the language, which should be caught by a modern type system. The compiler should be able to detect these problems. And a lot of the others, I think, by modelling the problem domain in the types, even if they're not directly related to memory unsafety, the compiler can also help check for these types of problems. Things like SQL injection bugs, parsing bugs, the type system can help check for consistency, can help check that these are not happening.

---

![](/static/2022-05-08-21-02-42.png)

- 大约70%的微软安全更新修复了与不安全内存使用有关的错误•	~70% of Microsoft security updates fix bugs relating to unsafe memory usage
- 这在过去10年中没有明显变化•	This has not significantly changed in >10 years
- 在内存不安全的语言中，我们在编写安全代码方面并没有变得更好•	We’re not getting better at writing secure code in memory unsafe languages

> 这是另一张图，来自微软的一份报告，它是在10年左右的时间里，对微软软件的安全漏洞类型进行的调查。在微软的案例中，大约70%的安全更新修复了与不安全内存使用有关的漏洞。这也许比上一个图表要高一点，因为微软开发的软件类型是大量的系统代码，大量的应用程序代码，而上一个图表，上一个表格，是看所有的软件，包括网络应用，等等。我认为有趣的是，**我们在这方面没有变得更好。我们已经知道内存安全错误是一个非常非常长的时间，10-20年，而我们在用内存不安全的语言编写安全代码方面并没有变得更好。内存安全漏洞的数量并没有减少。这并不是说微软不知道这是一个问题。只是这是一个很难解决的问题，而且在这些语言中很难解决**。And this is a another graph, this is from a presentation by Microsoft, and it's looking at the type of security vulnerabilities in Microsoft software, again over a 10 year or so period. And, in Microsoft's case, about 70% of their security updates fix bugs relating to unsafe memory usage. And this is perhaps a little higher than the previous graph, because of the type of software that Microsoft develops, which is a lot of systems code, a lot of applications code, whereas the previous graph, the previous table, was looking at all software, including web applications, and so on. I think what's interesting is that we're not getting better at this. We have known that memory safety bugs are a problem for a very, very long time, 10-20 years, and we're not getting better at writing secure code in memory unsafe languages. The number of memory safely bugs isn't going down. And it's not that Microsoft doesn't know that this is a problem. It's just that this is a hard problem, and it's difficult to fix in these languages.

# 内存不安全缓解：Mitigations for memory unsafe languages

- 使用现代工具进行C和C++开发。•	Use modern tooling for C and C++ development:
  - 至少用clang -W -Wall -Werror编译C代码。•	Compile C code with, at least, clang —W -Wall -Werror
    - 查阅文档，找出需要启用的其他警告。•	Review documentation to find additional warnings it makes sense to enable
    - 修复所有的警告 - 让编译器帮助你调试你的代码•	Fix all warnings – let the compiler help you debug your code
- 在调试过程中使用clang静态分析工具。•	Use clang static analysis tools during debugging:
  - https://clang.llvm.org/docs/AddressSanitizer.html
  - https://clang.llvm.org/docs/MemorySanitizer.html
  - https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html
  - https://clang.llvm.org/docs/ThreadSafetyAnalysis.html
  - https://clang.llvm.org/docs/ThreadSanitizer.html
  - 这些都有很高的开销，但能抓住许多内存和线程安全问题•	These have very high overhead, but catch many memory and thread safety problems

> 作为一个系统程序员，你应该怎么做？**如果你必须用一种内存不安全的语言来编写，请使用现代工具。如果你正在编译C代码，至少要打开所有你能找到的警告**。例如，如果你使用clang，编译C代码的最小标志集应该是 -W -Wall -Werror。你会认为这将打开所有的警告，并使它们成为错误。但是，实际上，它所做的是打开所有GCC特定版本的警告，并使其成为错误。所以，**看看文档，找到额外的警告，看看打开它们是否有意义。找到除了-Wall以外的警告，并打开它们。修复所有的警告。当编译器说有一个警告时，把它当作一个错误；强迫编译器把它当作一个错误。让编译器帮助你调试你的代码。而当你调试你的代码时，当你测试你的代码时，使用现有的静态分析工具**。这可能是像valgrind这样的老式工具，也可能是更现代的工具，比如地址和内存净化器，或者未定义行为净化器，线程净化器，内置于clang中。**现在有很多工具，也许开销很大，也许不能在生产中使用，但对于调试和测试来说，可以帮助你发现很多与内存和线程有关的安全问题**。 What should you do as a systems programmer? If you have to write in a memory unsafe language, use the modern tooling. If you're compiling C code, at the very minimum, turn on all the warnings you can find. The minimum set of flags for compiling C code, if you're using clang, for example, should be -W -Wall -Werror. And you’d think this would turn on all warnings, and make them errors. But, actually what it does, is turn on all warnings that a particular version of GCC had, and make them errors. So look at the documentation, and find the additional warnings, and see if it makes sense to turn them on. Find the warnings which exist in addition to -Wall, and turn them on. Fix all the warnings. When the compiler says there's a warning, treat it as an error; force the compiler to treat it as an error. Let the compiler help you debug your code. And when you're debugging your code, when you're testing your code, use the static analysis tools that exist. And this could be older tools like valgrind, or it could be more modern tools, like the address and the memory sanitisers, or the undefined behaviour sanitisers, the thread sanitisers, built into clang. There's a lot of tools that exist now that perhaps have a very high overhead, perhaps can’t be used in production, but for debugging and testing can help you catch many memory and thread related safety problems.

---

- **使用现代C++语言的特点**。•	Use modern C++ language features:
  - 我建议不要使用C++编程--语言太复杂，难以理解•	I advise against C++ programming – language is too complex to understand
  - 随着时间的推移，增加了太多的功能，删除了太少的功能；代码中混合了新旧功能•	Too many features have been added over time, too few removed; code mixes old and new features
  - 很少有人知道整个语言•	Very few people know the whole language
  - 事后看来，一些C++的默认值是不合适的•	In hindsight, some C++ defaults were inappropriate
  - **现代C++解决了许多这些问题--但必须保留向后的兼容性**•	Modern C++ addresses many of these issues – but must retain backwards compatibility
    - Rust采用了C++发展过程中的许多经验教训•	Rust adopts many lessons learned in the development of C++
    - 而且可以更简单，因为不需要担心与遗留代码的兼容问题•	And can be simpler, since doesn’t need worry about compatibility with legacy code
- **但是，如果你必须使用C++，那就对代码库进行现代化改造，尽可能使用更新的--更安全的--语言特性和习惯用语**。•	But if you have to use C++, modernise the code base, to use newer – safer – language features and idioms, where possible

> 如果你正在使用C++，请使用该语言的现代特性。**现代的C++成语比老式的成语要安全得多。虽然，一般来说，我不得不说我建议不要使用C++编程，因为它太复杂了。我认为，C++的问题在于，随着时间的推移，功能不断被添加，而功能却没有被删除**。因此，**现代C++是一种相当好的、相当安全的语言，如果你能理解它，并且你能确保代码不使用任何旧的、不太安全的功能**。但C++的问题是，**很少有人了解整个语言，它在早期版本中做了一些错误的选择，有一些不合适的默认值，你需要大量的知识来正确编写C++代码，知道哪些功能是安全的，知道在哪些情况下需要覆盖默认值**。它在这方面越来越好，**现代版本解决了很多这样的问题，但他们必须保留向后的兼容性，所以他们必须保留所有不安全的功能。这意味着你需要审核所有的代码，以检查它们是否被使用，而且你需要了解所有的这些特性**。 If you're using C++, use the modern features of the language. The modern C++ idioms are much safer than the older idioms. Although, in general, I have to say I would advise against C++ programming because it's too complicated. The problem, I think, with C++ is that features keep getting added over time, and features don't get removed. So modern C++ is quite a nice, quite a safe, language, if you can understand it, and if you can make sure that the code doesn't use any of the older, less safe, features. But the problem with C++ is that very few people know the whole language, it made some bad choices in early versions, had some inappropriate defaults, and you just need a lot of knowledge to write C++ code correctly, know which features are safe to use, know in which cases you need to override the defaults. It’s getting better at that, the modern versions solve a lot of these issues, but they have to retain backwards compatibility, so they have to retain all the unsafe features. The means you need to audit all the code to check that they're not being used, and you need to understand all of those features. 
> 我认为**Rust**是系统编程的一个很好的选择，原因之一是它**从这种经验中吸取了教训，它研究了在C++中哪些是可行的，哪些是不可行的，事后看来，它是可行的。而且，由于它是一种新的语言，它不需要向后兼容，所以它可以解决C++不能解决的问题**。One of the reasons I think Rust is a good choice for systems programming is that it's learned from this experience, and it's looked at what works in C++ and what, with the benefit of hindsight, doesn't. And, because it's a new language, it doesn't need to be backwards compatible, so it can fix the problems C++ can't fix.

# 以内存安全语言渐进式重写代码:Gradually Rewrite Code into a memory Safe Language

- 考虑**用一种内存安全语言重写代码中最关键的部分**。•	Consider rewriting the most critical sections of the code in a memory safe language:
- **逐步将C语言改写成Rust语言**•	Gradually rewrite C into Rust
  - Rust可以直接调用C函数•	Rust can call C functions directly
  - Rust可以被编译成一个库，可以直接与C或C++链接•	Rust can be compiled into a library that can be directly linked with C or C++
  - https://doc.rust-lang.org/nomicon/ffi.html
  - https://unhandledexpression.com/rust/2017/07/10/why-you-should-actually-rewrite-it-in-rust.html
  - 有可能将C或C++逐步改写成安全语言，同时在每个阶段都保持应用程序的可用性和构建性•	Possible to do a gradual rewrite of C or C++ into a safe language, while keeping the application usable and building at each stage
  - 逐步将Objective-C重写成Swift•	Gradually rewrite Objective-C into Swift
    - 在苹果的生态系统中，同样有可能将应用程序逐步重写成Swift。•	In the Apple ecosystem, similarly possible to gradually rewrite applications into Swift
- **困难重重，需要有兼容的运行时模型的语言**•	Difficult and requires languages with compatible runtime models
  - **渐进式重写**可能比从头开始重写有更多的成功机会•	Gradual rewrite likely has more chance of success than from-scratch rewrite

> 最终，我认为，如果你有一个内存不安全的代码库，你应该寻求**逐步重写它，或者至少重写关键部分，例如输入解析代码，进入内存安全语言**。例如，如果你有C或C++代码，你可以逐渐把它改写成Rust。而Rust的一个好处是，你可以以一种函数与C代码兼容的方式来编译它。因此，你可以一次重写一个程序的功能，并将Rust代码连接起来，在多年的时间里逐步转换，一个功能一个功能地测试，并逐步修复这些问题。幻灯片上的链接指向了一些谈论如何做到这一点的博客文章。有几个开源项目的例子是这样做的，例如，在五年的时间里将代码库从C语言逐步过渡到Rust语言，同时保持API，保持兼容性。 Ultimately, I think, if you have a memory unsafe code base, you should be looking to gradually rewrite it, or at least rewrite the critical sections, the input parsing code for example, into a memory safe language. If you have C or C++ code, you can gradually rewrite it into Rust, for example. And one of the nice things about Rust, is that you can compile it in a way that the functions are compatible with C code. So you can rewrite a program function at a time, and link in the Rust code, and gradually convert it over a period of many years, function by function, testing it as you go, and gradually fixing the problems. And the links on the slide point to some blog posts that talk about how to do this. And there’s been a couple of examples of open source projects which have done this, and have gradually transitioned a code base from C to Rust over a five year period, for example, while keeping the API, keeping compatibility.
> 如果你在苹果的世界里，你可以做同样的事情，比如说逐渐从Objective C改写成Swift，并获得安全方面的好处。但这是很难的。它需要有兼容的运行时模型的语言，所以你可以把代码连接在一起，用多种语言写一个程序，而且需要你有懂这两种语言的程序员。但我认为这种渐进式的重写才是正途，而且比从头开始的重写更有可能成功，因为你可以不断地测试程序，不断地调试程序，而不是把它全部扔掉，从头开始，必须重新实现所有的东西。 If you're in the Apple world, you can do the same sort of thing, gradually rewriting from Objective C to Swift, for example, and get the safety benefits. But this is difficult. It requires languages that have compatible runtime models, so you can link the code together, and write a program in multiple languages, and it requires that you have programmers who know both languages. But I think this sort of gradual rewrite is the way to go, and has much more chance of success than a from-scratch rewrite, because you can keep testing the program as go, you can keep debugging the program as you go, rather than having to throw it all away, start from scratch, and have to reimplement everything.

# ==================

# 2解析和网络安全:Parsing and Network Security

讲座的第二部分讨论了网络应用的安全漏洞。它强调了如何解析不受信任的输入这一关键问题，并讨论了Postel定律对输入解析器安全的一些影响。它讨论了一些建立安全解析器的方法，并介绍了LangSec运动的一些想法。

这就是我想说的关于解析的全部内容。**网络安全是很难的。要写出安全的解析器是很难的。但是我们有工具，我们有方法，可以帮助我们。我想敦促你，无论你是否使用Rust，或C，或C++，或Python，或任何其他语言，写下你的代码所接受的语法，想想什么是合法的，想想失败的条件。以一种稳健的、结构化的方式来定义你的解析器**。That’s all I want to say about parsing. Network security is hard. It is hard to write safe parsers. But we have tools, we have approaches, which can help. I would urge you, whether or not you're using Rust, or C, or C++, or Python, or any other language, write down the grammar which your code is accepting, think about what's legal think, about the failure conditions. Define your parser in a robust, structured, way.

# 可远程利用的漏洞:Remotely Exploitable Vulnerabilities

```c++
if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0) 
    goto fail;
    goto fail;
... other checks ... 
fail:
... buffer frees (cleanups) ... 
    return err;
```

- 在不安全的语言中编写安全的代码是困难的•	Writing safe code in unsafe languages is difficult
  - 很容易将每个单独的错误合理化--"怎么会有人写这个？"•	Easy to rationalise each individual bug – “How could anyone write that?”
  - 但是，人们会继续犯错•	But, people will continue to make mistakes
- **可远程利用的漏洞威胁着任何网络系统**•	Remotely exploitable vulnerabilities threaten any networked system
- 是否有特定类别的bug会导致这种漏洞？•	Are there particular classes of bug that cause such vulnerabilities?



> 正如我们在讲座的前一部分所看到的，在内存不安全的语言中编写安全代码是很困难的。有大量的也许有点微妙的漏洞，有点微妙的bug，可能发生，导致未定义的行为，导致不安全的行为，这些bug可能导致代码中可利用的缺陷。As we saw in the previous part of the lecture, writing safe code in memory unsafe languages is difficult. There's a large number of perhaps somewhat subtle vulnerabilities, somewhat subtle bugs, that can occur, which lead to undefined behaviour, lead to unsafe behaviour, and those bugs can lead to exploitable flaws in the code. 
> 这方面的很多问题是，很容易看到这些单独的错误，并将其合理化。我们很容易看到这些类型的问题，并说 "怎么可能有人会写这样的代码？" 而问题是，很多这些安全漏洞，我们在网络系统中看到的很多可远程利用的漏洞，都属于这个类别。And the problem with a lot of this, is that it’s easy to look at each of these individual bugs and rationalise them. It's easy to look at these types of problems, and say “how could anyone possibly write code like that?” And the problem is that a lot of these security vulnerabilities, a lot of the remotely exploitable vulnerabilities we see in network systems, fall under this category. 
> 我们在幻灯片上看到的例子，是一个来自苹果TLS代码的真正安全漏洞。这里发生的事情显然是一个错误的合并，或者说是错误的编辑，比如说某一行被重复了，"goto fail "这一行被重复了。当然，问题在于，由于缩进在C语言中并不重要，这就使得它总是进入失败的情况，并跳过一系列的检查。这导致了一个特定的检查被跳过，这导致了代码的远程可利用性，因为验证输入的检查没有被执行，这又导致了一个内存不安全的错误。And the example we see on the slide here, is a real security vulnerability from the Apple TLS code. And what's happened here is clearly a mismerge, or misedit, such that a particular line has got duplicated, and the line “goto fail”, has got duplicated. The problem, of course, is that because indentation is not significant in C, what this does is always goes to the failure case, and skips a bunch of checks. And it led to a particular check being skipped, and that led to code that was remote remotely exploitable, because the checks that validated the input were not performed, and that then led to a memory unsafety bug further down the line. 
看着这样的例子，我们很容易就会说 "怎么会有人写这样的东西？" 程序员怎么会没有发现这是一个错误呢？当然，对于任何一个单独的错误，你都可以这样做，你可以看着它说，嗯，当然，你应该已经看到了。但是，问题是，人们一直在犯错误。我们最终陷入了一种情况，即我们期望程序员是完美的。我们期望程序员永远不犯错误。而没有提供工具来帮助他们，没有提供工具来在他们犯错时抓住他们。And it's easy to look at examples like this, and say “how could anyone write that?” How could the programmer not spot that this was a bug? Of course, for any individual bug you can do that, you can look at it and say, well, of course, you should have seen that. But, the thing is, people keep making mistakes. We’ve ended up in a situation where we're expecting programmers to be perfect. We're expecting programmers to never make mistakes. And not providing the tools to help them, not providing the tools to catch the mistakes when they get made. 
> 问题是，这些类型的内存安全漏洞导致了可远程利用的漏洞。它们导致攻击者可以使用未定义的行为，可以找出特定情况下发生的事情，并可以闯入系统和运行任意代码。而这当然是一个问题。如果我们想提高安全性，我认为我们需要专注于，正如我们上次谈到的，我们需要专注于摆脱内存不安全语言。但显然这是一个长期的目标。And the problem is these types of memory on safety bugs lead to remotely exploitable vulnerabilities. They lead to situations where attackers can use that undefined behaviour, can figure out what happens in particular cases, and can break into systems and run arbitrary code. And this is, of course, a problem. If we want to improve security, I think we need to focus on, as we spoke about last time, we need to focus on getting rid of memory unsafe languages. But obviously this is a long term goal. 
> 思考一下是否有特定类型的bug，特定类别的bug，这些bug最容易造成这样的漏洞，我们可以在短期内解决这些问题，这也许是有意义的。我们可以扩大努力，主动转向更安全的语言，或主动使用新技术，或主动地，至少，仔细审查代码。And it may make sense to think about are there particular types of bug, particular classes of bug, which most cause such vulnerabilities, which we can address in the short term. Where we can expand the effort to proactively move to safer languages, or to proactively use new techniques, or to proactively, at least, review the code carefully.

# 解析未信任输入：Parsing Untrusted Input

- **输入解析器对网络系统的安全至关重要**•	The input parser is critical to security of a networked system
  - 从网络中获取不受信任的输入•	Takes untrusted input from the network
  - 生成经过验证的、强类型的数据结构，由代码的其他部分处理。•	Generates validated, strongly typed, data structures that are processed by the rest of the code
- 我们**怎样才能确保解析器是安全的**？•	How can we ensure parsers are safe?

> 我认为其中一个我们需要积极主动花费精力的领域是解析不受信任的输入。从网络到程序其他部分的输入，或者从文件解析器到程序其他部分的输入。而且，如果我们专注于网络系统，网络系统的结构，在一个非常高的水平上，是你从网络上得到一些不可信任的协议数据。你需要对它进行解析，把协议信息，解析成一些内部数据结构。然后，协议代码对这些数据结构进行操作，并将结果序列化，以便在网络上传输，作为对请求的回应。And I think one of these areas where we need to proactively spend this effort, is parsing untrusted input. The input from the network to the rest of the program, or the input from a file parser, to the rest of the program. And, if we focus on networked systems, the structure of a networked system, in a very high level terms, is that you get some untrusted protocol data from the network. You need to parse it, take the protocol messages, parse them into some internal data structure. And the protocol code then operates on those data structures, and serialises the results for transmission back out across the network, in response to the request. 
> 我认为应该清楚的是，**输入解析器对任何网络系统的安全都至关重要。它从网络上获取不受信任的输入数据，我们知道有一些人在恶意地试图破坏系统，它试图生成经过验证的、强类型的数据结构，可以被其他代码处理。其中一个关键的挑战是确保解析器的安全。并确保解析器安全，即使他们是用不安全的内存语言编写的**。I think what should be clear, is that the input parser is critical to the security of any networked system. It’s taking untrusted input data from the network, where we know there are people who are maliciously trying to break the systems, and it's trying to generate validated, strongly-typed, data structures that can be processed by the rest of the code. And one of the key challenges is ensuring that the parsers are safe. And ensuring that parsers safe, even if they've written in memory unsafe languages.

# 健壮性原则（Postel's Law): The Robustness Principle

![](/static/2022-05-09-01-37-43.png)

在编写网络系统时，传统的指导思想是用Postel定律表示的 Traditional guidance when writing networked systems is expressed in Postel’s law

> 那么，我们**如何构建网络化系统**？好吧，**在编写网络系统时，传统的指导思想是以Postel定律的形式表达的**。波斯特尔定律最早是在RFC1122中描述的。它谈到了网络协议的互操作性和稳健性。它的建议是，**你应该对你所接受的东西持开放态度，而对你所发送的东西持保守态度。也就是说，在生成数据时，你应该尽力确保你生成的数据符合协议的要求。但是，当解析你从网络上收到的数据时，波斯特尔定律的建议是，你应该原谅错误，你应该原谅格式的精确细节，只要你能理解你得到的东西**。软件确实需要重写以处理错误，它确实需要应对这样一个事实，即进来的数据是恶意的，是为了破坏系统，**但如果它太严格，太不宽容，互操作性就会受到影响。有一个平衡点**。波斯特尔定律是说，要朝着自由的方向努力，**接受不一定是格式良好的数据，以提高互操作性**。So how do we build networked systems? Well, the traditional guidance, when writing networked systems, has been expressed in the form of Postel’s law. And Postel’s law was first described in RFC 1122. And it, it talks about interoperability and robustness of network protocols. And the suggestion is that you should be liberal in what you accept, and conservative in what you send. That is, when generating data, you should try your hardest to make sure the data you generate conforms to the protocol. But when parsing data that you receive from the network, the suggestion from Postel’s law is that you should be forgiving of errors, you should be forgiving of the precise details of the format, providing you can make sense of what you get. The software does need to be rewritten to deal with errors, it does need to cope with the fact that the data is coming in which is malevolent, which is designed to break the system, but if it's too strict, too unforgiving, interoperability suffers. And there's a balance. And Postel’s law is saying, err towards being liberal, towards accepting data which is not necessarily well-formed, to enhance interoperability.

---

![](/static/2022-05-09-01-39-59.png)

> 我认为问题在于，**这种接受的东西要自由，发送的东西要保守的原则，对于今天的网络和今天的网络系统来说是否仍然合适**？我认为**这一点并不清楚**。Poul-Henning Kamp，FreeBSD的开发者之一，以我见过的最清楚的方式表达了这一点，他说Postel和他所有的朋友生活在一个网络上，而我们今天和我们的敌人生活在一个网络上。**人们正试图破坏系统，人们正恶意地试图破坏我们的代码，破坏我们的应用程序。我认为，波斯特尔法则并不适合今天的互联网。我们不应该，也许，在我们接受的东西方面如此自由。我们应该明确规定什么是合法的。我们应该明确规定代码将接受什么，以及它不接受什么。而且我们应该严格遵守。我们应该严格规定我们的代码如何以及何时失效。因为过于自由的后果就是我们的系统是可以被利用的。如果我们不精确地规定这种行为，就会有太多未定义行为的角落案例**。在IETF的互联网架构委员会中，也有一些关于这个问题的讨论，在链接的草案中。I think the question is whether this principle of being liberal in what you accept, conservative in what you send, is still appropriate for today's network, and for today's networked systems? And I think it's not clear that it is. Poul-Henning Kamp, one of the FreeBSD developers, expressed this in the clearest way I’ve seen, when he said that Postel lived on a network with all of his friends, and we today live on a network with our enemies. People are trying to break the systems, people are trying maliciously to break our code, break our applications. Postel’s law, I think, is not appropriate for today's Internet. We should not, perhaps, be so liberal in what we accept. We should clearly specify what is legal. We should clearly specify what the code will accept, and what it won't accept. And we should be strict about that. We should be strict about how, and when, our code fails. Because the consequences of being too liberal is that our systems are exploitable. If we don't precisely specify that behaviour, there are too many corner-cases with undefined behaviour. The Internet Architecture Board, in the IETF, also has some discussion of this, in the draft I’ve linked.

# 定义合法输入&失败响应：Define Legal Inputs and Failure Responses

![](/static/2022-05-09-01-42-58.png)

- **输入解析器从网络中获取不受信任的输入，生成经过验证的、强类型的数据结构，由代码的其他部分进行处理**。•	The input parser takes untrusted input from the network, generates validated, strongly typed, data structures that are processed by the rest of the code
- **解析器是一个规则驱动的自动机**•	A parser is an rule-driven automaton
  - **它根据一些语法对输入进行解析**•	It parses the input according to some grammar
  - **如果输入与语法不匹配，它就失败**。•	If the input does not match the grammar, it fails
- **正式指定协议语法**•	Formally specify the protocol grammar
  - **定义什么是合法的，什么是不合法的，并以机器可检查的方式将其写下来**•	Define what is legal, and what is not, and write this down in a machine checkable manner
    - 尽可能以限制性的方式定义语法--例如，当正则表达式就足够的时候，不要使用图灵完备的解析。•	Define the grammar in as restrictive a manner as possible – e.g., don’t use a Turing-complete parse when a regular expression will suffice
  - **规定如果输入数据与语法不匹配会发生什么：什么会导致失败？如何处理**？•	Specify what happens if the input data does not match the grammar: what causes a failure? How is it handled?

> **当我们构建网络系统时，我们应该采取的方法是明确规定哪些是合法的，哪些是不合法的。输入解析器被设计成接收不受信任的数据，对其进行验证，并生成强类型的、安全的数据，然后我们可以使用。它们把一些不受信任和不安全的东西，转换为可以信任的、安全的、可用的形式。它们通过根据一些语法来解析输入的内容来做到这一点。如果输入与语法不匹配，解析器就会失败**。When we're building network systems, the approach we should be taking is to clearly specify what is legal, what is not. Input parsers are designed to take in untrusted data, validate it, and generate strongly-typed, safe, data which we can then use. They’re taking something which is untrusted and unsafe, and converting it to a form which can be trusted, and which is safe, which is usable. And they do that by parsing the input according to some grammar. And if the input doesn't match the grammar, the parser fails. 
> 我认为，**很多传统协议和很多传统解析器的问题是，并不清楚该语法是什么，以及失败条件是什么。这就是Postel法则的问题所在。它鼓励每个应用程序以任意的方式扩展语法，要有一点灵活性，要对不同的输入和畸形的输入有一点宽容。这导致了不一致，系统在某些情况下工作，而在其他情况下却不工作。而这些行为的不一致导致了差距，特定的实现方式可以被利用**。And the problem, I think, with a lot of traditional protocols, and a lot of traditional parsers, is that it hasn't been clear what that grammar is, and what are the failure conditions. And this is the problem of Postel’s law. It encourages each application to extend the grammar in arbitrary ways, to be a little bit flexible, a little bit forgiving of giving of different inputs, malformed inputs. And that leads to inconsistencies, systems which work in some cases, which don't work in other cases. And those inconsistencies in behaviour leads to gaps, where particular implementations can be exploited. 
> 因此，我们**应该定义什么是合法的，什么是不合法的，并以一种机器可读的方式写下来。理想情况下，我们应该在协议规范中这样做，协议标准，这样每个实现都可以使用完全相同的语法，接受完全相同的输入，在什么是可接受的，什么是不可接受的方面，没有任何歧义，没有任何不一致**。So, we should define what's legal, and what's not, and write this down in a machine readable way. Ideally, we should do this in the protocol specification, the protocol standard, so every implementation can use the exact same grammar, and accepts the exact same inputs, and there's no ambiguity, non inconsistency, in what's acceptable and what isn't. 
> 理想情况下，**我们应该尽可能地以限制性的方式做到这一点。语法应该在可行的情况下尽量限制。因为我们的表达能力越强，我们就越有可能出现风险，越有可能出现漏洞，越有可能出现歧义**。And Ideally, we should do this in as restrictive a manner as possible. The grammar should be as restricted as it's feasible to do so. Because the more expressive power we have, the more likely we are to have risks, the more scope for vulnerabilities, the more scope for ambiguity. 
> 而且重要的是，**我们应该规定如果数据与语法不匹配会发生什么。我们应该规定什么会导致失败，以及如何处理失败。而且，理想情况下，我们应该在标准中这样做。但如果标准不这样做，每个实现都必须自己做。它必须清楚地说明它接受什么，不接受什么**。And importantly, we should specify what happens if the data doesn't match the grammar. We should specify what causes a failure, and how failures are handled. And, ideally, we should do so in the standard. But if the standard doesn't do this, every implementation has to do it itself. It has to be clear what it's accepting, and what it's not accepting.

# 生成解析器：Generate the Parser

而一旦我们完成了这些，我们就应该自动生成解析代码

- **难以推理出临时的、手工编写的、解析的代码**•	Difficult to reason about ad-hoc, manually written, parsing code
  - 它执行低级别的位操作、字符串解析等，所有这些都很难正确。•	It performs low-level bit manipulation, string parsing, etc., all of which are hard to get correct
  - 它的结构往往很差，很难遵循。•	It tends to be poorly structured, hard to follow
- 相反，**自动生成解析代码**。•	Rather, auto-generate the parsing code:
  - 如果输入语言是正则的，就使用正则表达式•	If input language is regular, use regular expression
  - 如果输入的语言是无语境的，就使用无语境语法•	If input language is context free, use a context free grammar
  - **如果这两种方法都不奏效，就使用更复杂的解析器，以最小的计算能力**。•	If neither of these work, use a more sophisticated parser, with minimal computational power
  - 生成强类型的数据结构，用明确的类型来识别不同的数据项•	Generate strongly typed data structures, with explicit types to identify different data items
- **重点关注解析器的正确性和可读性**•	Focus on parser correctness and readability
  - 解析性能比安全性更重要•	Parsing performance matters less than security

>  我们应该**自动生成解析代码，使用最简单的解析技术。如果我们有一个正则输入语言，我们应该使用一个正则表达式。如果我们有一个无上下文语法，我们应该使用一个无上下文解析器**。 We should automatically generate the parsing code, using the simplest possible parsing technique. If we've got a regular input language, we should use a regular expression. If we've got a context-free grammar we should use a context-free parser. 
> 如果需要的话，我们应该**使用更复杂的解析技术，但是我们应该使用那些最小的计算能力来最小化模糊性，最小化风险，如果我们搞砸了。我们应该生成强类型的数据结构，用明确的类型来识别不同类型的数据，所以我们知道什么被解析了，我们知道它符合一个特定的合法值集**。If need be we should use more sophisticated parsing techniques, but we should use those of the minimal computational power to minimise the ambiguity, minimise the risks, if we mess up. And we should generate strongly-typed data structures, with explicit types to identify the different types of data, so we know what has been parsed, we know that it conforms to a particular legal set of values. 
> 我们应该**使用可以验证的工具来自动做到这一点。这里的很多问题是，人们试图用手写解析器。而手工编写的、临时性的解析代码是很难推理的。它倾向于执行低级别的比特操作。它倾向于执行详细的字符串解析。而所有这些都很难做到正确，很难结构化**。And we should do this automatically using tools which can be validated. And a lot of the problem here is that people try to write parsers by hand. And manually written, ad-hoc, parsing code is very difficult to reason about. It tends to perform low-level bit manipulation. It tends to perform detailed string parsing. And all of this is hard to get right, hard to structure. 
> 但我们知道解析器。**有一整套关于如何设计解析器的理论**，以及一整套语法层次结构，你可以在幻灯片的右侧看到，其中谈到了不同类型解析器的表达能力。还有一大堆结构化解析器的技术。**因此，我们可以写下一个语法，我们可以正式地验证这个语法，我们可以正式地从这个语法中自动生成一个解析器，而且我们知道它是一致的，它是正确的**。But we know about parsers. There's a whole theory of how to design parsers, and a whole grammar hierarchy, which you see on the right hand side of the slide, which talks about expressivity of the different types of parsers. And there’s a whole bunch of techniques for structuring parsers. So we can write down a grammar, we can formally verify the grammar, we can formally generated a parser automatically from that grammar, and we know that it's consistent, and that it’s correct. 
> 我认为关键的**目标是要关注解析器的正确性和可读性。性能的重要性远远低于把它弄对，把它弄安全**。And I think the key goal is to focus on parser correctness and readability. Performance matters much less than getting this right, getting this to be secure.

---

- **使用现有的、经过良好测试的解析器库**•	Use existing, well-tested, parser libraries

![](/static/2022-05-09-01-54-51.png)

> **为了提高系统代码的安全性，我们可以做的关键事情之一是使用现有的、经过良好测试的解析器库。并将它们作为我们网络应用的输入端**。如果你在写Rust代码，请使用类似nom或combined的东西。久经考验、结构良好的解析器组合库，让你轻松指定语法，轻松指定解析规则。如果你使用C或C++，使用Hammer解析器，同样，它被设计成健壮的，被设计成可测试的，并以结构化的、定义好的方式失败。阅读这篇论文，"Writing Parsers like it is 2017"，这表明这**并不是一个新的想法，其中谈到了如何制作健壮的解析器**。One of the key things we can do to improve the security of systems code, is use existing, well-tested, parser libraries. And use them as the input side of our networked applications. If you're writing Rust code, use something like nom or combine. Well-tested, well-structured, parser combinator libraries, which let you easily specify the grammar, easily specify the parsing rules. If you're using C or C++, use the Hammer parser which, again, is designed to be robust, designed to be testable and to fail in structured, well-defined, ways. Read this paper, “Writing Parsers like it is 2017”, and this shows how this is not a new idea, which talks about how to make robust parsers.

---

![](/static/2022-05-09-01-57-34.png)

- **指定解析后的数据所存储的类型**•	Specify the types into which parsed data is stored
- **使用适当的形式语言来描述解析器--例如使用nom**•	Describe the parser using an appropriate formal language – example uses nom
- **从该语言生成解析器**•	Generate the parser from that language
- **首先进行解析，要么全部成功，要么失败--代码的其余部分只使用安全的、预先解析的数据**•	Parsing is performed first, and either succeeds in its entirety or fails – the rest of the code uses only safe, pre-parsed, data

> **指定数据被解析成的类型，用形式化语言描述解析器，从该语言生成解析器。并确保首先进行解析，并且要么成功，要么完全失败。然后，如果它成功了，你就有了安全的、预先解析过的、结构化的、强类型的数据，可以在此基础上构建其余的代码**。Specify the types into which the data is parsed, describe the parser using a formal language, generate the parser from that language. And ensure that the parsing is performed first, and either succeeds or fails in its entirety. And then, if it succeeds, you have safe, pre-parsed, structured, strongly-typed, data on which to build the rest of the code.
> **输入解析器是困难的。如果以一种临时的方式来写，它们就很难做对。特别是，如果用低级别的内存不安全的语言来写，因为它们涉及到大量的位操作，大量的字符串处理，这些都是这些语言中最难的特性**。 Input parsers are difficult. They’re very difficult to get right, if written in an ad-hoc way. And, especially, if written in a low-level memory unsafe language, because they involve lots of bit manipulation, lots of string handling, which are the features which are the hardest in those languages.
> **然而我们有工具，我们有解析器生成器工具，所以让我们利用它们。即使我们仍在使用C或C++，我们也有工具可以使之更安全**。 Yet we have tools, we have parser generator tools, so let's make use of them. Even if we're still using C or C++, we've got tools that can make this safer.

# 定义可解析协议：Define Parsable Protocols

- **如果设计网络协议，要考虑解析的便利性**•	If designing network protocols, consider ease of parsing
- **尽量减少解析数据所需的状态和前瞻的数量**•	Minimise the amount of state and look-ahead required to parse the data
- **宁可选择一个可预测的、有规律的语法，而不是以复杂的解析为代价来节省比特**。•	Prefer a predictable, regular, grammar to one that saves bits at the expense of complex parsing
  - 网络越来越快，安全漏洞依然存在•	Networks get faster, security vulnerabilities remain
  - 随着时间的推移，节省几个比特的好处会越来越少•	The benefit of saving a few bits gets less over time
  - 易于安全解析的好处依然存在•	The benefit of being easy to parse securely remains

> 当我们**在设计网络协议时，我们应该考虑到解析的便利性。我们应该考虑尽量减少状态的数量，以及解析协议数据所需的提前量。我们应该考虑格式的复杂性，以及它是否容易解析。我们应该设计网络协议，使其具有可预测性，使其能够使用正则表达式或上下文自由语法进行解析，而不是需要复杂的、依赖于状态的解析，因为这使我们能够使用更简单的解析生成器和更简单的解析代码，并减少出现错误的几率**。And when we're designing network protocols, we should be thinking about ease of parsing. We should be thinking about minimising the amount of state, the amount of look-ahead required to parse the protocol data. We should be thinking about the complexity of the format, and how easy it is to parse, or not to parse. We should be designing network protocols, such they are predictable, such that they can be parsed using regular expressions, or context free grammars, rather than needing complex, state-dependent parsing, because that allows us to use simpler parser generators, and simpler parsing code, and reduce the chances of there being bugs.
> 随着时间的推移，**由于网络速度越来越快，通过更复杂的格式来节省一些比特的好处就会减少。安全漏洞仍然存在。我们应该以简单和容易解析为目标，并且我们应该使用最好的解析工具来消除这些漏洞**。 The benefit of saving a few bits, by having a more sophisticated, more complex, format goes down over time, because the networks get faster. The security vulnerabilities remain. We should be aiming for simplicity and ease of parsing, and we should be using the best parsing tools we can to get rid of these vulnerabilities.

# Parsing and LangSec

- 阅读："我们必须杀死的bug"•	Read: “The Bugs We Have to Kill”
- 这种方法现实吗？•	Is this approach realistic?
- 我们能否将更好的解析与现代强类型语言结合起来，以提高网络安全？•	Can we combine better parsing with modern, strongly typed, languages to improve network security?
- 性能足够好吗？•	Is performance good enough?
- 我们能改进设计协议的方式吗？•	Can we improve the way we design protocols?

> 我敦促你阅读这篇论文，"我们必须杀死的bug"，它更详细地谈论了这些想法。它谈到了这种方法，**即使用解析器生成器工具、现代语言和强类型系统。我认为我们可以通过这样做来大规模地提高网络安全。我们可以通过使用这些技术来提高网络安全，即使是在不安全的语言中。因此，如果你仍然要写C或C++代码，想想你如何写输入解析器，想想使用一个经过良好测试的、结构良好的、解析工具，比如Hammer。写下语法，写下失败条件。而且，理想情况下，是的，用一种安全的语言来实现，但即使你不是，我们有更好的工具，我们只需要使用它们**。And I would urge you to read this paper, “The Bugs We Have to Kill”, which talks much more in detail about these ideas. It talks about this approach, of using parser generator tools, modern languages, strong type systems. I think we can we can massively improve network security by doing this. We can improve network security by using these techniques, even in unsafe languages. So if you still have to write C or C++ code, think how you write the input parser, think about using a well-tested, well-structured, parsing tool, like Hammer. Write down the grammar, write down the failure conditions. And, ideally, yes, implement this in a safe language, but even if you're not, we have better tools, we just need to use them.

# ==================

# 3现代类型系统&安全：Modern Type Systems and Security

讲座的最后部分讨论了一些**与内存安全无关的网络应用安全漏洞的原因**。它指出，这些原因往往是由于未能在代码中明确假设，使得攻击者可以利用不一致的行为来导致程序做一些意想不到的事情。该报告指出，**强类型语言中的类型驱动开发对于迫使假设明确化和检查设计的一致性的影响，可能是减少漏洞存在可能性的一个驱动因素**。人们注意到，**内存安全、强类型语言的使用和类型驱动设计不会消除安全漏洞，但它们确实有可能减少它们的普遍性**。

我已经谈到了内存安全，**我已经谈到了内存不安全的语言有大量的未定义行为，这往往会导致可利用的漏洞。我谈了一点关于解析的问题，解析非结构化数据的问题，并建议我们需要正式的解析库，输入语法的正式定义，这样我们就能确定我们的系统接受什么，不接受什么，并减少解析不信任的数据的一些风险**。我还说了一点，**通过仔细地构造我们的代码，并使用现代类型系统记录假设，我们可以减少系统有不一致和无法解释的行为的风险。作为专业的工程师，我们需要建立安全的、符合目的的系统。通过逐步转向内存安全的语言，转向具有更强类型系统的语言，允许我们正式指定其行为，并通过检查这些行为来帮助我们，我认为我们可以开始避免许多代码中固有的一些问题。我认为，作为专业的、有道德的工程师，我们有责任这样做**。And that's what I want to say about security. I’ve spoken about memory safety, I’ve talked about how memory unsafe languages have a large number of undefined behaviours, which tend to lead to exploitable vulnerabilities. I spoke a little bit about parsing, the problems of parsing unstructured data, and suggested we need formalised parsing libraries, formal definitions of the input grammar, such that we can be sure what is accepted, and what is not, by our systems, and to reduce some of the risks in parsing untrusted data. And I said a little bit about how by carefully structuring our code, and documenting the assumptions using modern type systems, we can reduce the risks that the system has inconsistencies and unexplainable behaviours. As professional engineers, we need to build systems which are secure and fit for purpose. By gradually moving to memory safe languages, to languages which have stronger type systems, that allow us to formally specify their behaviours, and that help us by checking those behaviours, I think we can start to avoid some of the problems inherent in a lot of code. And I think as professional, ethical, engineers it behooves us to do that.


# 安全漏洞原因：Causes of Security Vulnerabilities

- **安全漏洞一般是由说服程序做一些程序员没有想到的事情而引起的**•	Security vulnerabilities generally caused by persuading a program to do something that the programmer did not expect
  - 写过了缓冲区的末端•	Write past the end of a buffer
  - 将用户输入的信息视为可执行信息•	Treat user input as executable
  - 混淆权限检查•	Confuse a permission check
  - ...
- **违反了代码中的一个假设**•	Violate an assumption in the code

> 那么**是什么导致了系统的安全漏洞呢**？嗯，它们**往往是由攻击者说服程序做一些程序员没有想到的事情而引起的。当攻击者能够说服程序违反它的假设时，安全漏洞就会发生**。 So what causes security vulnerabilities in systems? Well, they tend to be caused by the attacker persuading the program to do something which the programmer didn't expect. Security vulnerabilities occur when the attacker can persuade the program to violate it’s assumptions.
> **如果你能说服程序用一种不安全的内存语言写过缓冲区的末端，并破坏状态，这就会导致它以一种意外的方式行事。如果你能说服程序以某种方式将用户输入的数据视为可执行的，例如通过滥用转义字符。如果你能以某种方式混淆权限检查。或者任何其他类型的行为，攻击者可以强迫程序做一些程序员没有想到的事情**。 If you can persuade the program to write past the end of a buffer, in a memory unsafe language, and corrupt the state, which can then cause it to behave in an unexpected way. If you can persuade the program to treat user input data as executable somehow, by misusing using escape characters for example. If you can confuse a permission check somehow. Or any other type of behaviour which the attacker can force the program to do, which the programmer isn't expecting.
> 从本质上讲，**攻击者的目标，即试图闯入一个网络系统的人的目标，是违反代码中的假设。混淆程序，使其做一些预期之外的事情。这样做的一个结果是，我们可以做的任何事情，使假设明确，并检查这些假设，有助于避免安全漏洞**。 Essentially, the goal of an attacker, the goal of someone who is trying to break into a networked system, is to violate the assumptions in the code. To confuse the program into doing something which is not expected to do. A consequence of that, is that anything we can do to make the assumptions explicit, and check those assumptions, helps avoid security vulnerabilities.

---

:orange: 解决方式

- **强类型化使假设显性化**•	Strong typing makes assumptions explicit
  - 使用显式的类型而不是通用类型•	Use explicit types rather than generic types
  - 定义安全的转换函数•	Define safe conversion functions
  - 必要时使用幻象类型，对数据应用语义标签•	Use phantom types where necessary, to apply semantic tags to data

> 我之所以一直强调强类型，很大程度上是因为**强类型使假设变得明确。它们让编译器检查我们在程序中所做的事情是否合理。由于这个原因，我认为强类型有助于减少代码中的安全漏洞**。A lot of the reason why I’ve been highlighting, and emphasising, strong typing, is that strong types make the assumptions explicit. They let the compiler check that what we're doing in the program makes sense. And for this reason, I would argue that strong typing helps reduce the security vulnerabilities in code. 
> 通过**使用显式的类型而不是通用类型，通过定义转换函数，通过使用类型系统为数据添加语义标签以帮助我们理解它的含义，我们可以清楚地知道数据应该如何被处理。我们可以清楚数据是什么，对它做了什么，以及对该数据的合法操作是什么**。By using explicit types rather than generic types, by defining conversion functions, by using the type system to add semantic tags to the data to help us understand what it means, we can be clear how the data should be processed. We can be clear what the data is, what has been done to it, and what are the legal operations on that data. 
> **通过明确规定合法的操作，我们可以让编译器帮助我们检查非法操作是否被执行。而这一点，我认为是提高系统安全性的关键**。And by clearly specifying the legal operations, we can have the compiler help us check that illegal operations are not performed. And this, I think, is key to improving the security of systems. 
> 大多数安全漏洞并不复杂。它们不是微妙的、神奇的、错误的行为。**它们是简单的东西，是被遗忘的简单检查。我们越是能在代码中表达所需的行为，编译器就越能帮助我们确保我们不会忘记这些检查**。Most security vulnerabilities are not complex. They’re not subtle, magic, misbehaviours. They’re simple things, simple checks which have been forgotten. And the more we can express the desired behaviour in the code, the more the compiler can help us make sure that we don't forget those checks.

# 显式类型：Prefer Explicit Types

- **漏洞来自于不一致的数据处理**。•	Vulnerabilities come from inconsistent data processing:
  - 例如，将**未经消毒的用户输入数据传递给期望有效SQL的函数**。•	e.g., passing un-sanitised user entered data to a function that expects valid SQL
    - StudentName和SqlString是不同的；**给它们不同的类型，这样编译器就能捕捉到不一致的用法**•	A StudentName and an SqlString are different; give them different types so compiler can catch inconsistent usage
    - 在将任意的学生姓名安全地存储在SQL数据库中之前，必须**对某些字符进行转义**。•	Certain characters must be escaped before an arbitrary student name can be safely stored in an SQL database
- **如果到处使用String，程序员必须手动检查一致性**•	If String used everywhere, the programmer must manually check for consistency
  - **容易犯错**•	Easy to make mistakes
  - **如果所有的类型都是一样的，编译器就无法帮助**。•	If all the types are the same, the compiler can’t help

> **在处理数据的时候，你应该更喜欢显式类型。很多原因是漏洞来自不一致的数据处理。很容易不小心把从网络上传来的数据，在未经消毒的情况下，传给处理这些数据的函数并执行这些数据**。When dealing with data, you should prefer explicit types. A lot of the reason for this, is because vulnerabilities come from inconsistent data processing. It's easy to accidentally take data which arrives off the network, and pass it, un-sanitised, to a function which processes that data and execute that data. 
> 幻灯片上的《XKCD》漫画非常有名，就是这样一个例子，你拿着一些输入数据，在这种情况下是学生的名字，不小心把它传给了一个期待有效SQL数据的函数。因为学生的名字中嵌入了一个有效的SQL命令，它被执行并破坏了数据库。这种类型的错误发生，是因为我们混淆了不同类型的数据。因为在这个例子中，我们把一个人的名字和一组SQL命令混在一起。但是学生的名字、输入数据和SQL数据是不同的类型。The XKCD cartoon, which is pretty well-known, on the slide, is an example of this, where you're taking some input data, in this case the student’s name, and accidentally passing it to a function that expects valid SQL data. And because the student’s name has a valid SQL command embedded within it, it gets executed and corrupts the database. And this type of bug happens, because we're conflating different types of data. Because we're conflating, in this example, a person's name with a set of SQL commands. But student names, and input data, and SQL data, are different types. 
> 应该可以**用一种方式来编写代码，用一种类型的值来表示不受信任的输入数据，用另一种数据类型来表示SQL命令。并有一个特定的转换函数，在数据格式之间进行转换，并在进行转换之前对数据进行验证。通过这样做，将这些不同类型的数据放在不同的类型中，我们就不会意外地将数据传递到错误的函数中。它可以阻止我们意外地将不值得信任的输入数据作为SQL字符串传递**。**但这只有在我们为不同的事情使用不同的类型时才有效**。And it should be possible to write the code in a way that uses one type of value to represent untrusted input data, and another data type to represent SQL commands. And to have a specific conversion function, which converts between the data formats, and validates the data, before making that conversion. And by doing that, by having these different types of data in different types, we can't accidentally pass the data into the wrong function. It stops us accidentally passing untrusted input data as an SQL string. But that only works if we use different types for different things. 
> 如果我们**在任何地方都使用字符串**，那么程序员就必须在他们的头脑中保持 "这是可信的吗？这是不被信任的吗？它已经被验证了吗？它被正确地转义了吗？" 这就**很容易犯错**。If we use a string everywhere, then the programmer must keep in their head “is this trusted? Is this untrusted? Has it been validated? Has it been correctly escaped?” And it's easy to make mistakes. 
> 如果我们**到处使用相同的类型，如果我们使用相同的字符串类型来表示来自网络的输入数据和学生姓名，就像我们用来表示SQL命令一样，编译器就不能帮助我们**。If we use the same type everywhere, if we use the same string type to represent input data from the network and student names, as we use to represent the SQL commands, the compiler can't help us. 
> 因此，我的第一个建议是：**为了提高你的系统的安全性，考虑一下不同的类型是什么，用不同的类型来表示不同种类的数据。使用不同的类型来表示经过解析、验证的、可信的数据，而不是用来表示不可信的输入数据，并仔细地在它们之间进行转换**。So my first suggestion: to improve the security of your systems, think about what the different types are, and use different types to represent different sorts of data. Use a different type to represent the parsed, validated, trusted, data, from that used to represent the untrusted input data, and carefully convert between them.

# 谨慎数据转换：Convert Data Carefully

- **显式的类型需要类型转换**•	Explicit types require type conversions
  - **强化安全边界**•	Enforce security boundaries
  - 不受信任的用户输入→转义的、安全的、内部的形式；在使用前验证输入•	Untrusted user input → escaped, safe, internal form; validate input before using it
  - **确保只发生合法的转换**•	Ensure only legal conversions occur

> **当你转换数据时，确保有显式的类型转换函数，并使用这些函数来执行安全边界**。 Make sure when you are converting data, make sure that there are explicit type conversion functions, and use these to enforce the security boundaries. 
> **不值得信任的输入数据是一回事，它需要被小心处理。但我们可以处理它，我们可以转义它，我们可以尝试将它转换为一些安全的、可信的、内部的形式，确保所有的元字符、转义序列等都被正确处理。我们可以在使用它之前对它进行验证**。Untrusted input data is one thing, it needs to be handled with care. But we can process it, we can escape it, we can try to convert it to some safe, trusted, internal form, making sure that all of meta characters, the escape sequences, and so on have been correctly handled. We can validate it before we're using it. 
> 我们可以**编写显式转换函数，在代表输入数据的类型和代表要处理的数据的类型之间进行转换。这可以确保只有合法的转换发生，并且可以确保，为了转换数据，它必须被验证**。And we can write explicit conversion functions, to convert between the type representing the input data, and the type representing the data to be processed. And this can ensure that only legal conversions occur, and it can ensure that, in order to convert the data, it has to be validated. 
> 这种组合，即使**用不同类型的输入数据和经过解析、处理、验证的数据，以及明确的转换函数，并确保在这些类型之间转换的唯一方法是使用有效的、验证的转换函数，确保只有合法的转换可以发生**。And this combination, of using different types for input data and parsed, processed, validated, data, and explicit conversion functions, and making sure the only way to convert between those types is by using a valid, validating, conversion function, makes sure that only legal conversions can happen. 
> 这**有助于确保我们不会意外地将不值得信任的数据传递到不该传递的地方。这是一种执行安全边界的方式，一种区分安全和不安全数据的方式，并且只允许在那些验证了数据完整性的数据之间进行转换**。And helps make sure that we don't accidentally pass untrusted data somewhere where we shouldn’t. It's a way of enforcing the security boundaries, a way of distinguishing secure and insecure data, and of only allowing conversions between those that validate the data integrity.

# 幻像类型添加语义标签：Use Phantom Types to add semantic Tags

- **幻象类型参数是指在运行时不显示，但在编译时被检查的类型**。•	A phantom type parameter is one that doesn't show up at runtime, but is checked at compile time
  - 在Rust中，一个**没有字段的结构有一个类型，但大小为零**。•	In Rust, a struct with no fields has a type but is zero sized
    - ![](/static/2022-05-09-02-27-15.png)
  - **作为类型参数，可以为数据添加语义标签**。•	Useful as type parameters to add semantic tags to data:

  - **有助于表示状态机中的状态**•	Useful to represent states in a state machine

> 我们**应该考虑标记数据的方法，标记数据是否被检查的方法，以及标记它与处理它的假设的方法**。And we should think about ways of labelling the data, ways of labelling whether data has been checked or not, and ways of tagging it with the assumptions were making about its processing. 
> 在像Rust这样的语言中，或者许多其他更现代的强类型语言中，完全有可能给类型添加标签。例如，在Rust中，完全可以定义一个没有字段的结构。其结果没有大小，因为**它没有内容，但是它可以作为一个参数，作为一个类型参数，来给数据添加语义标签**。And in languages like Rust, or many other more modern strongly-typed languages, it's entirely possible to add tags to the types. It's entirely possible in Rust, for example, to define a struct that has no fields. And the result has no size, because it has no content, but it can be used as a parameter, as a type parameter, to add a semantic tags to the data. 
> 所以在这个例子中，我们定义了两个结构，UserInput和Sanitised，这两个结构都是空的。它们没有大小，没有字段，因此也没有大小，但是我们用一个类型参数来标记 Html 类型，这个类型是 UserInput 或 Sanitised。So in the example we define two structs, UserInput and Sanitised, both of which are empty. They have no size, no fields and therefore no size, but we tag the Html type with a type parameter, which is either UserInput or Sanitised. 
> 我们可以写一个 sanitise_html() 函数，它接收用户输入形式的 HTML，并返回经过消毒的 HTML，在这两种形式之间进行转换，我们可以确保所有接收 HTML 的东西都是这两种变体之一。And we can write a sanitise_html() function, that takes HTML in the form of user input, and returns sanitised HTML, to convert between the two forms, and we can make sure that everything that takes HTML takes one of these two variants. 
> 因此，**我们可以用它来表示一个特定的处理步骤是否已经被执行。我们可以用它来表示各种状态机中的状态，这些状态机定义了系统中的行为**，正如我们在课程的早期所看到的那样。So we can use it to represent whether a particular processing step has been performed. We can use it to represent states in the various state machines that define the behaviour in the system, as we saw earlier in the course. 
> 同样，**关键是要给数据贴上标签，说明对数据做了什么，使假设明确。然后，编译器可以帮助我们，检查我们传递的数据是否已经被正确地标记为进行了特定的净化操作。这并不能阻止错误的发生，它只是限制了错误的范围。如果我们搞砸了，如果我们写错了转换，编译器可以为我们发现问题**。Again, the point is to label the data, to specify what has been done to the data, to make the assumptions explicit. And then the compiler can help us, by checking that the data we're passing around has been correctly tagged as having had the particular sanitising operations performed. It doesn't stop the bugs, it just limits the scope of them. If we mess up, if we write the conversions wrongly, the compiler can detect the problems for us.

# No Silver Bullet

- **内存安全和强类型化并不能消除安全漏洞**•	Memory safety and strong typing won’t eliminate security vulnerabilities
- 但是，**如果小心使用，它们可以消除某些类别的漏洞，并通过使隐藏的假设可见而使其他漏洞的可能性降低**。•	But, used carefully, they eliminate certain classes of vulnerability, and make others less likely by making hidden assumptions visible

> 而且，说白了，**使用内存安全语言、使用强类型、使用显式类型、为验证或未验证的数据提供不同的类型、转换函数、语义标签，所有这些东西都不会消除安全漏洞. 使用内存安全语言也不会消除安全漏洞**。And, to be clear, the use of memory safe languages, the use of strong typing, the use of explicit types, different types for validated or unvalidated data, conversion functions, semantic tags, all of these things are not going to eliminate security vulnerabilities. The use of memory safe languages is not going to eliminate security vulnerabilities.
> 不过，**它们所做的是消除某些类别的漏洞**。当我们用C语言编写网络代码、安全关键代码时，我们必须持续关注缓冲区溢出，比如说。我们必须不断调试代码，不断修复缓冲区溢出，一次一个。如果我们用Rust写代码，缓冲区溢出就不会发生。我们已经消除了一类特殊的漏洞。这就是内存安全语言的好处。这也是强类型语言的好处。 What they do, though, is eliminate certain classes of vulnerabilities. When we're writing networked code, security critical code in C, we have to be continually on the lookout for buffer overflows, for example. We have to keep debugging code, keep fixing buffer overflows, one at a time. If we write the code in Rust, buffer overflows can't happen. We've eliminated a particular class of vulnerability. This is the benefit of memory safe languages. This is the benefit of strongly-typed languages. 
> 这**并不是说它们摆脱了安全漏洞，而是说它们摆脱了特定类型的安全漏洞，让我们把精力放在其他类型上。强类型的使用并没有摆脱安全漏洞，但它让我们的假设变得清晰。它让我们更清楚地向编译器说明我们编写代码的目标是什么，然后编译器可以帮助我们检查代码是否符合这个目标**。It's not that they get rid of security vulnerabilities, it’s that they get rid of particular types of security vulnerability, and let us focus our efforts on the other types. The use of strong typing doesn't get rid of security vulnerabilities, but it lets us make our assumptions clear. It lets us more clearly specify to the compiler what our goal is in writing the code, and the compiler can then help us check that the code meets that goal. 
> 而且，**就漏洞发生的程度而言，因为攻击者有办法违反这些假设，发现我们所遗漏的情况，我们越是能够明确说明，以便编译器能够帮助我们发现这些情况，这些漏洞就越不可能持续存在**。And, to the extent that vulnerabilities occur because the attackers have ways of violating those assumptions, spotting the cases we've missed, the more we can specify, so the compiler can help us spot those cases, the less likely it is that these vulnerabilities persist. 
> **我们永远不可能完全摆脱安全漏洞的困扰。这里没有神奇的银弹。但我们可以消除某些类型的漏洞。而且我们可以通过明确规定假设，使确实存在的代码中的漏洞不太可能出现**。We're never going to get rid of security vulnerabilities entirely. There's no magic silver bullet here. But we can eliminate certain types of vulnerability. And we can make vulnerabilities in the code which does exist less likely by clearly specifying the assumptions.

# 责任与道德:Liability and Ethics

ACM道德和职业行为准则。

![](/static/2022-05-09-02-35-04.png)

安全漏洞和软件故障经常造成伤害--你能证明你的专业实践是正确的吗？Security vulnerabilities and software failures routinely cause harm – can you justify your professional practice?

> 而且，**作为程序员，我们需要开始思考我们如何写代码。例如，如果你查一下ACM的道德准则，每个工程师必须做的关键事情之一就是避免造成伤害**。And, as programmers, we need to start thinking about how we write code. If you look up, for example, the ACM code of ethics, one of the key things every engineer has to do, is avoid causing harm. 
> 当我们建造系统时，无论是软件系统，还是桥梁，或任何其他类型的工程，我们必须避免造成伤害。对于土木工程师来说，这意味着使用适当的技术来建造桥梁，使它们不会倒下。对于软件工程师来说，这意味着使用适当的技术来确保我们的软件不会造成伤害。而且，不幸的是，**安全漏洞和软件故障确实经常造成伤害**。When we're building systems, whether they're software systems, or bridges, or any other type of engineering, we have to avoid causing harm. And for the Civil Engineers, that means using appropriate techniques to build the bridges such that they don't fall down. For the software engineers, it means using appropriate techniques to make sure our software doesn't cause harm. And, unfortunately, security vulnerabilities, and software failures, do routinely cause harm. 
> 我想，我想让你思考的问题是，**你是否遵循最佳实践来避免这种伤害。如果你用C语言编写一个网络系统，当我们知道内存不安全的语言很可能会出现缓冲区溢出、空闲后使用的错误、竞争条件等等，从而导致安全漏洞时，你能真正声称你在遵循最佳实践来避免伤害吗？你能证明你的专业实践是正确的吗**？And I think the question I want you to think about, is whether you are following best practices to avoid that harm. If you're writing a networked system in C, can you actually claim you're following best practices to avoid harm, when we know that a memory unsafe language is likely to suffer from buffer overflows, use after free bugs, race conditions, and so on, which cause security vulnerabilities. Can you justify your professional practice? 
> 我认为，我们正在迅速进入这样一个阶段：**某种软件故障或安全漏洞将造成重大伤害。而这将导致一场诉讼。一些软件工程师，在某个地方，将在法庭上被要求证明他们的程序，并将被要求证明你是否遵循了最佳实践**？And I think, we are rapidly getting to the stage where, some sort of software failure or security vulnerability is going to cause significant harm. And that is going to result in a lawsuit. And some software engineer, somewhere, is going to be up in court, and will be asked to justify their processes, and will be asked to justify did you follow best practices? 
> 我们都知道，人并不完美，我们都知道错误会发生。**问题不在于确保没有人犯过错误。问题是确保人们遵循最佳做法，以减少人为错误，并降低风险**。我认为，**今天的最佳实践是使用内存安全语言，使用强类型系统，使用结构化方法来定义我们的软件。但我们是否总是这样做并不清楚。但是，作为一个社区，我认为我们希望在我们受到法律诉讼的威胁之前，转向以一种更有结构、更明确、更安全的方式来构建软件**。And we all know that people are not perfect, we all know that mistakes happen. And the issue is not making sure that no-one ever makes a mistake. The issue is making sure people follow best practices, to mitigate human errors, and to mitigate risk. And I would argue that the best practice today is using memory safe languages, is using strong type systems, is using structured methodologies for defining our software. And it's not clear that we're necessarily always doing that. But as a community, I think we want to shift towards building software in a in a more structured, more well-defined, more secure, way, before we are forced to, by threat of lawsuit.

# ==================

# Reading

1. P. Chifflier and G. Couprie. Writing parsers like it is 2017. IEEE Workshop on Language-Theoretic Security, San Jose, CA, USA, May 2017. https://dx.doi.org/10.1109/SPW.2017.39

* 为了提高系统代码的安全性，我们可以做的关键事情之一是使用现有的、经过良好测试的解析器库。并将它们作为我们网络应用的输入端
* 并不是一个新的想法，其中谈到了如何制作健壮的解析器

2. S. Bratus, M. L. Patterson, and A. Shubina. The bugs we have to kill. ;login:, 40(4):4–10, August 2015. http://langsec.org/papers/the-bugs-we-have-to-kill.pdf

- 阅读："我们必须杀死的bug"•	Read: “The Bugs We Have to Kill”
- 这种方法现实吗？•	Is this approach realistic?
- 我们能否将更好的解析与现代强类型语言结合起来，以提高网络安全？•	Can we combine better parsing with modern, strongly typed, languages to improve network security?
- 性能足够好吗？•	Is performance good enough?
- 我们能改进设计协议的方式吗？•	Can we improve the way we design protocols?
- **即使用解析器生成器工具、现代语言和强类型系统。我认为我们可以通过这样做来大规模地提高网络安全。我们可以通过使用这些技术来提高网络安全，即使是在不安全的语言中。因此，如果你仍然要写C或C++代码，想想你如何写输入解析器，想想使用一个经过良好测试的、结构良好的、解析工具，比如Hammer。写下语法，写下失败条件。而且，理想情况下，是的，用一种安全的语言来实现，但即使你不是，我们有更好的工具，我们只需要使用它们**
