# Content

讨论了类型和类型系统的一些概念，并试图强调从弱类型语言（如 C）转向更强类型、更安全的系统编程语言的好处。它开始介绍 Rust 编程语言，作为这种更安全的系统语言的一个例子 Lecture 3 discusses some of the concepts around types and type systems, and tries to highlight the benefits of moving from a weakly-typed language, such as C, to a more strongly-typed, safer, systems programming language. It begins to introduce the Rust programming language, as an example of such a safer systems language.

* [Content](#content)
* [类型和系统编程：Types and Systems Programming](#类型和系统编程types-and-systems-programming)
* [类型定义：What is a Type](#类型定义what-is-a-type)
* [类型系统：What is a Type System](#类型系统what-is-a-type-system)
* [类型系统的类型:Types of Type Systems](#类型系统的类型types-of-type-systems)
* [静态类型，动态类型：Static and Dynamic Types](#静态类型动态类型static-and-dynamic-types)
  * [对比](#对比)
* [强类型，弱类型：Strong and Weak Types](#强类型弱类型strong-and-weak-types)
* [安全语言 & 不安全语言（强弱类型）：Safe language & unsafe language](#安全语言--不安全语言强弱类型safe-language--unsafe-language)
* [为什么选择强类型：Why is Strong Typing Desirable?](#为什么选择强类型why-is-strong-typing-desirable)
* [segmentation fault (core dumped)](#segmentation-fault-core-dumped)
* [C语言（弱类型）-系统编程：Types for Systems Programming](#c语言弱类型-系统编程types-for-systems-programming)
* [系统编程能用强类型系统吗？：Is Strongly-typed Systems Programming Feasible?](#系统编程能用强类型系统吗is-strongly-typed-systems-programming-feasible)
* [==================](#)
* [Rust](#rust)
* [基本特性&类型：Basic Features and Types](#基本特性类型basic-features-and-types)
  * [函数调用，返回类型,可变变量，不可变变量](#函数调用返回类型可变变量不可变变量)
  * [基本类型：primitive types](#基本类型primitive-types)
* [数组：Arrays](#数组arrays)
  * [可变数组：Vectors](#可变数组vectors)
* [tuples](#tuples)
* [structs](#structs)
  * [结构体方法 method on structs](#结构体方法-method-on-structs)
* [traits](#traits)
  * [trait-多类型](#trait-多类型)
* [trait-通用函数（模拟类继承通用函数）](#trait-通用函数模拟类继承通用函数)
* [共同traits：Deriving Common Traits](#共同traitsderiving-common-traits)
* [关联types-traits：Associated Types](#关联types-traitsassociated-types)
* [枚举：Enumerated types](#枚举enumerated-types)
  * [枚举类型参数：eters](#枚举类型参数eters)
* [标准枚举-Option, Result](#标准枚举-option-result)
* [模式匹配：pattern Matching](#模式匹配pattern-matching)
* [利用模式匹配避免空指针](#利用模式匹配避免空指针)
* [==================](#-1)
* [Rust引用：References](#rust引用references)
* [Rust引用限制：Constraints on References](#rust引用限制constraints-on-references)
* [内存分配 & Box：Memory Allocation and Boxes](#内存分配--boxmemory-allocation-and-boxes)
* [Strings](#strings)
* [Rust特点:key points](#rust特点key-points)
* [=================](#-2)
* [Reading](#reading)

# 类型和系统编程：Types and Systems Programming

讨论了编程语言中类型的概念。它回顾了**什么是类型和类型系统**，并讨论了**静态类型与动态类型、强类型与弱类型**以及**安全与不安全编程语言**的概念。它强调了**强类型安全语言对于系统编程的好处** discusses the idea of types in programming languages. It review what is a type and a type system, and discusses the concepts of static vs. dynamic typing, strong vs. weak types, and safe vs. unsafe programming languages. It highlights the benefits of strongly typed safe languages for systems programming.

# 类型定义：What is a Type

A type describes what an item of data represents一个类型描述了一个数据项所代表的内容

![](/static/2022-01-27-16-34-06.png)

什么是类型？ what is a type? 

在编程语言中，**类型是描述一个数据项代表什么的东西**。它告诉我们一个特定的变量是否可以容纳一个整数、一个浮点值、一个文件、一个序列号、一个用户名，或者任何它发生的东西。它从概念上说，**一个变量所代表的数据是什么，以及该数据是如何表示的**？a type in programming languages is something which describes what an item of data represents. It tells us whether a particular variable can hold an integer, a floating point value, a file, a sequence number, a username, or whatever it happens to be. It says conceptually what is the data which is represented by a variable, and how is that data represented?

类型在编程中是非常熟悉的。例如，如果我们看一下屏幕右侧的代码，也就是C代码，我们会看到一些变量声明。**我们可以指定变量的类型**。例如，我们指定x持有一个整数；y持有一个双精度浮点值；而变量hello是一个指向一个字符的指针，在这种情况下是指向字符串 "Hello, world "的第一个字符的指针。我们还可以看到，**定义新的类型是可能的**。例如，幻灯片上的结构，struct sockaddr_in的定义，定义了一个包含五个字段的复合类型：长度、家族、端口、addr和一些填充。其中每个字段都有自己的类型，而其中一个字段的类型又是一个复合类型，即struct in_addr。**这让我们可以建立合理的复杂类型，以表示我们在程序中要处理的不同类型的数据**。 Types are very familiar in programming. For example, if we look at the code on the right hand side of the screen, which is C code, we see a number of variable declarations. We can specify the types of the variable. We specify that x holds an integer, for example; that y holds a double precision floating point value; and that the variable hello is a pointer to a character, in this case a pointer to the first character of the string “Hello, world”. We also see that it’s possible to define new types. For example, the definition of the struct, struct sockaddr_in, on the slide defines a compound type holding five fields: length, family, port, addr, and some padding. Each of which has its own type, and the type of one of these is, in turn, a compound type, struct in_addr. This lets us build up reasonably complex types, to represent the different types of data that we’ll work with in our program.

# 类型系统：What is a Type System

* A type system is a set of rules constraining how types can be used **类型系统是一组限制如何使用类型的规则**
  * What operations can be performed on a type? 在**一个类型上可以进行哪些操作**？
  * What operations can be performed with a type? 可以**对一个类型进行哪些操作**？
  * How does a type compose with other types of data? **一个类型如何与其他类型的数据进行组合**？
    * 不同类型的数据如何与其他类型的数据组成复合数据类型，或指定不同替代方案的类型

类型系统是一组规则，它制约着类型的使用方式。类型系统规定了哪些操作可以在特定类型的数据上执行。哪些操作可以用这些类型的数据进行，以及不同类型的数据如何与其他类型的数据组成复合数据类型，或指定不同替代方案的类型 So given this definition of a type, what is a type system? Well, a type system is a set of rules that constrains how the types can be used. The type system specifies what operations can be performed on particular types of data. What operations can be performed with those types of data, and how the different types of data compose with other types of data to form compound data types, or types specifying different alternatives.

---

* A type system proves the absence of certain program behaviours **一个类型系统证明了某些程序行为的不存在** 【一个类型系统规定了程序可以做什么。它规定了那些特定类型的对象的合法行为。同样地，它证明了程序不能做某些事情。它证明了程序不能执行某些非法行为 A type system specifies what the program can do. It specifies the legal behaviour for objects of those particular types. Equally, it proves that the program can't do certain things. It proves that the program can't perform certain illegal behaviours.】
  * It doesn’t guarantee the program is correct 它并不保证程序是正确的
  * It does guarantee that some incorrect behaviours do not occur 它确实能保证一些不正确的行为不会发生 【**当然，这并不保证程序是正确的，但它确实保证了某些类型的不正确行为不会出现在一个良好的类型化程序中**。类型系统消除了某些类型的错误，希望不会给语言增加太多的复杂性。**类型系统帮助我们防止的一些错误是直接的** This doesn't guarantee that the program is correct, of course, but it does guarantee that some types of incorrect behaviour don't occur in a well-typed program. Type systems eliminate certain classes of bugs, hopefully without adding too much complexity to the language. Some of the bugs the type system helps us prevent are straightforward.】
    * A good type system eliminates common classes of bug, without adding too much complexity 一个好的类型系统可以消除常见的错误，而不会增加太多的复杂性
      * 例如，它可以防止我们把苹果加到橘子上，得到一个无意义的答案。或者它保证我们不能访问集合中的第11个元素，而这个集合只持有10个元素  It prevents us adding apples to oranges and getting a meaningless answer, for example. Or it guarantees that we can't access the 11th element of the collection, which only holds 10 elements.
      * 不过，有些类型系统可以帮助防止更微妙的错误。例如，现代类型系统可以帮助确保在多线程代码中不会出现竞赛条件。或者它们可以检查程序行为的各种不变量，并检查设计的特定功能是否得到维护。 Some type systems can help protect against more subtle bugs, though. Modern type systems, for example, can help make sure that race conditions don't occur in multi threaded code. Or they can check various invariants of the program behaviour, and check that particular features of the design are upheld.
      * **设计一个类型系统的目标是通过类型系统的复杂性和特性，与捕捉错误的能力相平衡** The goal of designing a type system is to balance complexity, through the complexity and the features of the type system, with the ability to catch bugs.
    * A bad type system adds complexity to the language, but doesn't prevent many bugs 一个糟糕的类型系统会增加语言的复杂性，但并不能防止许多错误。【**一个设计不好的类型系统会增加语言的复杂性和句法上的开销，但并不能真正捕捉到任何问题** A badly designed type system adds complexity and syntactic overhead to the language, but doesn't really catch any problems.】
      * 有些人认为，像Java这样的语言中的类型系统就属于这个类别。然而，**理想的情况是，我们想要的是这样一种语言，它的类型系统足够复杂（强大），能够捕捉到代码中的真正问题，但开销又足够低，人们愿意使用它** Some would suggest that the type system in languages like Java is in this category. Ideally what we want, though, is a language where the type system is sophisticated enough to catch real problems with the code, yet low enough overhead that people are willing to use it. 
* Type-related checks can happen at compile time, at run time, or both **与类型有关的检查可以在编译时发生，也可以在运行时发生，或者同时发生**【类型是程序的一个基本特征。我们习惯于把类型看作是编译时的特征，因为当我们把它们弄错时，编译器就会抱怨。但是类型也存在于运行时，而且某些类型的检查也发生在运行时 Types are a fundamental feature of a program. We’re used to thinking of types as a compile time feature because the compiler complains when we get them wrong. But types exist at runtime too, and certain types of type checking also happen at runtime】
  * e.g., array bounds checks are a property of an array type, checked at run time 例如，数组的边界检查在很大程度上是一个数组类型的属性，但通常是在运行时检查，而不是在编译时 (For example, array bounds checks are very much a property of an array type, but are typically checked at runtime, rather than compile time.)

# 类型系统的类型:Types of Type Systems

![](/static/2022-01-27-20-54-52.png)

不同的语言有不同的类型系统。Different languages have different type systems.

* 有些语言是**强类型**的，并且不提供任何灵活性，不能从类型规则中逃脱。 Some languages are strongly type, and provide no flexibility, no escape from the type rules.
* 在其他语言中，类型检查要弱得多（**弱类型**），而且有可能颠覆这些规则或**在不同类型的数据之间进行转换**。 In others, the type checking is much weaker, and it's possible to subvert the rules or to cast between different types of data. 
* 有些语言**静态**地应用类型，当一个变量被分配到一个特定的类型时，它的类型永远不会改变，它只能持有该类型的变量，持有该类型的值。Some languages apply types statically, and when a variable is assigned a particular type, its type can never change and it can only hold variables of, hold values of, that type.
* 其他语言则更为**动态**，允许变量所能持有的类型在程序的不同阶段发生变化。 Other languages are more dynamic, and allow the types that variables can hold to change at different points in the program. 

<font color="deeppink">这里有不同的权衡因素。没有正确或错误的答案。当我们考虑类型系统时，我们需要考虑，类型规则在多大程度上被严格执行，以及对象在多大程度上可以随着程序的执行而改变其类型</font>There are different trade offs here. There's no right or wrong answer. And when we're thinking about type systems, we need to think about, to what extent the typing rules are strictly enforced, and to what extent objects can change their types as the program’s execution proceeds.

# 静态类型，动态类型：Static and Dynamic Types

**静态类型**

![](/static/2022-01-27-21-18-45.png)

在具有静态类型的语言中，变量的类型是固定的。In a language with static types, the type of a variable is fixed. 

例如，在幻灯片底部的例子中，我们有一个Rust程序，它声明变量x为整数类型，然后试图将浮点数4.2加入其中。由于Rust是一种静态类型的语言，这就失败了，编译器会抱怨说，你不能把浮点数加到一个持有整数类型的值上。这两种类型不匹配。In the example at the bottom of the slide, for example, we have a Rust program which declares the variable x to hold an integer type and then tries to add the floating point number 4.2 to it. And since Rust is a statically typed language, this fails and the compiler complains that you can't add a floating point number to a value which is holding an integer type. The types don’t match.

在这个例子中，有趣的是，我们**从来没有指定变量x持有整数类型**，一些静态类型语言要求明确声明变量的类型。例如，C和C++以及Java就属于这个类别. What's interesting in this example, though, is that we never specified that the variable x holds an integer type Some statically typed languages require that the types of variables are explicitly declared.

* **其他的，比如Rust**，就像我们在幻灯片上看到的例子，可以从**上下文中推断出类型** C and C++ and Java fall into this category, for example. Other, like Rust, and like the example we see on the slide, can infer types from the context.
* 然而，仅仅因为语言<font color="deeppink">可以推断出变量的类型并不意味着类型是动态的。</font>**在rust中，一旦变量x的类型被推断为整数，我们就不能给它添加一个浮点值，尽管我们从来没有明确说过x可以保存整数。这个类型仍然是静态的，它只是为我们省去了指定它是什么的打字工作**。However, just because the language can infer the type of variable doesn't mean that the type is dynamic. With rust, once the type of variable x has been inferred to be an integer we can't add a floating point value to it, even though we never explicitly said that x can hold integers. The type is still static, it just saves us the typing of specifying what it is.

动态类型

![](/static/2022-01-27-21-30-28.png)

这个例子显示了一些Python代码。同样，我们设置了一个**变量x来保存值6。我们检查它的类型，我们看到它的类型是一个整数**。再说一遍，Python推断出的类型与Rust在上一张幻灯片中的推断方式基本相同。然而在这个例子中，当我们把值 4.2 加到它上面时，这是一个浮点值，它成功了。如果我们看一下类型，检查一下x的类型，我们会发现它的**类型已经变成了一个浮点数**

**在Python的动态类型中，将一个整数转换成一个浮点数是安全的，它不会丢失任何信息，所以当我们要求解释器这样做时，转换成功了，变量的类型也改变了** In other languages, the types are much more dynamic. The example show some Python code. And again, we set a variable x the hold the value six. We inspect its type, and we see that its type is an integer. And again, Python has inferred the type in much the same way that Rust did in the previous slide. However in this case, when we add the value 4.2 to it, which is a floating point value, it succeeds. And if we look at the type, we inspect the type of x, we see that its type has changed to that of a floating point number In Python types of dynamic, and it's safe to convert an integer to a floating point value, it doesn't lose any information, so when we ask the interpreter to do so, the conversion succeeds and the type of the variable changes.

## 对比

![](/static/2022-01-27-21-33-43.png)

动态类型的语言和静态类型的语言哪个更好？这在很大程度上取决于你在做什么，而且有不同的权衡。Which is better, a dynamically typed language or statically typed language? Well, it very much depends what you're doing, and there are different trade offs. 

动态类型语言的**性能可能比较低**，但它们提供了更多的**灵活**性。动态类型的语言必须在<font color="deeppink">运行时存储变量的类型和它的值</font>。而这往往会**占用额外的内存**。它还必须在执行各种操作之前**检查变量的类型是否正确**，并且必须在**运行时**执行这些检查。同样，因为类型会随着时间的推移而改变。同样，它可以**根据变量的类型进行较少的优化**，这也是因为类型可以改变。Dynamically typed languages tend to perhaps be lower performance, but they offer more flexibility. A dynamically typed language has to store the type of a variable as well as its value at runtime. And this tends to take up additional memory. It also has to check that the variables are of the correct type before it performs the various operations, and it has to perform those checks at runtime. Again, because the types can change over time. And similarly, it can make fewer optimisations based on the types of the variable, again because the types of can change. 

系统语言倾向于有静态类型，而且它们倾向于**提前编译**，因为它们对性能敏感。如果类型是固定的，并且如果编译器可以查看代码并根据代码做出**优化决策**，并且可以提前这样做，而不用担心快速执行这些优化，那么它通常可以实现**更好的性能**。系统编程语言倾向于**用性能来换取灵活性**，并且有非常静态的类型系统。Systems languages tend to have static types, and they tend to be compiled ahead of time, because they’re performance sensitive. If the types of fixed, and if that the compiler can look at code and make optimisation decisions based on the code, and can do so ahead of time, without worrying about performing those optimisations quickly, it can generally achieve better performance. Systems programming languages tend to trade-off performance for flexibility, and have very static type systems.

# 强类型，弱类型：Strong and Weak Types

![](/static/2022-01-27-22-02-23.png)

在一个具有**强类型**的语言中，每个**操作都必须符合类型系统**。强类型的语言确保**不允许**[那些不能被证明是正确的，不能被证明符合类型规则的]**操作**。In a language with strong types, every operation must conform to the type system. A strongly typed language makes sure that operations which can't be proven to be correct, that can't be proven to conform to the typing rules, are not permitted.

---

更多的**弱类型**语言提供了规避类型检查器的方法。More weakly type languages provide ways of circumventing the type checker.

* 例如，很多语言都允许在**某些类型之间进行安全转换**，安全和自动转换。例如，很多语言允许在浮点和双精度类型之间进行转换，以扩展一个类型的精度，或者从一个整数到一个长整数 而在所有这些情况下，转换是安全的。
* 在其他情况下，语言可以允许更加开放的转换。For example, a lot of languages allow safe conversions, safe and automatic conversions, between certain types. For example, a lot of languages allow conversions between floating point and double precision types, to extend the precision of a type, or from an integer to a long integer And in all these cases the conversion is safe. In other cases, the language can allow more open-ended casts.
  * 幻灯片底部的代码片段显示了C语言中一个常见的习语。变量buffer保存了一个非结构化的字符序列，recv()调用将数据读入该缓冲区。The code fragments at the bottom of the slide shows a common idiom in C. The variable, buffer, holds an unstructured sequence of characters, and the recv() call reads data into that buffer.
  * 一旦读出的数据被成功获取，它就会被**转换为一个不同的类型**，代表缓冲区的**预期内容**。这是**很不安全**的行为。程序员本质上是在告诉编译器 "相信我，我知道我在做什么"。相信这个字节序列实际上是，在这个例子中，一个RTP数据包。Once the read has successfully retrieved that data, it’s cast to a different type representing the expected contents of the buffer. This is very unsafe behaviour. The programmer is essentially telling the compiler “Trust me, I know what I’m doing”. Trust that this sequence of bytes is actually, in this example, an RTP packet.
  * **如果程序员是正确的**，并且这个字节序列确实是一个RTP数据包，这就是**安全和高性能**的。If the programmer is correct, and the sequence of bytes really is an RTP packet, this is safe and high performance.
  * If the programmer is not correct, the data doesn't match its type, and the behaviour is undefined. **如果程序员不正确**，数据就不符合它的类型，**行为也就无法定义**。

一个弱类型的语言提供了这样的逃生口。绕过类型系统的方法。告诉编译器 "相信我，我知道我在做什么 "的方法。**这可以提供很大的权力。这也是非常有风险的，因为如果程序弄错了，程序会不可预测地崩溃**。A weakly type language provides these sort of escape hatches. Ways of circumventing the type system. Ways of telling the compiler “Trust me, I know what I'm doing”. This can provide a lot of power. It's also very risky because if the program and gets it wrong, the program crashes unpredictably

---

# 安全语言 & 不安全语言（强弱类型）：Safe language & unsafe language

**考虑安全 & 不安全语言上下文**

![](/static/2022-01-27-22-13-20.png)

在考虑强类型和弱类型时，在安全和不安全的语言环境中对它们来说非常重要 When thinking about strong and weak types, it’s essentially important to them in the context of safe and unsafe languages.

一个**安全的语言**，**无论其类型是静态的还是动态的，都知道所有变量的类型，并且在任何时候都只允许对这些值进行合法操作**。A safe language, whether the typing is static or dynamic, knows the types of all the variables, and only allows legal operations on those values at any time.

另一方面，**不安全的语言**，除非类型可以被规避。它允许程序员向编译器说明 "相信我，我知道我在做什么"。**它允许程序员执行他们认为是正确的操作，即使类型系统不能证明它们是正确的。它把检查正确性的责任推给了程序员，而不是让类型系统来帮忙**。An unsafe language, on the other hand, unless the types to be circumvented. It allows the programmer to specify to the compiler “Trust me, I know what I'm doing”. It lets the programmer perform operations which they believe to be correct, even though the type system can't prove them to be so. It pushes the burden of checking for correctness onto the programmer, rather than allowing the type system to help.

<font color="deeppink">不安全的语言提供了很多的灵活性。它们允许你做一些在安全语言中无法实现的事情。它们的风险也更大。在不安全的语言中，更容易出错，也更容易使程序崩溃</font>Unsafe languages provide a lot of flexibility. They allow you to do things which are not possible in safe languages. They’re also much riskier. It's much easier to mess up in an unsafe language, and to have the program crash.

# 为什么选择强类型：Why is Strong Typing Desirable?

![](/static/2022-01-27-22-28-12.png)

而这就是为什么强类型是可取的，**一个只使用强类型的程序的结果总是定义得很好**。 And this is why strong typing is desirable, I think. Results for a program that only use strong types are always well defined.

* 该语言总是**安全的**。结果总是与语言的规则一致。 The language is always safe. The results are always consistent with the rules of the language. 
* **一个强类型的程序只执行合法的操作**。它永远不可能执行未定义的行为。A strongly typed program only ever performs operations that are legal. It can never perform undefined behaviour.
* **强类型有助于我们对问题空间进行建模。它帮助我们检查设计和产生的代码是否一致**。Strong typing helps us model the problem space. It helps us check out designs and the resulting code for consistency. 
* **它有助于消除某些类别的错误。也就是说，类型系统不能证明程序是正确的，但它可以证明某些行为不会发生，因为它们对这些类型来说是不合法的**。It helps eliminate certain classes of bugs. That is, the type system can't prove that the program is correct, but it can prove that certain behaviours don't happen because they're not legal for those types. 

另一方面，**弱类型系统不能做出这样的保证**，因为程序员总是有规避类型系统的选择。Weak type system, on the other hand, can't make such guarantees, because the programmer always has the option of circumventing the type system.

# segmentation fault (core dumped)

![](/static/2022-01-27-23-48-11.png)

在编写 c 程序时，我们都看到过这样的消息---- 内存内存区段错误(core dumped)。然而，我认为，分段错误永远不应该发生。We've all seen this message, segmentation fault (core dumped), when writing C programs. I'd argue, though, that segmentation faults should never happen. 

* **编译器和运行时应该能够强制执行类型规则，并确保如果程序违反了这些规则，它将被干净地终止**。The compiler and the runtime should be able to enforce the typing rules, and make sure that if the program violates them, it's terminated cleanly. 
* 当程序没有干净地终止，**并且程序执行一些非法的行为，【访问不属于它的内存】，操作系统就会杀死它，这时就会发生内存区段错误**。A segmentation fault happens when the program is not terminated cleanly, and the program perform some behaviour which is illegal, accesses memory which it doesn't own, and the operating system kills it. 

这是一个有用的安全措施。操作系统能够阻止任性的程序，这一点很重要。**不幸的是，这并不是一个非常精确的安全措施。有很多行为可以访问对象边界之外的内存，但是不会超出操作系统分配的内存边界**。That's a useful safety measure. It's important that the operating system can stop wayward programs. Unfortunately, it's not a very precise safety measure. There are lots of behaviours which access memory outside the bounds of an object, but which don't go outside the bounds of memory allocated by the operating system. 

* 这些给出了**不确定（未定义）的行为**。它们默默地损坏和修改程序状态的其他部分。正是这些类型的不当行为倾向于导致安全漏洞，由于**弱类型系统导致的**不定义行为的结果。These give undefined behaviour. They silently corrupt and modify other parts of the program’s state. It’s these types of types of misbehaviour that tend to lead to security vulnerabilities, as a result of undefined behaviour due to weak type systems.

---


![](/static/2022-01-27-23-53-11.png)

C 编程语言对此尤其不利。标准记录了语言中193种不同的未定义行为。我认为更令人担忧的是，任何这些未定义的行为都可能导致完全不可预测的结果。如果程序遇到未定义的行为，标准说任何事情都可能发生。这并不能保证什么。如果我们试图编写安全、正确和值得信赖的代码，这确实令人担忧。幻灯片上的链接指向了博客文章，指向了一些关于这个的讨论。而且 c 程序可以执行的那些行为真的非常令人担忧。 The C programming language is especially bad for this. The C standard documents 193 different kinds of undefined behaviour in the language. And I think what's more worrying is that any of these undefined behaviours can lead to entirely unpredictable results. If the program hits undefined behaviour, the standard says anything can happen. It doesn't make any guarantees. That's really worrying if we're trying to write secure, correct, and trustworthy code. The link on the slide, to the blog post, points to some discussion of this. And it's really quite alarming the sorts of behaviours that C programs can perform.

# C语言（弱类型）-系统编程：Types for Systems Programming

![](/static/2022-01-27-23-59-26.png)

正如我们所看到的，C语言是一种**弱类型**的语言，但它却被广泛用于**系统编程**。为什么会这样呢，为什么我们要使用一种提供如此少的保证的语言？我们可以用强类型的语言编写系统程序吗？这样做又有什么困难呢？ As we've seen, C is a weakly typed language, yet it's widely used for systems programming. Why is this, why do we use a language which provides so few guarantees? And can we write systems programs in languages which are strongly typed? And what are the difficulties in doing so?

----

原因 Why is C weakly typed?

![](/static/2022-01-28-00-01-56.png)

为什么C语言是弱类型的是一个历史性的意外。Well, I think, the question is why C is weakly typed is a historic accident. 

部分原因是C语言的最初设计者并不是类型理论家。**他们是操作系统设计师，而不是编程语言设计师，编程语言理论家**。Partly is because the original designers of C were not type theorists. They were operating systems designers, rather than programming language designers, programming language theorists. 

部分原因是开发C语言的机器**没有足够的资源来进行复杂的类型检查**。即使设计语言的人是编程语言理论方面的专家，即使我们有复杂的类型系统和执行这种检查的能力，他们运行代码的机器也没有资源来做这些。In part, it's because of the machines and which C was developed didn't have the resources to perform complex type checks. Even if the people designing the language had been experts in programming language theory, and even if we’d had sophisticated type systems and the ability to perform such checks, the machines they were running the code on, didn't have the resources to do that. 

部分原因是在1970年代早期，**当C语言被设计时，类型理论还不是特别先进。我们不知道如何执行今天可能出现的各种检查**。In part because type theory wasn't particularly well advanced in the early 1970s, when C was being designed. We didn't know how to perform the various checks that are possible today.

# 系统编程能用强类型系统吗？：Is Strongly-typed Systems Programming Feasible?

![](/static/2022-01-28-00-08-01.png)
![](/static/2022-01-28-00-08-09.png)

强类型系统编程可行吗？Is strongly typed systems programming feasible? 

**事实上，已经有很多使用强类型语言编写的操作系统的例子**。In fact, there's been many examples of operating systems which are written in strongly typed languages. 

* 例如，Mac 操作系统的原始版本就是用 Pascal 编写的。是80年代的一个研究项目，被称为 Oberon 项目，它使用了一种叫做 Oberon 的语言，是 Pascal 的后代，用来编写操作系统。The original version of the Mac operating system, for example, was written in Pascal. Was a research project in the 80s known as project Oberon, which used a language called Oberon, a descendant of Pascal to write operating systems. 
* 美国国防部为航空航天、军事应用和空中交通管制开发了 Ada 编程语言，这是一种为系统编程而设计的强类型语言。右边的代码片段是 Ada 代码的一个示例。我们看到它非常精确地指定了，各种数值类型的范围。它指定将字段打包到各种控制寄存器中的顺序。它甚至指定了类型的字节顺序。在某些方面，它比 c 提供了更低层次的控制，尽管可能以一种更详细的方式。And the US Department of Defence developed the Ada programming language for aerospace, military applications, and air traffic control, and that's very much a strongly typed language designed for systems programming. The code fragment on the right is a sample of Ada code. And we see that it very precisely specifies the ranges of the various numeric types. It specifies that the order in which fields are packed into the various control registers. It even specifies the byte order of the types. In some ways it provides even more low level control than C does, although perhaps in a much more verbose way. 

多年来，c 和 Unix 的普及使人们相信操作系统需要弱类型的代码。在最低水平上可能也是如此;Over the years the popularity of C and Unix has kind of led to a belief that operating systems require unsafe weakly type code. That may be true at the very lowest levels; 

编程中断寄存器，编程特定的硬件寄存器，但大多数系统代码，包括大多数设备驱动程序，几乎可以用强类型安全语言编写，只需要不安全代码的极小片段。programming interrupt registers, programming particular hardware registers, but most systems code, including most device drivers, can pretty much be written in strongly typed safe languages, with only tiny fragments of unsafe code. 

Rust 编程语言是试图提供一种适用于系统编程的类型安全语言的现代尝试。我希望在这门课程中展示的是，这是非常容易实现的，我们可以使用安全的语言来编写系统程序。The Rust programming language is a modern attempt to try and provide a type safe language which is suitable for systems programming. What I hope to show in this course, is that this is very much achievable, and we can use safe languages to write systems programs.

# ==================

讲座的第二部分介绍了Rust编程语言，作为强类型系统编程语言的一个例子。它回顾了Rust的基本特征和类型。

# Rust

![](/static/2022-01-28-00-18-34.png)

Rust编程语言是一种**现代系统编程语言**。它最初是由Graydon Hoare作为一个副业项目开发的，从2006年开始，开发工作由Mozilla赞助，从2009年开始，已经超过十年。该语言的1.0版本是在2015年进行的。而在2018年12月，一个经过清理但向后兼容的版本，即Rust 2018版，被发布了。从那时起，Rust每六周发布一次新版本，在增加新功能的同时，保持了确保向后兼容的有力政策。 The Rust programming language is a modern systems programming language. It was initially developed by Graydon Hoare as a side project, starting in 2006, and development was sponsored by Mozilla for over ten years starting in 2009. The 1.0 release of the language was made in 2015. And in December 2018, a cleaned-up but backwards compatible version, the Rust 2018 Edition, was released. Since then, Rust has released new versions every six weeks, maintaining a strong policy of ensuring backwards compatibility while adding new features.

# 基本特性&类型：Basic Features and Types

![](/static/2022-01-28-00-20-40.png)

幻灯片上显示的是Rust版本的 "Hello, world!"程序。与其他许多语言一样，执行从主函数开始。**【函数】是用fn关键字定义的，后面是函数名、括号内的参数和任何返回类型**。本例中的main()函数不需要任何参数，也不返回任何东西。接下来是函数的主体，用大括号括起来。在本例中，函数主体包括一个**宏，println!()，在编译时被扩展**。Rust中的【**宏调用总是以感叹号结束，以区别于函数调用**】。Rust中的**宏是C中#定义功能的一个更复杂和类型安全的版本**。 The Rust version of the “Hello, world!” program is shown on the slide. As with many other languages, execution starts with the main function. Functions are defined with the fn keyword, followed by the function name, its arguments within parenthesis, and any return type. The main() function in the example takes no arguments and returns nothing. The body of the function follows, enclosed in braces. In this case, the body comprises a macro, println!(), that’s expanded at compile time. Macro invocations in Rust always end with an exclamation point, to distinguish them from function calls. **Macros in Rust are a more sophisticated, and type safe, version of the # define feature in C.**

---

![](/static/2022-01-28-00-24-24.png)

这张幻灯片显示了一个稍微复杂的例子。第一行是一个**use语句，它导入了一个库模块**。在本例中，提供命令行参数解析的**模块 env 是从标准库中导入的**。This slide shows a slightly more sophisticated example. The first line is a use statement, that imports a library module. In this case, the module env, that provides command line argument parsing, is imported from the standard library.

use 语句将导入的**模块的公共函数、类型和其他定义带入范围**。然后，这些函数可以通过相对于导入路径的名称来引用，就像 Python 中的导入一样。A use statement brings the public functions, types, and other definitions of the imported module into scope. Those functions can then be referenced by name, relative to the imported path, much like imports in Python. 

* 对于例子，这段代码调用了 env::args() 函数。For examples, this code call the env::args() function. 

本例中的main()函数显示了一个运行中的for循环。**env::args()函数返回一个迭代器，逐一返回命令行参数，for 循环消耗该迭代器生成的值，依次执行每个参数的主体**。The main() function in this example shows a for loop in operation. The env::args() function returns an iterator that returns the command line arguments one-by-one, and the for loop consumes the values generated by that iterator, executing the body for each in turn. 

**println!()宏**采用**格式字符串来指定值的打印方式**。这与C语言printf()语句中的格式字符串很相似，只是格式指定符被大括号`{}`包围，而不是在前面加上%符号。The println!() macro takes format strings to specify how values are printed. This works a lot like the format string in a C printf() statement, except that the format specifiers are surrounded by braces rather than preceded by a % sign. 

正如我们从幻灯片的底部看到的，这个程序打印了它的命令行参数As we see from the bottom of the slide, this program prints its command line arguments

---

## 函数调用，返回类型,可变变量，不可变变量

本地变量，类型推断

![](/static/2022-01-28-00-31-00.png)

看看main()函数，我们看到变量被定义在let绑定中，**例如 "let m = 12"。这就定义了一个新的变量m，并将值与该变量绑定。变量的类型是由上下文推断出来的**。

* **如果编译器不能推断出类型**，可以在**变量名后面加一个冒号**，然后在**赋值前指定类型名**。Looking at the main() function, we see that variables are defined in let bindings, such as “let m = 12”. This defines a new variable, m, and binds the value to that variable. The type of the variable is inferred from the context. If the compiler can’t infer the type, it can be specified by following the variable name with a colon, then the type name, before the assignment of the value. 

---

默认情况下，**变量绑定是不可改变的**。也就是说，这个函数中的变量m、n和r的值在被绑定后不能被改变。By default variable bindings are immutable. That is, the value of the variables m, n, and r in this function cannot be changed after they have been bound.

要做一个可变的绑定，也就是一个值可以改变的变量，在let语句后面添加 "mut "限定符。例如，我们可以写 "`let mut m = 12` "来使m成为一个可变变量。To make a mutable binding, that is a variable whose value can change, add the “mut” qualifier following the let statement. For example, one could write “let mut m = 12” to make m a mutable variable. 

---

最后在main()中，我们看到对gcd()函数的调用，以计算m和n的最大公除数。Finally in main(), we see a call to the gcd() function, to calculate the greatest common divisor of m and n. The gcd() function is defined first in the code. 

* 我们看到它需要**两个参数**，m和n。每个参数都是**可变的**，也就是说，它可以在函数的主体中被改变，并且是**u64类型，一个64位无符号整数**。We see that it takes two parameters, m and n. Each of these is mutable, that is, it can be changed within the body of the function, and is of type u64, a 64 bit unsigned integer.
* 该函数的**返回类型也是u64**。The return type of the function is also a u64.
* 你会看到Rust要求明确说明函数参数的类型，**如果函数返回一个值，则返回类型也要明确说明**。 You’ll see that Rust requires the types of the function arguments, and the return type if the function returns a value, to be explicitly stated. 

虽然**编译器通常可以推断出函数参数和返回值的类型，但Rust的设计者决定必须明确说明它们，以避免混淆，并提供文档**。While it would often be possible for the compiler to infer the types of function arguments and return value, the designers of Rust decided they must always be explicitly stated to avoid confusion, and provide documentation. 

在函数体中，我们看到了assert()宏的使用，以及if和while语句。这些都以传统的方式运作。Within the function body, we see use of the assert() macro, and if and while statements. These all function in the conventional way. 

* 在if语句中的let绑定创建了一个局部变量的绑定。The let binding within the if statement creates a local variable binding. 

你可能会注意到这个函数的一个不寻常的特征：没有返回语句。You may notice one unusual feature of the function: there is no return statement. 

**Rust区分了语句和表达式**。Rust distinguishes between statements and expressions. 

* 表达式评估为某个值；而语句则没有值。语句以分号结尾，表达式则没有。Expressions evaluate to some value; statements have no value. Statements end in semicolons, expressions do not. 
* gcd()函数以一个**表达式结束：n** 像所有的表达式一样，它有一个值。而且，由于这个值是函数中的最后一件事，它被返回。这被称为**隐式返回**，是Rust中一个常见的习惯用语。The gcd() function ends with an expression: n. Like all expressions, it has a value. And, since this value is the last thing in the function, it is returned. This is known as an implicit return, and is a common idiom in Rust.

像其他语言一样，以返回语句的形式明确返回也是可能的。拷贝一下幻灯片上的代码。将gcd()函数末尾的**表达式**，**即只有n的那一行，通过在末尾添加分号变成一个语句，并将结果编译出来。确保你理解所产生的错误信息，以及它发生的原因**。An explicit return, in the form of a return statement, like in other languages, is also possible. Take a copy of the code on the slide. Change the expression at the end of the gcd() function, the line with just n on its own, into a statement by adding a semicolon to the end, and compile the result. Make sure you understand the error message that results, and why it occurs.

## 基本类型：primitive types

我们已经看到了Rust中的一些可用的原始类型。可用的类型与C语言中的类型非常相似，尽管类型名称不同。该表显示了两者的对应关系。除了名称之外，还有两个主要区别。We’ve seen some of the primitive types available in Rust already. The available types are very similar to those available in C, although the type names are different. The table shows the correspondence. Aside from the names, there are two major differences. 

![](/static/2022-01-28-01-00-24.png)

* 首先是Rust有一个本地的bool类型，用来保存布尔值，即真或假。C语言没有布尔类型，而是用整数来表示布尔值，零值代表假，非零代表真。The first is that Rust has a native bool type to hold a boolean value, true or false. C does not have a boolean type, and uses integers to represent booleans, with a zero value representing false, and non-zero representing true. 
* 第二个是字符类型。
  * 在 c 中，char 的大小定义为一个字节。**该字节中的位数以及它是有符号的还是无符号的都依赖于实现，并且没有指定字符集**。这使得用 c 语言编写**可移植的文本处理代码**变得困难。The second is the character type. In C, a char is defined to be one byte in size. The number of bits in that byte, and whether it is signed or unsigned are implementation dependent, and the character set is not specified. This makes it difficult to write portable text handling code in C. 
  * 另一方面，Rust 将 char 定义为32位 **Unicode 标量值**。这在字符的大小和所使用的字符集方面是完全明确的。这使得在 Rust 中编写可移植的、国际化的文本处理代码变得更加容易。Rust, on the other hand, defines a char to be a 32-bit Unicode scalar value. This is entirely unambiguous in terms of both the size of the character, and the character set used. This makes it much easier to write portable, and internationalised, text handling code in Rust. 
    * 不过请注意，**虽然 Rust 在这里比 c 好，但 Unicode 仍然非常复杂。特别是，在处理文本时，常常需要区分标量值的 Unicode 概念(如 Rust 中使用的)、代码点、字符集和字符** Note, though, that while Rust is better than C here, Unicode is still very complicated. In particular, when dealing with text, it’s often necessary to distinguish between the Unicode concepts of scalar values, as used in Rust; code points; grapheme clusters; and characters. 

Rust **对其 char 类型使用标量值是有意义的，因为这些是 Unicode 的基本组件**。但是，许多人们认为是**字符的东西，包括表情符号，实际上是 [Unicode 字符集，表示为标量值序列，不能被编码为单个字符]。如果你想一个字符一个字符地处理文本，你可能需要使用库，比如幻灯片中提到的 Unicode 分割库，它让你[使用字符集群，而不是直接使用字符值]**。It makes sense for Rust to use scalar values for its char type, since these are the basic component of Unicode. But, many things that people recognise as characters, including emoji, are actually **Unicode grapheme clusters**, represented as sequences of scalar values, and cannot be encoded as a single char. If you want to process text character by character, you probably want to use libraries, such as the Unicode segmentation library mentioned on the slide, that let you work with grapheme clusters, rather than using char values directly.

* https://doc.rust-lang.org/book/ch03-02-data-types.html

# 数组：Arrays

![](/static/2022-01-28-01-12-49.png)

除了原始类型外，Rust还支持常见的复合数据类型集。数组的工作方式和你所期望的一样。它们持有**固定数量的元素，都是相同的类型**。**边界在运行时被检查**。 In addition to the primitive types, Rust supports the usual set of compound data types. Arrays work as you might expect. They hold a fixed number of elements, all of the same type. Array bounds are checked at run time.

## 可变数组：Vectors

(Vec<T> implements the trait Deref<Target=&[T]> that defines the conversion)

![](/static/2022-01-28-01-17-48.png)

在你需要一个可变长度的列表的情况下，Rust提供了一个Vector，即Vec，作为标准库的一部分。In cases where you need a variable length list, Rust provides a Vector, Vec, type as part of the standard library.

Vec类型遵循一种常见的模式，暴露了一个`new()`方法，可以创建一个该类型的新实例，正如我们在幻灯片顶部的例子中看到的那样。这里值得注意的是，**Vec需要一个类型参数T，表示它要容纳的元素的类型**。The Vec types follows a common pattern, exposing a new() method that creates a new instance of that type, as we see in the example at the top of the slide. What’s notable here is that Vec takes a eter, T, that indicates the type of elements it will hold.

* **在创建一个空向量时，必须指定这个参数**。This parameter has to be specified when creating an empty vector.
* 我们看到有两种方法可以做到这一点。We see two ways of doing this.
  * 第一种是**调用`Vec::new()`而不指定类型参数，而是将其赋值给一个指定了类型的变量**。这里的例子指定了变量v的类型为Vec，新的向量被赋值给它。The first is to call Vec::new() without specifying the eter, but to assign to a variable where the type is specified. The example here specifies that the variable, v, has type Vec, and the new vector is assigned to that.
    * `let mut v : Vec<u32> = Vec::new(); `
  * 第二种方法是在**创建向量时显式包含类型参数，调用`Vec::::new（）`**。The second way is to explicitly include the eter when creating the vector, calling Vec::::new().
    * `let mut v = Vec::<u32>::new();`

还有一个方便的宏，我们在左下角看到，**它可以从一个数组字面创建一个向量**。在内部，向量的实现相当于一个C程序，它使用malloc()为数组分配空间，然后在空间变满时使用realloc()来增加空间。因此，<font color="deeppink">从一个向量到一个数组的转换是非常快的。向量类型实现了Deref特性，提供了对数组的这种转换，允许向量被传递给期望数组类型的函数</font>。There’s also a convenience macro, that we see at the bottom left, that creates a vector from an array literal. Internally, vectors are implemented as the equivalent of a C program that uses malloc() to allocate space for an array, then realloc() to grow the space when it becomes full. As a consequence of this. conversion from a vector to an array is extremely fast. The vector type implements the Deref trait that provides such a conversion to arrays, allowing vectors to be passed to functions that expect array types.

# tuples

![](/static/2022-01-28-01-45-05.png)

Rust支持图元，图元是未命名的值的集合，每个元素可以是不同的类型。Rust supports tuples, that are collections of unnamed values where each element can be a different type. 

* 在这个例子中，变量tup的第一个和最后一个元素是整数值，而中间的元素是一个浮点值。In this example, the first and last elements of the variable tup are integer values, while the middle element is a floating point value. 
* 元组的元素可以通过索引访问，从零开始，使用点符号。Elements of a tuple can be accessed by index, starting at zero, using dot notation. 
* 元组也可以用let绑定的方式进行去结构化，正如我们在幻灯片上的函数的第二行所看到的，其中变量x、y和z被设置为元组的元素。这种行为与Python的行为类似。Tuples can also be de-structured in a let binding, as we see in the second line of the function on the slide, where the variables x, y, and z are set to the elements of the tuple. This behaviour is similar to that of Python. 
* Rust也允许空元组值，正如我们在幻灯片的底部看到的那样。这些表示没有一个值，很像C语言中的void类型。Rust also permits empty tuple values, as we see at the bottom of the slide. These represent the absence of a value, much like the void type in C.

# structs

![](/static/2022-01-28-01-48-08.png)

Rust还支持结构类型，即**命名值的集合，其中每个元素可以有不同的类型**。像其他语言一样，结构中的元素可以使用点符号来访问。正如我们在main()函数中看到的那样，结构的实例是通过指定结构的名称，然后在大括号中指定其字段的值来创建的。 Rust also supports structure types, that are collections of named values, where each element can have a different type. Elements of a struct are accessed using dot notation, as in other languages. Instances of structs are created as we see in the main() function, by specifying the name of the struct, followed by the values for its fields in braces.

---

tuple structs

![](/static/2022-01-28-01-51-01.png)

我们也可以指定带有未命名字段的结构。这些结构被称为元组结构体。It’s also possible to specify structs with unnamed fields. These are known as tuple structs. 

* 元组结构体的值的访问方式与元组的值相同，元组结构的实例是通过指定结构体名称和括号中的字段值来创建的。 Values of a tuple struct can be accessed in the same way as values of a tuple, and instances of a tuple struct are created by specifying the struct name followed by the values of its fields in parenthesis. 
* 元组结构体可以作为类型别名来使用。 Tuple structs can be useful as type aliases. 

也可以定义一个**没有元素的结构**。这些结构被称为**类单元结构**。A struct can also be defined that has no elements. These are known as unit-like structs. 

* 由于没有内容，类单元结构不占用空间。它们可以作为**标记类型或类型参数**使用。Since they has no content, unit-like structs takes up no space. They’re useful as marker types or eters. We’ll discuss uses of tuple structs and unit-like structs more in lecture 4.

## 结构体方法 method on structs

![](/static/2022-01-28-01-56-10.png)

我们可以在一个结构体上实现方法。 Finally, it’s possible to implement methods on a struct. 

* 可以通过写一个**impl块**来实现，指定要实现的结构。 This is done by writing an impl block, specifying the struct to be implemented, as we see on the slide. 
* 方法定义将**self作为参数，代表它们所实现的结构体**。Method definitions take self as a parameter, representing the struct on which they are implemented. 
* 对该结构的字段的访问是通过显式的self引用，就像在Python中一样。 Access to fields of that struct is via explicit self references, like in Python. 
* **方法的调用是使用点符号**，以通常的方式进行。Methods are called using the dot notation, in the usual way. 

**实现方法的结构体**看起来很像 Java 或 Python 中的对象。但它的不同之处在于，**Rust不支持继承或子类**。相反，它使用一种被称为**traits的功能**，我们将在下一部分讨论。A struct that implements methods looks a lot like an object in Java or Python. It’s different, though, in that Rust does not support inheritance or subclassing. Instead, it uses a feature known as traits, that we’ll talk about in the next part.

# traits

特质是Rust引入**抽象化**的主要方式之一。它们**允许你定义一组可以在一个类型上执行的操作**，并编写可以与任何实现这些操作的类型一起工作的代码。Traits are one of the primary ways in which Rust introduces abstraction. They allow you to define a set of operations that can be performed on a type, and to write code that works with any type that implements those operations. 

![](/static/2022-01-28-14-32-32.png)

- trait描述了类型可以实现的功能 	Traits describe functionality that types can implement
- 实现trait的类型必须提供的方法，指定的相关类型，但没有实例变量或数据。Methods that must be provided, and associated types that must be specified, by types that implement the trait – but no instance variables or data
- 类似于Haskell中的类型类或**Java中的接口** Similar to type classes in Haskell or interfaces in Java

---

特质定义了一组方法和类型。这些方法和类型必须由实现该特质的任何类型来实现。A trait defines a set of methods and types. Those methods and types must be implemented by any type that implements that trait. 

* 例如，在幻灯片上的代码示例中，我们看到trait Area的定义。这个特质包括一个方法的签名，即 area()，该方法将 self 作为参数，并返回一个 u32 类型的值。该方法的主体没有被指定。In the code sample on the slide, for example, we see the definition of trait Area. This trait includes the signature of a single method, area(), that takes self as a parameter and return a value of type u32. The body of the method is not specified.
* 然后，代码中定义了一个结构体，即具有宽度和高度的矩形，然后为该结构体实现了 Area 特质。The code then defines a struct, Rectangle, with width and height, then implements the trait Area for that struct.
* 语法 "impl Area for Rectangle "指定了Rectangle结构具有Area特质的实现，impl块的主体包含了 area() 方法的定义，与特质定义中给出的方法的签名相匹配。The syntax “impl Area for Rectangle” specifies that the Rectangle struct has an implementation of the Area trait, and the body of the impl block contains a definition of the area() method, matching the signature of the method given in the trait definition.

**特质定义通常只包括方法签名，如图所示，但也可能包括完整的方法实现**。在**特质定义中指定了完整实现的方法不需要写在impl块中，但是impl块需要出现以表明该类型实现了特质**。Trait definitions usually just include method signatures, as shown here, but they may also include complete method implementations. Methods that have their complete implementation specified in the trait definition do not need to be written in the impl block, but the impl block needs to be present to indicate that the type implements the trait.

特质定义了功能。特质定义不能包含实例变量或数据；它们只是指定方法。在这个层面上，traits的行为类似于Java中的接口，或者Haskell中的类型类。Traits define functionality. Trait definitions cannot contain instance variables or data; they just specify methods. At this level, traits behave like interfaces in Java, or type classes in Haskell.

## trait-多类型

特质是抽象化的重要工具--与许多语言中的子类型作用类似 Traits are an important tool for abstraction – similar role to subtypes in many languages

![](/static/2022-01-28-14-39-59.png)

一个特质可以由多种类型来实现。在这个例子中，我们展示了如何定义一个结构体Circle，并为该类型实现面积特性。**Rectangle和Circle都实现了Area特性，因此包括一个具有相同签名的 area() 方法**。不过这两个方法的主体是不同的。特质是抽象的一个重要工具。它们允许你描述可以由不同类型实现的通用功能集。 A trait can be implemented by multiple types. In this example, we show how we can also define a struct Circle, and implement the Area trait for that type too. Both Rectangle and Circle implement the Area trait, and so include an area() method with the same signature. The body of the two methods differs, though. Traits are an important tool for abstraction. They allow you to describe common sets of functionality that can be implemented by different types.

# trait-通用函数（模拟类继承通用函数）

- Rust使用特质而不是类和继承来定义通用函数或方法，这些函数或方法适用于实现特定特质的任何类型。Rust uses traits instead of classes and inheritance to define generic functions or methods that work with any type that implements a particular trait
  - Rust不是一种面向对象的语言，你不能继承某个类型，也不能编写与某个特定类型的子类一起工作的代码。但你可以做的是，写代码与任何实现了特定特质的类型一起工作。Rust is not an object oriented language, and you cannot inherit from a type, or write code that works with subclasses of a particular type. What you can do, though, is write code that works with any type that implements a particular trait.

![](/static/2022-01-28-14-47-35.png)

幻灯片显示了一个特质的定义，即Summary，其中包括一个方法，即summary()。接下来是一个函数的定义，notify()。notify()函数接收一个参数，**即T类型的item。这个类型，T，是一个类型参数**。The slide shows the definition of a trait, Summary, that include a single method, summarise(). This is followed by definition of a function, notify(). The notify() function takes a single parameter, item, of type T. The type, T, is a eter. 

* **类型参数**被定义在角括号中，位于函数名称的后面和参数的前面。这里的定义表明，T具有类型Summary。也就是说，T是任何实现了Summary特性的类型。因为关于T的所有信息都是它实现了Summary特性，所以对类型为T的变量item的唯一合法操作是那些定义在该特性上的操作。Type parameters are defined in angle brackets, after a function’s name and before its arguments. The definition here indicates that T has type Summary. That is, T is any type that implements the Summary trait. Since all that is known about T is that it implements the Summary trait, the only legal operations on the variable, item, with type T, are those defined on that trait. 

正如我们在println!()宏中所看到的，我们可以调用item的summaryise()方法，但我们不能执行其他操作。**这种方法让我们可以编写通用代码。函数notify()不知道也不关心T的实际类型是什么，也不关心它是否实现了其他的特质、方法或实例变量，只要它实现了Summary特质**。As we see in the println!() macro, we can call the summarise() method on item, but we can perform no other operations. This approach lets us write generic code. The function, notify(), doesn’t know or care what is the actual type of T, and whether it implements other traits, methods, or instance variables, provided it implements the Summary trait.

# 共同traits：Deriving Common Traits

![](/static/2022-01-28-16-38-03.png)

一些特质得到了非常广泛的实现。例如，标准库包括Debug特性，它可以格式化一个值以便由调试器打印。**所有的原始类型和标准库中的大多数其他类型都实现了这个Debug特性**。A number of traits are very widely implemented. For example, the standard library includes the Debug trait that formats a value for printing by a debugger. This is implemented by all the primitive types, and by most other types in the standard library. 

* Rust编译器理解一个注解，即derive，如幻灯片上的代码样本所写。The Rust compiler understands an annotation, derive, written as shown in the code sample on the slide. 
* derive注解可以被添加到结构定义中，并告诉编译器为派生类型生成一个标准的实现(给这个结构体)。例如，通过在矩形结构上写# [derive(Debug)]，如图所示，我们告诉编译器自动生成一个 "impl Debug for Rectangle "块。The derive annotation can be added to a struct definition, and tells the compiler to generate a standard implementation for the derived type. For example, by writing # [derive(Debug)] on struct Rectangle, as shown, we tell the compiler to auto-generate an "impl Debug for Rectangle" block. 

这是有可能的，**因为每个Debug特性的实现都是以完全相同的方式进行的**。impl块的代码可以以完全机械的方式生成，并且总是具有相同的结构。 This is possible, because every implementation of the Debug trait proceeds in exactly the same way. The code for the impl block can be generated in an entirely mechanical way, and always has the same structure. 

* 幻灯片上的第一个链接指向可派生trait的列表。The first link on the slide points to the list of derivable traits. 
  * https://doc.rust-lang.org/book/appendix-03-derivable-traits.html
* 第二个链接指向关于如何为你可能定义的trait实现自动衍生的描述。The second points to a description of how to implement auto-derivation for a trait you might define. 
  * https://doc.rust-lang.org/book/ch19-06-macros.html#how-to-write-a-custom-derive-macro
* **虽然有可能，但为你定义的类型实现自动衍生是非常罕见的**。While possible, it’s extremely rare to implement auto-derivation for types you define. 

不过，使用# [derive(Debug)] 注解是非常普遍的。Using the # [derive(Debug)] annotation, though, is extremely common.

* 这可以用来派生标准的trait，比如Debug，这样对象就可以被调试器打印出来；通过派生Eq trait的实现来实现结构体的等值检测；通过派生Copy trait来允许对象的复制，等等。This can be used to derive standard traits such as Debug so the object can be printed by a debugger; to implement equality tests for structures, by deriving an implementation of the Eq trait; and to allow copies to be made of objects by deriving the Copy trait, and so on.

# 关联types-traits：Associated Types

![](/static/2022-01-28-16-54-58.png)

最后，特质可以包括相关类型的定义。也就是说，可以指定在实现该trait时必须指定某些类型。Finally, traits can include definitions of associated types. That is, that can specify that certain types must be specified when the trait is implemented.

* `type xxx;`
* 例如，Rust中的for循环对迭代器进行操作，其中迭代器被定义为实现了Iterator trait的东西。For example, for loops in Rust operate on iterators, where an iterator is defined to be something that implements the Iterator trait.
  * 迭代器trait定义了一个方法和一个相关的类型。该方法被称为**next()。它返回由迭代器产生的序列中的下一个元素，或者一个没有更多元素的指示。这是一个枚举类型的实例`Option`**，Option。The Iterator trait defines a method and an associated type. The method is called next(). It returns the next element in the sequence produced by the iterator, or an indication that there are no more elements. This is an instance of an enum type, Option, that we’ll discuss in a minute.
  * **`Option`包括一个类型参数，`Self::Item`**。它引用了trait定义中的另一个元素，一个叫做 Item 的类型。Item的类型是什么？特质定义并没有说明。它指出该特质的所有实现都需要定义Item类型，但除此之外没有对它的类型进行限制。The Option includes a eter, Self::Item. This references the other element of the trait definition, a type called Item. What is the Item type? The trait definition doesn’t specify. It indicates that all implementations of the trait need to define the Item type, but otherwise puts no constraint on what it may be. 
* **每个迭代器trait的实现都必须包括一行，type Item = something，来指定该类型，并且必须定义next()函数来返回该类型的Optional值**。Every Implementation of the Iterator trait must include a line, type Item = something, to specify that type, and must define the next() function to return an Optional value of that type.

该trait是通用的，可应用任何可能的类型。trait允许你编写对许多不同类型进行操作的代码，通过抽象出需要对这些类型进行的操作。The trait is generic, over any possible type. Traits allow you to write code that operates on many different types, by abstracting away the operations that need to be performed on those types.

# 枚举：Enumerated types

枚举类型，即枚举，允许你编写代码，可以访问可能是几种不同类型的数据的值。。Enumerated types, enums, allow you to write code that can access the value of data that may be of several different types. In the simplest case, enums work the same way they do in C or Java. They specify a set of named values that an item may take.

![](/static/2022-01-28-17-17-28.png)

**在最简单的情况下，枚举的工作方式与C或Java中的相同。它们指定了一个项目可能采取的一组命名值**

不过Rust也允许两种更普遍的枚举形式。第**一种是可以容纳未命名的数据项的枚举**，就像一个可以采取几种不同变体的元组结构。在这个例子中，RoughTime枚举可以持有表示JustNow、InThePast或InTheFuture的值。如果该值是在过去或未来，该枚举还持有一个时间单位和一个计数。例如，代码片段中的变量 "when "表示4分7年前发生的事情。**枚举的InThePast变体需要两个未命名的参数，一个时间单位和一个数字，四分之七**。 Rust also allows two more general forms of enum, though. The first is an enum that can hold unnamed data items, like a tuple struct that can take several different variants. In this example, the RoughTime enum can hold values indicating JustNow, InThePast, or InTheFuture. If the value is in the past or future, the enum also holds a time unit and a count. For example, the variable “when” in the code fragment indicates something that happened four score and seven years ago. The InThePast variant of the enum takes two unnamed parameters, a TimeUnit and a number, four score and seven.

**枚举也可以保存命名的数据**，就像一个结构，可以采取几个不同的变体。在这个例子中，枚举Shape可以是一个有中心和半径的球体(变体1)，也可以是一个由两个角的位置指定的立方体（变体2）。 An enum can also hold named data, acting like a struct that can take several different variants. In this example, the enum Shape, can be either a Sphere, with a centre and a radius, or a Cuboid specified by the locations of two corners.

---

## 枚举类型参数：eters

![](/static/2022-01-28-17-24-55.png)

当一个变量、参数或结果可以有几种可能的类型时，就会使用枚举。枚举定义了一个类型可能的替代类型的集合，并被用来模拟可以取一组相关值中的一个的数据。An enum is used when a variable, parameter, or result can have on of several possible types. Enums define the set of possible alternative types for a type, and are used to model data that can take one of a set of related values. 

**像结构体一样，枚举可以有类型参数**，必须在实例化枚举时指定。例如，Rust标准库定义了一个Result枚举，它需要两个类型参数，T和E，结果枚举有两个变体。Ok(T)变体用来表示一个成功的结果，包裹着一个T类型的值。Err(E)变体用于表示一个错误，包裹一个E类型的结果。 **Enum也可以有impl块，定义可以在枚举上调用的方法，它们本身也可以实现traits**。Like structs, enums can have eters that must be specified when the enum is instantiated. For example, the Rust standard library defines an enum Result, that takes two eters, T and E. There are two variants to the Result enum. The Ok(T) variant is used to indicate a successful result, wrapping a value of type T. The Err(E) variant is used to indicate an error, wrapping a result of type E. Enums can also have impl blocks that define methods that can be invoked on the enum, and they can themselves implement traits.

# 标准枚举-Option, Result

Rust标准库定义了两个非常有用的标准枚举类型。The Rust standard library defines two extremely useful standard enum types. 

![](/static/2022-01-28-18-00-43.png)

一个是我们之前看到的Result类型，它是由**可能成功或失败的函数**返回的。例如，在幻灯片的底部，**我们看到recv()函数的定义，它返回的结果可以是Ok，包裹一个Message类型的值，也可以是Err变体，包裹一个NetworkError对象**。One is the Result type, that we saw previously, that’s returned by functions that may either succeed or fail. For example, at the bottom of the slide we see the definition of a recv() function, that returns a Result that can be either Ok, wrapping a value of type Message, or an Err variant that wraps a NetworkError object. 

---

另一个是Option类型。这代表一个可能不存在的值。The other is the Option type. This represents a value that might not exist.

* 例如，在一个C语言程序中，我们可以写一个函数来查询数据库中的一个键。这个函数可能需要一个指向代表数据库的结构的指针，以及一个指向要查找的键的指针。In a C program, for example, one might write a function to lookup a key in a database. This function might take a pointer to the struct representing the database, and a pointer to the key to be found. 
* 如果在数据库中找到了键，这个函数将返回一个指向相应值的指针，如果键不存在，它将返回null。If the key is found in the database, such a function will return a pointer to the corresponding value, or it will return null if they key doesn’t exist. 
* 一个Java程序将是类似的，只是lookup()将是数据库对象的一个方法，并将返回一个持有该值的对象的引用，或者是null。A Java program would be similar, except that lookup() would be a method on the database object, and would return a reference to an object holding the value, or null. 
* 在Rust中，相应的函数将返回一个Option类型的实例。In Rust, the equivalent function would return an instance of the Option type. 
* Option是一个枚举，它需要一个类型参数T，并且有两种可能的变体。Some(T)表示该项目存在，None表示不存在。因此Rust函数将返回一个Option，其变体表示结果是否存在。Option is an enum, that takes a eter T, and has two possible variants. Some(T) indicates that the item is present, and None indicates that it is not. The Rust function would therefore return an Option, with the variant indicating whether the result exists or not. 

这看起来是一个微小的语法差异，但正如我们在后面的讲座中所看到的，它让Rust编译器更有效地检查错误。This looks like a minor syntactic difference, but as we’ll see later in the lecture, it lets the Rust compiler check for errors much more effectively.

# 模式匹配：pattern Matching

![](/static/2022-01-28-18-08-27.png)

在这部分讲座中，我想讨论的最后一个Rust特性是模式匹配。模式匹配引入了匹配语句。这是对C和Java等语言中switch语句的一种概括。The final Rust feature I want to discuss in this part of the lecture is pattern matching. Pattern matching introduces the match statement. This is a generalisation of the switch statement in languages like C and Java. 

* 在最简单的情况下，和C语言一样，匹配语句可以匹配一个整数值。在这个例子中，count_rabbits()方法在草地对象上被调用，而匹配语句对结果进行操作。In the simplest case, much like in C, a match statement can match on an integer value. In this example, the count_rabbits() method is called on the meadow object, and the match statement operates on the result. 
  * 如果没有兔子，就不打印任何东西。If there are no rabbits, nothing is printed. 
  * 如果有一只兔子，则打印出一只兔子在周围嗅嗅。If there is one rabbit, it prints that a rabbit is nosing around. 
  * 如果有几只兔子，就打印出有多少只兔子在跳动。And if there are several rabbits, it prints to say how many rabbits are hopping about. 
* 最后一个变体显示了Rust的匹配语句与C的switch语句相比的第一个扩展。**匹配语句可以包括一个变量，如果其他变体都不匹配的话，这个变量就会被绑定，当switch语句的那个分支被执行时，就可以使用这个变量**。The last variant shows the first extension of the Rust match statement compared to the C switch statement. A match can include a variable that’s bound if none of the other variants match, and that variable can be used when that branch of the switch statement is executed. 
* **可以使用下划线来指定一个不与值绑定的通配符作为匹配的数值**。A wildcard that doesn’t bind to a value can be specified using an underscore as the value to match. 

Rust中的匹配语句是详尽的。也就是说，<font color="deeppink">**每个可能的值都必须匹配，或者必须有通配符或变量匹配。如果某些值没有被匹配到，那就是一个编译时错误**</font>。Match statements in Rust are exhaustive. That is, every possible value must match, or there must be a wildcard or variable match. It’s a compile time error if some values are not covered by the match.

---

![](/static/2022-01-28-18-37-02.png)

Rust还对匹配语句进行了概括，**允许对其他类型进行匹配，而不仅仅是整数**。幻灯片显示了一个针对字符串值的匹配，例如，评估为枚举变体。**Rust中的`match`语句有一个等于所选分支的值。这意味着可以使用匹配语句为let绑定中的变量赋值**，如幻灯片中所示。**`match`语句的所有变体都必须评估为相同类型的值，或者评估为nothing**。
 Rust also generalises the match statement to allow matching on other types, not just integers. The slide shows a match against string values, for example, that evaluate to an enum variant. A match statement in Rust has a value that’s equal to that of the chosen branch. This means it’s possible to use a match statement to assign a value to a variable in a let binding, as shown in the slide. All variants of a match statement must evaluate to give values of the same type, or to nothing.

---

匹配枚举

Rust中的匹配语句也可以与枚举变体匹配。

![](/static/2022-01-28-18-41-24.png)

在这张幻灯片中，我们有一个与之前使用的RoughTime相同的例子，**其中的`match`语句可以检查枚举的变体，并在每种情况下产生不同的值**。这允许编写的代码可以处理那些可以是几个不同变体之一，几个不同类型之一的数据。**由于匹配是详尽的，编译器将保证所有代码处理所有可能的变体** Match statements in Rust can also match against enum variants. On this slide we have the same RoughTime example as used before, with a match statement that checks which variant of the enum is present, and produces a different value in each case. This allows code to be written that can deal with data that can be one of several different variants, one of several different types. Since matches are exhaustive, the compiler will guarantee that all code handles all possible variants.

# 利用模式匹配避免空指针

![](/static/2022-01-28-18-48-57.png)

模式匹配对于编写处理可选值和可能失败的结果的代码非常有用。 This is extremely useful for writing code that handles optional values and results that may fail. 

例如，在C语言中，我们可以写一个函数，在数据库中查找一个用户，然后为该用户预订一张票。get_user()函数成功时返回一个指向客户记录的指针，失败时返回空值。写代码很容易，如幻灯片所示，假设get_user()函数成功并一直试图预订机票，导致book_ticket()函数在传递空指针时崩溃。**C语言在编译时无法捕捉到这个错误**。For example, in C one might write a function that looks up a user in a database then books a ticket for that user. The get_user() function returns a pointer to the customer record on success, or null on failure. It’s easy to write code, as shown on the slide, that assumes the get_user() function succeeds and always tried to book the ticket, causing the book_ticket() function to crash when passed a null pointer. C cannot catch the bug at compile time. 

不过在Rust中，**get_user()函数将返回Option枚举的一个实例，代码最终将不得不对其进行模式匹配以获得结果**。In Rust, though, the get_user() function will return an instance of the Option enum, and the code will eventually have to pattern match against this to get at the result. 

**模式匹配必须是详尽的，这意味着除非同时处理Option类型的Some()和None变体，否则代码是不会被编译的**。对于get_user()函数失败的情况，**Rust编译器不能让你写出有意义的错误处理，但它确实迫使你以某种方式检查和处理错误，如果你忘记了错误处理，代码就不会被编译。因此，【Rust把运行时的故障变成了编译时的检查**】。The pattern match must be exhaustive, which means that the code won’t compile unless both the Some() and None variants of the Option type are handled. The Rust compiler can’t make you write meaningful error handling, for cases where the get_user() function fails, but it does force you to check for and handle the error somehow, and the code won’t compile if you forget the error handling. Rust therefore turns a runtime failure into a compile time check.

# ==================

讲座的第四部分结束了对Rust编程语言的介绍。它讨论了Rust如何支持引用，以及它对引用的使用有哪些限制；内存分配和装箱是如何工作的；以及所提供的各种字符串类型。最后，它谈到了Rust作为一种系统语言的有趣之处，以及其设计的新颖之处 The 4th part of the lecture concludes this introduction to the Rust programming language. It discusses how Rust supports references, and what constraints it imposes on their use; how memory allocation and boxing work; and the various string types provided. Finally, it talks about what makes Rust interesting as a systems language, and what is novel about its design.

# Rust引用：References

![](/static/2022-01-28-23-39-36.png)

乍一看，Rust中的内存管理和C语言中的内存管理有点像。同样地，解除对指针的引用以访问被引用的对象也是明确的。At first glance, memory management in Rust looks a little like it does in C. Like in C, the act of taking a reference to a pointer to an object is explicit. And, similarly, so is dereferencing a pointer to access the referenced object. 

* 幻灯片显示了创建一个变量绑定：let x = 10。它还演示了如何**获取对该绑定的引用：`let r = &x`**。The slide shows has creates a variable binding: let x = 10. And it demonstrates how to take a reference to that binding: let r = &x. 
* 在这两种情况下，我们看到Rust推断出了x和r的类型，而在右边所示的同等C语言代码中，我们必须明确地写出类型。术语也是不同的，Rust使用的是引用，而C则称它为指针。但除此之外，代码都是一样的。In both cases, we see that Rust infers the types of x and r. Whereas, in the equivalent C code, shown on the right, we have to explicitly write the type. And the terminology is different reversed, with Rust using the term reference, whereas C calls it a pointer. But otherwise the code is the same. 
* 解除引用的情况也是如此，我们写让`s = *r`。用于解除引用指针的*操作符在两种语言中都是一样的。The same is true for dereferencing, where we wriite let s = *r. The * operator used to dereference pointers is the same in both languages. 

**函数可以通过引用获取其参数**。Functions can take their parameters by reference. 

* 例如，幻灯片上显示的calculate_length()函数是通过对一个缓冲区的引用而不是通过缓冲区本身。For example, the calculate_length() function shown on the slide is passed a reference to a buffer rather than on passing the buffer itself. 
* 这与同等的C语言代码的行为是一样的，即传递一个指向缓冲区的指针。This behaves the same as the equivalent C code, that passes a pointer to the buffer. 
* Rust在这里比C语言更加一致。它使用&语法来获取一个引用，并传递一个引用来评估。而C使用&语法来获取一个引用，但使用*语法来传递一个引用。在所有这些情况下，编译器为Rust和C程序生成的代码完全相同。Rust is a little more consistent than C here. It uses the & syntax to both take a reference, and to pass a reference to evaluate. While C uses the & syntax to take a reference, but the * syntax to pass a reference. The compiler generates the exact same code for the Rust and C programs in all of these cases.

---

可变 & 不可变引用

![](/static/2022-01-29-17-41-57.png)

Rust的一个不寻常的特点是，它区分了两种不同类型的引用：不可变的引用和可变的引用。不可变的引用是用&写的，如图所示的代码片段：`let r = &x`。**一个不可变的引用是对一个对象的引用，它不能改变**。这个代码片段，即对一个变量的不可变的引用，然后试图改变引用的值，是不会被编译的。编译器注意到该引用是不可变的，并抛出一个错误，表明它不能分配给引用的值。One of the unusual features of Rust is that it distinguishes two different types of reference: immutable references and mutable references. And immutable reference is written using an ampersand, as in the code fragment shown: let r = &x. An immutable reference is a reference to an object that cannot change. The code fragment, which takes an immutable reference to a variable then tries to change the referenced value won't compile. The compiler notices is that the reference is immutable and throws an error, indicating that it cannot assign to the referenced value. 

但有时，你需要可变的引用。一个可以让你改变被引用数据的引用。Rust允许这样做。**可变引用是用&mut语法写的**，正如我们在第二个代码片段中看到的那样。它们**允许引用的值发生变化**。如果你编译并运行这段代码，你会发现在通过引用成功地改变了x的值之后，它打印出了15的值。Sometimes, though, you need to mutable reference. A reference that lets you change the referenced data. Rust allows this. Mutable references are written using the syntax &mut as we see in the second code fragment. They allow the referenced value to change. And if you compile and run the code, you see that it prints the value 15 after having successfully changed the value of x via the reference.

# Rust引用限制：Constraints on References

- 当可变引用存在时，一个对象对其所有者来说是不可访问的。

除了区分可变和不可变的引用之外，Rust还对如何创建和使用引用进行了一些限制。In addition to distinction between mutable and immutable references, Rust enforces a number of constraints on how references can be created and used. 

![](/static/2022-01-29-17-46-22.png)

首先，**Rust中的引用不可能是空的。一个引用总是指向一个有效的对象**。在Rust中不可能创建或返回一个空指针。The first is that a reference in Rust can never be null. A reference always points to a valid object. it's not possible to create or return a null pointer in Rust. 

* 在C或Java中**可能成为空指针的值是通过Result和Option类型来处理的**。正如我们在讲座的前几部分所看到的，这是一个枚举，它的值要么是一些X，其中X是值，要么是没有值。该选项是使用**模式匹配提取的，允许编译器对无的情况进行强制检查**。Values that would be a potentially null pointer in C or Java are handled by returning and option type. As we saw in the previous parts of the lecture, this is an enum, that either has the value some X where X is the value, or has the value none. The option is extracted using pattern matching, allowing the compiler to enforce the check for the none case. 

第二个约束是，**虽然Rust允许对一个对象存在许多不可变的引用，但它【禁止同时对该对象存在任何可变的引用**】。The second constraint is that while Rust allows many immutable references to an object to exist, it prohibits there from being any mutable references to that object at the same time. 

* 当**一个对象的不可变的引用存在时，Rust编译器会强制要求被引用的对象是不可变的，【即使该对象被声明为可变的**】。这意味着你可以绝对确定，当一个对象的不可变引用存在时，被引用的对象不会改变。编译器会强制执行这个约束条件。And while an immutable reference to an object exists, the Rust compiler enforces that the referenced object is immutable, even if that's object was declared to be mutable. This means that you can be absolutely sure that, while an immutable reference to an object exists, the referenced object will not change. The compiler enforces this constraint. 
* 如果你试图编写**同时对同一个对象有可变和不可变的引用的代码，该代码将不会被编译**。If you try to write code that has both mutable and immutable references to the same object at the same time, that code will not compile. 

此外，编译器还强制规定，**在作用域中对一个对象【最多只能有一个可变的引用】，并且在可变的引用存在时，不能有对该对象的不可变的引用**。Furthermore, the compiler enforces that there can be at most one mutable reference to an object in scope, and that there can be no immutable references to the object, while a mutable reference exists. 

编译器还强制规定，**当可变引用存在时，原始对象是不可访问的**。The compiler also enforces that the original object is inaccessible while the mutable reference exists. 

* **如果你有一个对象的可变引用，你可以通过引用读取或修改该对象，而且只能通过该引用**。而且你可以确信，**程序的任何部分都不能访问该对象**。编译器严格执行了这些保证。它们限制了你可以写什么类型的程序，通过强制执行对数据的引用在不同时间可以存在的约束。If you have a mutable reference to an object, you can read or modify that object via the reference, and only via that reference. And you can be sure that no of a part of the program has access to that object. The compiler strictly enforces these guarantees. They limit what types of program you can write, by enforcing constraints on what references to data can exist at different times. 

结果是，这些规则使得空指针异常、迭代器无效和线程间的数据竞赛在Rust中不可能发生。他们用灵活性来换取安全性。As a consequence, though, these rules make null pointer exceptions, iterator  invalidation, and data races between threads impossible in Rust. They trade off flexibility for safety. 

* C、C++、Java和其他许多语言中可以编译但会崩溃或在运行时抛出异常的代码，在Rust中根本无法编译。在这些语言中产生不可预知的未定义行为的代码，在很多情况下也不会在Rust中编译 Code that would compile but crash, or throw an exception at runtime, and C, C++, Java, and many other languages simply will not compile in Rust. Code that gives unpredictable undefined behavior in those languages also, in many cases, will not compile in Rust

# 内存分配 & Box：Memory Allocation and Boxes

除了允许对现有对象的引用外，Rust还可以在堆上分配内存。在C语言中，堆上的内存是用malloc()函数分配的。**它的参数是所需分配的大小，并返回一个指向未初始化的堆内存的适当大小的指针。然后，该值可以通过写入取消引用的指针来存储在分配的内存中(先分配指向堆得内存，再初始化值**）。我们在幻灯片右侧的代码中看到，malloc()调用为一个整数分配空间，并将其分配给指针b In addition to allows references to existing objects, Rust makes it possible to allocate memory on the heap. In C, memory on the heap is allocated using the malloc() function. This takes as it's argument the size of the required allocation, and returns a pointer to uninitialised heap memory, of the appropriate size. The value can then be stored in the allocated memory by writing to the dereferenced pointer. We see this in the code on the right hand side of the slide, where the malloc() call allocates space for an integer and assigns this to the pointer, b. Then, in the next statement, the code write the value five to the allocated space. 

![](/static/2022-01-29-22-08-07.png)

Rust使用一种被称为Box的类型来指代堆分配的内存。Rust uses a type known as Box to refer to heap allocated memory. 

Box类型是一个智能指针类型，它引用了一个存储在堆上的T类型的对象。在左边的代码中，**语句let b = Box::new(t) 创建了一个新的Box**。而等价的C代码分配了内存，然后分别给该内存赋值。**Box的new函数得到了要存储的值，并在一次调用中分配了内存并存储了该值。也就是说，当我们写Box::new(5)时，我们不是在说分配5位内存。相反，我们是在说，分配足够的内存来容纳一个整数，并将整数值 "5 "存储到该内存中**。The Box type is a smart pointer type that references an object of type T that's stored on the heap. In the code on the left, the statement let b = Box::new(t) creates a new box. While the equivalent C code allocates the memory, and then separately assigns a value to that memory. The box new function is given the value to be stored and allocates the memory and stores the value in one call. That is, when we write Box::new(5) we're not saying allocate five bits of memory. Rather we're saying, allocate enough memory to hold an integer and store the integer value "5" into that memory. 

**box的实现，是作为一个指向堆分配的内存的指针**。变量b的表示方法与Rust代码和C程序完全相同。在分配方式上的差异被暴露给了程序员。The implementation of box, is as a pointer to the heap allocated memory. The variable, b, is represented in exactly the same way and the Rust code and in the C Program. The differences in the way allocation is exposed to the programmer. 

其结果是，Rust中的内存分配比C语言中的等价物更安全，这有三个原因 The result is that memory allocation in Rust is safer than the equivalent in C. There are three reasons for this.

* 首先，**Box::new()调用所返回的值被保证是初始化的**。在Rust中没有办法从未初始化的内存中读取，<font color="deeppink">而C语言允许你从分配的内存中读取，在进行赋值之前，会出现未定义的不可预测的行为</font> First, the value returned by the Box::new() call is guaranteed to be initialized. There's no way to read from uninitialized memory in Rust, whereas C allows you to read from the allocated memory, before making an assignment, which gives undefined unpredictable behavior. 
* 第二，**在Rust中保证应用程序的大小是正确的**。**C语言没有尝试检查malloc()分配的内存的大小是否与存储在该内存中的对象的大小相匹配**，如果对象大于分配的大小，就会出现未定义的、不可预测的行为。Second, the application is guaranteed to be the correct size in rust. The C language makes no attempt to check that the size of the memory allocated by malloc() matches the size of the object stored in that memory, and has undefined, and unpredictable behavior, if the object is larger than the allocation. 
* 最后，**Rust保证当Box超出范围时，内存会被自动去分配(智能指针**)。在C语言中，有必要手动调用free()函数去分配内存，而且**很容易忘记释放内存，浪费资源，或者过早释放内存，导致未定义行为**。And, finally, Rust guarantees that the memory will be automatically deallocated when the box goes out of scope. In C it's necessary to manually call the free() function to deallocate memory, and it's easy to either forget to the free memory, wasting resources, or to free memory too early, leading to undefined behavior.

---

![](/static/2022-01-30-00-32-18.png)

**默认**情况下，**Rust中的Box是不可变的，其内容不能被改变**。可以使用 "`let mut` "语法创建一个可变的Box，允许其值发生变化，如图所示。 By default, a box in Rust is immutable and its contents cannot be changed. A mutable box can be created that does allow the value to change, using the "let mut" syntax, as shown. 

最后，**Rust中的Box没有实现标准的Copy特性**。这意味着你可以传递Box，但你不能复制它们。Finally, boxes in Rust do not implement the standard copy trait. This means that you can pass boxes around, but you cannot make copies of them.

* 可以**保证一个Box只存在一个副本**。Box类型是一个指向在堆上分配的内存的指针。**如果有可能制作一个Box的副本，那么就有可能对同一个对象创建多个指针（禁止的）。就像Rust阻止你对同一个对象采取多个可变引用一样，它也阻止你通过Box创建多个指向同一个对象的指针。而且，与可变引用一样，这是为了防止线程之间的数据竞赛**。 It's guaranteed that only one copy of a box exists. The Box type is a pointer to memory allocated on the heap. If it were possible to make a copy of the box, then it would be possible to create several pointers to the same object. In the same way that Rust prevents you from taking several mutable references to the same object, it also prevents you from creating several pointers to the same object via boxes. And, as with mutable references, this is to prevent data races between threads.

# Strings

![](/static/2022-01-30-00-39-01.png)

Rust中的字符串被定义为unicode文本，并以UTF-8格式进行编码。**这使得它们可以代表全部的国际化文本**。Strings in Rust are defined to be unicode text and are encoded in UTF-8 format. This allows them to represent the full range of internationalized text. 

有点令人困惑的是，Rust中有两种字符串类型。Somewhat confusingly, there are two string types in Rust.

* **str**是一个**不可变**的字符串片，它总是**通过一个不可变的引用`&str`来访问**。正如我们在幻灯片上看到的那样，Rust中的<font color="deeppink">字符串字面量是&str类型的</font>。**＆str类型是作为一种原始类型内置于语言**中的 A str is an immutable string slice that's always accessed via an immutable reference as &str. String literals in Rust, as we see on the slide, are of type &str. The &str type is built into the language as a primitive type. 
* **字符串String是一个在标准库中实现的可变字符串缓冲类型**。从本质上讲，它是一个**指向容纳UTF-8格式文本的数组的可变box（智能指针**） In contrast, a string is a mutable string buffer type implemented in the standard library. Essentially it's a mutable box pointing to an array holding text in UTF-8 format. 

虽然`&str`**类型的变量不能改变**，但正如我们在幻灯片上看到的，一个**string可以被修改，并且可以从一个字符串字面创建**。While the variable of type &str cannot change, a string can be modified, as we see on the slide, and can be created from a string literal. 

* Rust中的string等同于Java中的字符串缓冲区。Rust中的&str类型相当于Java的String。a string in Rust is equivalent to a string buffer in Java. The &str type in Rust is equivalent to a Java String. 

最后，Rust中的**string类型实现了标准库中的deref特性**。这使得**编译器可以实现字符串的自动解引**。 Finally, the string type in Rust implements the deref trait from the standard library. This allows the compiler to implement automatic dereferencing for strings.

* 在示例代码中，变量s的类型是String。如果我们写let r = &s，那么我们就会得到对该字符串string的引用。变量r的类型是&String。它是对一个string对象的引用。  In the example code, the variable s has type String. If we write let r = &s, then we get a reference to that string. The variable, r, has type &String. It's a reference to a String object. 
* 相反，如果我们**取一个对s的引用并把它赋给我们指定为&str类型的变量t，那么编译器就会使用deref特性的实现来执行转换，给我们一个&str**，一个不可变的字符串片断。If, instead, we take a reference to s and assign it to the variable t, that we've specified as being of type &str, then the compiler uses the implementation of the deref trait to perform the conversion, giving us an &str, an immutable string slice. 
  * `let t: &str = &s;`
  * **这种类型转换没有运行时成本**，因为它只涉及到一个指向string类型的内部可变缓冲区的指针。Rust关于不可变的引用的通常规则意味着，**当&str引用存在时，底层的字符串是不可改变的**。由于这种转换是无消耗的，那些不会改变字符串的函数往往只对&str实现，而不用针对string类型实现。This type conversion has no runtime cost, since it just involves taking a pointer to the internal mutable buffer of the string type. The usual Rust rules about immutable references mean that the underlying string becomes unchangeable while the &str reference exists. Since this conversion is free, functions that don't need to mutate the string tend to be only implemented for &str and not on string values.

# Rust特点:key points

![](/static/2022-01-30-01-03-07.png)
![](/static/2022-01-30-01-03-21.png)

我们对Rust编程语言的初步审查到此结束。应该很清楚，Rust在很大程度上是一种传统的系统语言。That concludes our initial review of the Rust programming language. As should be clear, Rust is largely a traditional systems language. 

* 对于来自其他语言的程序员来说，基本类型、控制流和数据结构是非常熟悉的。但它确实对系统语言进行了一些创新。The basic types, control flow, and data structures are very familiar to programmers coming from other languages. But it does make some innovations for systems language. 
* 枚举类型和模式匹配是众所周知的函数式编程语言的特点。如Option和Result类型。但它们以前并没有在系统编程中使用。同样，使用structs和trait作为面向对象编程的替代方案，反映了Haskell中类型类的使用，但这在系统领域是新的。 Enumerated types and pattern matching are well known features of functional programming languages. As the Option and Result types. But they've not previously been used in systems programming. Similarly, the use of structures and traits as an alternative to object oriented programming mirrors the use of type classes in Haskell, but it's new in the systems domain. 

总的来说，Rust中真正新颖的东西比较少。Overall, there's relatively little in Rust that is truly novel. 

* 语法与C语言有一点不同，但它的不同之处主要来自于标准ML的启发。基本数据类型与C语言密切相关，枚举类型和模式匹配来自标准ML语言。而Standard ML是一种有影响力的函数式编程语言，早在20世纪80年代就已经开发出来了，在Haskell开发之前就被广泛用于函数式编程的教学，所以在10-20年前就被程序员所熟悉。The syntax is a little is a little different from that of C, but where it differs it mostly takes inspiration from Standard ML. The basic data types closely match those of C. Enumerated types and pattern matching come from the Standard ML language. And Standard ML was an influential functional programming language, developed back in the 1980s, that was widely used for teaching functional programming before Haskell was developed, and so was quite familiar to programmers 10-20 years ago. 
* Traits是由Haskell的类型类type classes改编而来，也有许多来自C++的影响，但这些影响通常是看C++如何解决问题，然后做相反的事情。 Traits are adapted from Haskell type classes, and there are many influences from C++, but these are generally of the form of looking at how C++ solves a problem, and doing the opposite. 
* Rust倾向于安全的默认值，而C++倾向于性能，并使安全选择成为一种选择。Rust tends to favor the safe default, while C++ tends to prefer performance, and makes the safe choice an option. 
* Rust有一个地方很新颖，那就是内存管理。围绕着引用和所有权的想法，这些都是Rust独有的。 The one area where Rust is novel it's memory management. The ideas around references and ownership that we've touched on in this lecture and we'll talk, more about later in the course, are unique to Rust. 
* 虽然，即使在这里，它们也受到了先前由AT&T和康奈尔大学在21世纪初开发的被称为Cyclone的研究语言工作的影响。Although, even here, they're influenced by previous work on a research language known as Cyclone developed by AT&T and Cornell University in the early 2000s.

# =================

# Reading

1. https://blog.regehr.org/archives/213
2. 