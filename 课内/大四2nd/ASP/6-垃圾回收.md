# Content

机翻

讨论了垃圾收集。它回顾了一些著名的垃圾收集算法，包括mark-sweep、mark-compact、copy和generational算法。它讨论了它们的相对性能，以及与手工内存管理和基于区域的内存管理相比，使用垃圾收集的得失。讨论了影响垃圾收集行为的各种实际因素。

* [Content](#content)
* [1基本垃圾回收：Basic Garbage Collection](#1基本垃圾回收basic-garbage-collection)
* [垃圾回收定义：Garbage Collection](#垃圾回收定义garbage-collection)
* [标记清除：Mark-Sweep Collectors](#标记清除mark-sweep-collectors)
* [标记清除-标记](#标记清除-标记)
* [标记清除-清除](#标记清除-清除)
* [标记清除-summary](#标记清除-summary)
* [标记压缩：Mark-Compact Collectors](#标记压缩mark-compact-collectors)
* [标记压缩-优缺点](#标记压缩-优缺点)
* [复制算法：Copying Collectors](#复制算法copying-collectors)
* [复制算法-工作原理](#复制算法-工作原理)
* [复制算法-Cheney Algorithm](#复制算法-cheney-algorithm)
* [复制算法-效率](#复制算法-效率)
* [Summary-基本垃圾回收](#summary-基本垃圾回收)
* [===============](#)
* [2分代和增量垃圾收集：Generational and Incremental Garbage Collection](#2分代和增量垃圾收集generational-and-incremental-garbage-collection)
* [对象生命周期：Object Lifetimes](#对象生命周期object-lifetimes)
* [分代复制算法：Copying Generational Collectors](#分代复制算法copying-generational-collectors)
* [分代复制-原理](#分代复制-原理)
* [分代复制-引用问题](#分代复制-引用问题)
* [分代复制-效率summary](#分代复制-效率summary)
* [增量垃圾回收：Incremental Garbage Collection](#增量垃圾回收incremental-garbage-collection)
* [增量垃圾回收-原理](#增量垃圾回收-原理)
* [增量回收-协调策略:Coordination Strategies](#增量回收-协调策略coordination-strategies)
* [增量回收-效率(三色算法-协调策略)](#增量回收-效率三色算法-协调策略)
* [===============](#-1)
* [3  实际因素：Practical Factors](#3--实际因素practical-factors)
* [===============](#-2)

# 1基本垃圾回收：Basic Garbage Collection

讲座的第一部分介绍了垃圾收集的概念，并讨论了三种基本的垃圾收集算法：标记扫除算法、标记压缩算法和复制算法。标记扫除算法实现起来很简单，但效率很低。它在运行中停止程序，有很高的和不可预测的收集时间，并且有很差的引用位置性，导致内存碎片化。Mark-compact收集器在此基础上进行了改进，提高了应用时间并减少了碎片化，但它更复杂、更慢，而且仍然有较差的引用位置性。而复制型收集器又提高了性能，减少了碎片，但代价是内存开销更高。

# 垃圾回收定义：Garbage Collection

通过垃圾收集避免了引用计数的问题和编译时所有权跟踪的复杂性 •	Avoid problems of reference counting and complexity of compile-time ownership tracking via garbage collection

- 明确地跟踪分配的对象，记录哪些对象正在使用；处理未使用的对象•	Explicitly trace through allocated objects, recording which are in use; dispose of unused objects
  - 因此，垃圾收集的原则是避免引用计数的一些问题，并避免基于区域的内存管理中编译时所有权跟踪的复杂性，通过建立一个系统，可以明确地跟踪内存并收集未使用的对象；并明确地收集垃圾。一般来说，垃圾收集的工作方式是，收集器追踪内存，追踪所有已分配的、已使用的、已在堆上分配的对象，并试图找到这些对象中哪些仍在使用。如果那些在堆上的对象有的没有被引用，它就把它们处理掉。它自动释放内存。So the principle of garbage collection is to avoid some of the problems with reference counting, and avoid the complexity of compile time ownership tracking in region based memory management, by building a system which can explicitly trace through memory and collect unused objects; and explicitly collect the garbage. The way garbage collection works, in general, is that the collector traces through the memory, traces through all of the objects which have been allocated, that have been used, that are allocated on the heap, and it tries to find which of those objects are still in use. And if some of those objects which are on the heap are not somehow referenced, it disposes of them. It automatically frees the memory
- 将垃圾收集转移到程序执行的一个独立阶段，而不是对象生命周期的一个综合部分•	Moves garbage collection to be a separate phase of the program’s execution, rather than an integrated part of an objects lifecycle
  - 从本质上讲，这就把垃圾收集移到了对象的生命周期中，而不是像基于区域的方案那样，把管理对象的寿命与知道它何时离开范围结合起来，而是把它移到一个独立的执行阶段，一个独立的垃圾收集系统，与程序一起运行 And essentially this moves the garbage collection, so instead of being integrated into the object’s lifecycle, in the way a region based scheme integrates managing when the object lives into knowing when it goes out of scope, it moves it into a separate phase of execution, a separate garbage collection system, that runs alongside the program.
- 程序（突变器）和垃圾收集器的操作是交错进行的•	Operation of the program (the mutator) and the garbage collector is interleaved
  - 因此，程序的运行--垃圾收集研究者称之为 "突变器"--和垃圾收集器是某种交错的。程序运行了一段时间，然后暂停。垃圾收集器运行，收集一些垃圾，回收一些内存。然后程序重新启动。他们在这两个执行阶段之间跳来跳去 So the operation of the program – what garbage collection researcher call “the mutator” – and the garbage collector is sort of interleaved. The program runs for a while, and then it pauses. The garbage collector runs, collects some garbage, reclaims some memory. Then the program restarts. And they bounce around between the two phases of execution.

存在许多追踪垃圾收集的算法。•	Many tracing garbage collection algorithms exist:

- 基本垃圾收集器•	Basic garbage collectors
  - 标记清除收集器•	Mark-sweep collectors
  - 标记压缩收集器•	Mark-compact collectors
  - 复制收集器•	Copying collectors
- 分代垃圾收集器•	Generational garbage collectors

# 标记清除：Mark-Sweep Collectors

> 在第一阶段，它在堆中运行，并试图找到活的对象，将它们与死的对象分开。从本质上说，它是在标记那些仍然活着的对象。In the first phase it's runs through the heap, and tries to find that the live objects and separate them from the dead objects. Essentially it's marking the objects which are still alive.
> 然后，在第二阶段，它通过，并回收垃圾。它扫除那些没有被标记的对象。  And then, in the second phase, it goes through, and reclaims the garbage. It sweeps away the objects which have not been marked. 
> 这是一个非递增的算法，在垃圾收集器运行时，它会暂停程序。因此，当系统检测到它的内存不足时，程序会被暂停，而垃圾收集器开始运行。它在堆中运行，标记活的对象，再次在堆中运行，以清扫和回收垃圾。然后，才重新启动程序的执行。It’s a non-incremental algorithm, in that it pauses the program when the garbage collection, while the garbage collector runs. So, when the system detects that it’s running short of memory, the program gets paused, and the garbage collector starts running. It runs through the heap, marks the live objects, runs through the heap again, to sweep up, to reclaim, the garbage. And, only then, restarts the execution of the program.

- 最简单的自动垃圾收集方案•	Simplest automatic garbage collection scheme
- 两阶段的算法•	Two phase algorithm
  - 区分活着的对象和垃圾（标记）。•	Distinguish live objects from garbage (mark)
  - 回收垃圾（清扫）•	Reclaim the garbage (sweep)
  - 非递增式：当内存变得紧张时，程序会暂停，以执行垃圾回收工作•	Non-incremental: program is paused to perform collection when memory becomes tight

# 标记清除-标记

> 第一个阶段是标记阶段。标记阶段的目标是区分哪些对象是活的。我们的目标是找到实际上可以到达的、实际上仍在被程序使用的对象的集合。The first phase is the marking phase. The goal of the marking phase is to distinguish the objects which are alive. The goal is to find the set of objects which are actually reachable, actually still in use by the program. 
> 要做到这一点，它首先要找到所谓的对象根集。根集合是全局变量的集合，是程序中全局分配的任何东西，也是堆栈中分配的变量集合。而且，当你查看分配在堆栈上的变量集时，你不仅仅要看当前的堆栈框架，对于当前执行的函数，你要看所有的父堆栈框架，一直到main()的堆栈框架。所以它是所有在调用栈中执行的局部变量，直到当前的执行点，加上任何全局变量。这就构成了根集。To do this, it starts by finding what's called the root set of objects. The root set is the set of global variables, anything allocated, globally in the program, and it's the set of variables which are allocated on the stack. And, when you look at the set of variables allocated on the stack, you don't just look at the current stack frame, for the currently executing function, you look at all of the parents stack frames for this, all the way up to the stack frame for main(). So it's all of the local variables executed in the call stack, up to the current point of execution, plus any global variables. And this comprises the root set
> 然后，垃圾收集器从这个根集开始，并跟踪指针。根集合中的任何对象，如果有一个指向另一个对象的指针，它就会跟踪这个指针到那个对象，然后，递归地，从那里开始跟踪指针，找到所有其他的对象。也许这是一个广度优先的搜索，也许这是一个深度优先的搜索，你用什么算法来追踪指针并不特别重要。最关键的是，你从根集开始，然后沿着指针找到系统中的所有其他对象。The garbage collector then starts with this root set, and follows pointers. Any object in that root set, which has a pointer to another object, it follows that pointer to that object, and then, recursively, from there on follows the pointers out to find all of the other objects. And maybe that's a breadth-first search, maybe it's a depth-first search, it doesn’t particularly matter what algorithm you use to follow the pointers. The key thing is that you start from the root set, and you follow the pointers to find all of the other objects in the system.
> 而且，当你跟随指针时，你要标记这些对象。你在对象头中设置一个位，或者在某个表格中设置一个位，以确认你已经到达一个特定的对象。而且，如果你发现一个你已经到达的对象，你可以停下来，绕回来，并搜索一些其他的指针。最终，你会用完可追踪的指针。最终，你已经遍历了整个图，并找到了所有从根集可以到达的对象。如果你有一个对象的循环，那就意味着你会回到自己身边，一旦你绕了一圈，你就会停下来，然后回溯，看看其他的对象。如果你有一个对象的循环，这些对象互相引用，但从根集上是无法到达的，那么你就永远无法到达这些对象，所以它们永远不会被标记。 And, as you follow the pointers, you mark the objects. You set a bit in the object header, or set a bit in some table somewhere, to recognise that you've reached a particular object. And, if you find an object which you've already reached, you can stop, circle back, and search some of the other pointers. And eventually you’ll run out of pointers to follow. Eventually you’ve traversed the whole graph, and found all of the objects that are reachable from the root set. If you have a cycle of objects, that just means you’ll come back to yourself, and you'll stop once you've gone around the loop once, and backtrack, and look at the rest of the objects. If you have a cycle of objects which reference each other, but are not reachable from the root set, then you'll never you'll never be able to reach those, and so they’ll never be marked.

- 标记阶段：区分活体物体•	The marking phase: distinguishing live objects
- 确定对象的根集，包括。•	Determine the root set of objects, comprising:
  - 任何全局变量•	Any global variables
  - 任何分配在堆栈上的变量，在任何现有的堆栈框架中•	Any variable allocated on the stack, in any existing stack frame
- 盯着根集遍历对象图，找到其他可达对象•	Traverse the object graph staring at the root set to find other reachable objects
  - 从根集开始，跟踪指向其他对象的指针•	Starting from the root set, follow pointers to other objects
  - 追踪每个对象中的每个指针，系统地找到所有可到达的对象•	Follow every pointer in every object to systematically find all reachable objects
  - 可以采用广度优先或深度优先的方式进行•	May proceed either breadth-first or depth-first
  - 互相引用的对象的循环，但从根集合中无法到达的，将不会被标记。•	A cycle of objects that reference each other, but are not reachable from the root set, will not be marked
- 将可到达的对象标记为活的•	Mark reachable objects as alive
  - 在对象头中设置一个位，或者在一些单独的活体对象表中设置一个位，以表明该对象是可到达的。•	Set a bit in the object header, or in some separate table of live objects, to indicate that the object is reachable
  - 在以前见过的对象上停止遍历，以避免永远循环下去•	Stop traversal at previously seen objects to avoid looping forever

# 标记清除-清除

> 第二阶段是所谓的清扫阶段，在那里你找到不再存活的对象。The second phase is what's called the sweep phase, where you find the objects which are no longer alive.

扫除阶段：回收不再存在的对象•	The sweep phase: reclaiming objects that no longer live

- 对整个堆进行一次扫描，检查每个对象的有效性•	Pass through entire heap once, examining each object for liveness
  - 如果被标记为有效，则保留该对象•	If marked as alive, keep the object
  - 否则，释放内存并回收该对象的空间•	Otherwise, free the memory and reclaim the object’s space
- 【其工作方式是，线性地通过整个堆，并查看堆中的每个对象。如果该对象在标记阶段被标记为活着，那么它就保留它。否则，它将释放内存以回收空间。 And the way this works is that it passes linearly through the entire heap, and it looks every object in the heap. If the object has been marked in the marking phase as being alive, then it keeps it. Otherwise, is it frees the memory to reclaim the space.】

当对象被回收时，其内存被标记为可用。•	When objects are reclaimed, their memory is marked as available 【当一个对象被回收时，它将其内存标记为可重新使用。When an object is reclaimed, it marks its memory as being available for reuse.】

- 系统维护一个未使用的内存块的自由列表•	The system maintains a free list of blocks of unused memory
- 新的对象被分配到现在未使用的内存中，如果它们适合的话；或者在堆的其他地方尚未使用的内存中。•	New objects are allocated in now unused memory if they fit; or in not-yet-used memory elsewhere on the heap
  - 系统维护一个空闲列表，它维护一个未使用的内存块的列表。当它分配对象时，它把它们放入空闲列表中的一些空间，并在列表中删除这些空间。And the system maintains a free list, it maintains a list of unused blocks of memory. And when it allocates objects, it puts them into some of the space that was in the free list, and removes that space in the list.
- 碎片化是一个潜在的问题--但不会比使用malloc()/free()更糟。•	Fragmentation is a potential concern – but no worse than using malloc()/free()
  - 扫频阶段只是在整个堆中进行。它从头开始，一路走到尾，任何被标记的对象都被保留，任何没有被标记的对象都被添加到空闲列表中。当它要在未来分配新的对象时，正如我所说的，它会把它们从空闲列表中移除。对象不会到处移动，所以如果一个对象被回收，就会有一个内存缺口。而且，在它的两边可能还有对象，所以内存有可能是碎片化的。但我认为这并不比使用malloc()或free()差，因为它们也不会到处移动对象。如果你分配大量的小对象，并以不可预测的顺序释放它们，你最终会得到相当零散的内存，其中有很多小洞。   And the sweep phase just go through the entire heap. It starts the beginning, works its way through to the end, and any object which was marked it keeps, and any object which was not marked is added onto the free list. When it comes to allocating new objects in the future, as I say, it takes them off the free list. Objects don't move around, so if an object is reclaimed there's a gap in memory. And there may be objects on either side of it, so the memory is potentially fragmented. But I think this is no worse than using malloc() or free(), which also don't move objects around. If you allocate lots of small objects, and release them in an unpredictable order, you end up with memory which is quite fragmented, with lots of little holes in it.

---

# 标记清除-summary

标记扫描收集器很简单，但效率很低。•	Mark-sweep collectors are simple, but inefficient:

- **垃圾收集很慢，而且持续时间不可预测**•	Garbage collection is slow and has unpredictable duration
  - 程序在收集器运行时被停止•	Program is stopped while the collector runs 【程序在收集器运行时被停止，所以它必须等待垃圾收集器的执行 The program gets stopped while the collector runs, so it has to wait for the garbage collector to execute.】
  - 收集垃圾的时间是不可预测的，取决于活对象的数量（标记阶段的时间）和堆的大小（扫除未使用对象的时间）。•	Time to collect garbage is unpredictable, and depends on the number of live objects (time for the marking phase) and size of the heap (time to sweep up unused objects)
    -  垃圾收集器运行的时间取决于有多少对象是活的，因为它必须从根集开始搜索，并跟踪所有的指针，所以程序分配的内存越多，它跟踪所有的指针，并标记活的对象所需的时间就越长 How long it takes the garbage collector to run will depend on how many objects are alive, because it has to search though from the root set, and follow all of the pointers, so the more memory the program has allocated, the longer it will take it to follow all the pointers, and mark the live objects.
    -  类似地，垃圾收集器需要运行多长时间将取决于堆的大小，因为它必须扫过整个堆并检查对象是否可以被回收 Similar, how long the garbage collector takes to run will depend on the size of the heap, because it has to sweep through the entire heap and check to see if the objects can be reclaimed
  - 与引用计数不同，如果程序有大量的内存分配，标记-扫除式垃圾收集会更慢。•	Unlike reference counting, mark-sweep garbage collection is slower if the program has lots of memory allocated
    - 这取决于程序曾经分配过的最大内存量，因为它知道被触及的堆的最大区域是什么。但是，如果一个程序分配了大量的内存，或者如果一个程序以前分配了大量的内存，那么我们知道它已经触及了很多堆，扫除垃圾的速度会变慢。这与引用计数和基于区域的系统形成了对比，后者只是取决于他们正在查看的特定对象集。这取决于分配的内存的总大小和之前分配的总大小 this depends on the maximum amount of memory that the program has ever allocated, because it knows what's the maximum region of the heap that’s been touched. But, if a program has a lot of memory allocated, or if a program has previously allocated a lot of memory, so we know it's touched a lot of the heap, the mark sweep garbage collection gets slower. And this is in contrast to reference counting and region based systems which just depends on the particular set of objects which that they're looking at. This depends on the total size of the memory allocated and the total size that has been previously allocated.
    - 如果你使用一个引用计数方案，例如，或基于区域的方案，当你操作一个指针时，你改变了引用计数，你也许分配或释放了那个对象，只有你当前访问的那个对象的引用计数被更新 If you're using a reference counting scheme, for example, or region-based scheme, when you manipulate a pointer, you change the reference count, you maybe allocate or free that object, it’s only that object you're currently accessing where the reference count gets updated
- **标记清除垃圾收集没有引用的位置性**•	Garbage collection has no locality of reference
  - 以不可预测的顺序通过整个堆，破坏了缓存和虚拟内存子系统的运行。•	Passing through the entire heap in unpredictable order disrupts operation of cache and virtual memory subsystem
  - 对象位于它们适合的地方，而不是保持引用位置的地方•	Objects located where they fit, rather than where maintains locality of reference
  - 【一个标记扫描收集器会穿过整个堆。当它运行时，它会访问系统中的每个对象。这可能会扰乱缓存，扰乱虚拟内存子系统，因为它把所有的对象都带入了缓存，所以它驱逐了之前的工作集。而且，如果你有一个虚拟内存系统，而且一些内存被分页到了磁盘上，那么它就必须访问这些页面，从磁盘上把它们带进来，以便在标记和扫描阶段扫描它们。因此，这就破坏了缓存，并且从虚拟内存中带入了一些东西，因此它可能会相当慢】 A mark-sweep collector goes through the entire heap. It accesses every object in the system when it runs. And this can disrupt the cache, it can disrupt the virtual memory subsystem, by bringing all of the objects into the cache, so it evicts the previous working set. And, if you have a virtual memory system, and some of the memory is paged out to disk, then it has to access those pages, bring them in from disk, in order to scan through them in the mark and sweep phase. So this disrupts the cache, and it brings things in off of the virtual memory, so it can be quite slow as a result.
- **自由空间的碎片化是一个问题**•	Fragmentation of free space is a concern
  - 由于对象没有被移动，空间可能变得支离破碎，使得即使整体空间可用，也很难分配到大对象。•	Since objects are not moved, space may become fragmented, making it difficult to allocate large objects even though space available overall
  - 【对象不会被到处移动，所以当东西被释放时，会有一个空隙可以被重新使用。但这可能意味着内存，空闲的内存，是以一堆小碎片的形式存在的，一堆小块，而不是一个大的连续区域。而这可能使分配大对象变得困难，即使你有足够的内存，也可能没有足够大的连续的内存块】 Objects don't get moved around, so when things get freed there's a gap which can be reused. But this could mean that the memory, the free memory, exists as a bunch of small fragments, a bunch of small pieces, rather than a large contiguous region. And this can make it difficult to allocate large objects, even if you have enough memory, there may not be a large enough contiguous block of memory.

# 标记压缩：Mark-Compact Collectors

- 目标：与标记扫描采集器相比，解决碎片问题并加快分配速度•	Goal: solve fragmentation problems and speed-up allocation, compared to mark-sweep collectors

![](/static/2022-05-06-21-01-33.png)

- 三个逻辑阶段。•	Three logical phases:
- 【第一阶段是一个标记阶段，就像在标记扫描收集器中一样。它找到对象的根集，然后沿着根集的指针在内存中扫描，以找到活着的对象集。从概念上讲，它在内存中又做了一次扫描，目的是为了达到，回收任何未使用的对象。所以，这就像标记扫描收集器中的扫描阶段。它贯穿整个堆，任何活着的、在遍历阶段被标记过的对象都被保留下来，其他的都被删除】 The first phase is a marking phase, just like in the mark sweep collectors. It finds the root set of objects, and then it scans through the memory, following the pointers from the root set, to find the set of objects which are alive. And that it does conceptually another pass through the memory, with the goal of reaching, the goal of reclaiming, any unused objects. So it's just like the sweep phase in a mark sweep collector. It runs through the whole heap, and any objects which are alive, which have been marked in the traversal phase, are kept, and anything else is deallocated.
  - 遍历对象图，标记实时对象•	Traverse object graph, mark live objects
  - 收回无法到达的对象•	Reclaim unreachable objects
- 【然后，从概念上讲，它对堆进行第三次扫描，并对活的对象进行压缩。因此，如果对象之间有空隙，有东西被回收，它就会移动这些对象，使分配的内存在一个连续的空间里，而所有空闲的内存在最后的另一个连续的块里】 And then, conceptually, it makes a third pass through the heap, and it compacts the live objects. So if there are gaps between the objects, where something has been reclaimed, it moves those objects so that the allocated memory is in a contiguous space, and all the free memory is in another contiguous block at the end.
  - 压缩活动对象，移动它们以留下连续的自由空间•	Compact live objects, moving them to leave contiguous free space
- 【实现了这一点，回收和压缩可以在一次完成，但它仍然会穿过整个地址空间，仍然会触及所有的内存，并可能移动一些对象。】implement this, the reclaiming and the compacting can be done in one pass, but it still goes through the entire address space, and it still touches all of the memory, and potentially move some of the objects around.
  - 回收和压缩内存可以在一次完成，但仍会触及整个地址空间•	Reclaiming and compacting memory can be done in one pass, but still touches the entire address space

# 标记压缩-优缺点

一旦完成分配，它就会给你带来非常快速的分配

![](/static/2022-05-06-21-01-33.png)

- 优点。•	Advantages:
  - 【首先是它们解决了碎片化问题。通过移动对象，它们确保在收集器运行后所有的空闲内存都在一个连续的块中。因此，你不需要担心你在这里和那里只有少量的空闲字节，而没有大的块。因此，所有的空闲空间都留在一个连续的块中，你可以根据你的需要进行分配。它们也使内存分配变得非常快，因为空闲的内存在一个连续的块中，你不必通过某种复杂的空闲列表结构来为你需要分配的内存找到适当大小的间隙】The first is that they solve the fragmentation problem. By moving the objects around, they make sure that all of the free memory is in one contiguous block after the collector has run. And therefore you don't need to worry about the fact that you only have a small numbers of free bytes here and there, and no large blocks. So all the free spaces is left in one contiguous block, and you can allocate as much as you need. They also make memory allocation very fast, because the memory the free memory, is in a contiguous block, you don't have to search through some sort of complicated free list structure to find the appropriate sized gap for the memory you need to allocate.
    - 解决了碎片化的问题--所有的自由空间都在一个连续的块中。•	Solves fragmentation problems – all free space is in one contiguous block
  - 【 内存分配只是在空闲区域中获取第一个地址，将一个指针指向下一个空闲地址，然后返回上一个块。这只是一个加法和一个指针的返回，所以分配新的内存总是非常非常快】 Memory allocation is just a case of taking the first address in the free region, bumping a pointer to where next free address will be, and returning the previous block. It's just an addition and a return of a pointer, so it's always very, very fast to allocate new memory
    - 分配速度非常快--总是从空闲块的开始分配，所以分配只是将指针递增到空闲空间的开始，然后返回之前的值•	Allocation is very fast – always allocating from the start of the free block, so allocation is just incrementing pointer to start of free space and returning previous value

- 缺点是。•	Disadvantages:
  - 【**但缺点是，就像标记清扫收集器一样，引用的位置性很差。它必须穿过整个堆，从虚拟内存中把东西拉进来，而且它至少要做两次。它也很慢，因为它必须把对象移来移去。它必须在内存中复制一些对象，而且有可能要复制相当多的对象。它需要多长时间取决于它要复制多少个对象，有多少个对象被移动。这取决于可达内存的大小，也取决于堆的大小**】The disadvantages, though, like the mark sweep collectors, the locality of reference is bad. It has to pass through the entire heap, pull things in from virtual memory, and it has to do this at least twice. it's also slow, because it has to move objects around. It has to copy some objects in memory, and could potentially have to copy quite a lot of objects. And how long it takes will depend on how many objects it has to copy, how many objects get moved around. It depends on the size of the reachable memory, and it depends on the size of the heap.
    - 回收的参考定位性差•	Collection has poor locality of reference
    - 回收很慢，因为要在内存中移动对象，而且所花的时间是不可预测的•	Collection is slow, due to moving objects in memory, and time taken is unpredictable
  - 【**而且这很复杂。你必须移动对象，这意味着你必须改变任何指向这些对象的东西，你必须改变指针的值。所以，你不仅要标记对象，还要移动它们，并且要更新所有指向这些对象的指针。这意味着你需要一个运行时系统，知道什么是指针，知道哪些指针指向特定的对象，并能从对象回到指针上，在对象移动时更新它们以指向一个新的位置。所以这确实需要某种虚拟机或解释器，在那里你可以很容易地更新指针的值，在那里你可以很容易地找到并更新所有指针的值**。】 And it's complicated. You have to move objects around, and that means you have to change anything which points to those objects, you have to change the pointer values. So, not only are you marking the objects, but you're moving them, and you're updating all the pointers that point to those objects. And this means you need a runtime system that knows what is a pointer, and knows which pointers point to particular objects, and can go back from objects to the pointers and update them to point to a new location when the object moves. So this really needs some sort of virtual machine or interpreter, where you can easily update the values of the pointers, where you can easily find and update the values of all of the pointers.
    - 回收很复杂--需要更新所有移动对象的指针•	Collection is complex – needs to update all pointers to moved objects

# 复制算法：Copying Collectors

- 复制收集器将遍历（标记）和复制阶段整合为一个通道•	Copying collectors integrate traversal (marking) and copying phases into one pass
  - 【**因此，它试图将遍历对象图、标记活动对象以及将这些对象复制到一个连续区域的过程集成到一次中。使剩余的内存基本上是空闲的。其思想是，在执行第一次遍历时，所有活动对象都被复制到一个内存区域中。所有剩余的内存，在这个区域之外的，都是垃圾，或者没有被使用，并且可以立即被标记为 free**】So it tries to integrate the traversing through the object graph, the marking of the live objects, and the copying of those objects into a contiguous region, into one pass. And make freeing the remaining memory essentially free. The idea is that, by the time that first pass has executed, all of the live objects have been copied into one region of memory. And all the remaining memory, which is outside of that region, is garbage, or has not been used, and can immediately be marked as free
    - 所有的实时数据都被复制到一个区域的内存中。•	All the live data is copied into one region of memory
    - 所有剩余的内存包含垃圾，或尚未使用的内存•	All the remaining memory contains garbage, or has not yet been used

- 【**这有点像标记压缩模式，但是它更有效率，收集所需的时间取决于活动对象的数量，取决于它找到并复制到新空间中的对象的数量。回收剩余的物体基本上不需要花费时间。**】 It’s kind-of like a mark compact scheme, but it's more efficient, and the time it takes to collect depends on number of live objects, depends on the number of objects it finds and copies into the new space. And reclaiming the remaining objects takes essentially no time.
  - 与mark-compact类似，但效率更高•	Similar to mark-compact, but more efficient
  - 收集的时间与实时对象的数量成正比•	Time taken to collect is proportional to the number of live objects

# 复制算法-工作原理

![](/static/2022-05-06-21-40-02.png)

- 使用半空间Stop-and-copy。•	Stop-and-copy using semispaces:
- 【**它首先将堆分成两半，每一半都包括一个连续的内存块。所以你只在总堆内存的一半中工作。所以，你立即浪费了一半的内存。你在一次使用一半的内存。而你只从那一半的堆中分配内存。所以，每次程序分配一个新对象时，它都是以连续的方式在堆的一半中分配内存。内存分配速度很快，因为它只是分配堆中的下一个空闲地址，而且它只是以连续的方式在内存中依次进行。这意味着你不需要担心碎片问题，因为你有整个堆的一半可以分配，而且你只是以一种连续的方式线性地通过它**】it starts by dividing the heap into two halves, each of which comprises a contiguous block of memory. So you're only working in one half of the total heap memory. So, you’ve immediately wasted half the memory. You're using half the memory at a time. And you allocate memory from that half of the heap only. So, every time program allocates a new object, it allocates memory in a contiguous fashion in one half of the heap. And memory allocation is fast, because it's just allocating the next free address in the heap, and it just proceeds, in order, through the memory in a contiguous fashion. And it means you didn't need to worry about fragmentation, because you've got the whole of this half of the heap to allocate from, and again you're just passing through it linearly in a contiguous way
  - 将堆分成两半，每一半都是连续的内存块•	Divide the heap into two halves, each one a contiguous block of memory
  - 只从堆的一半线性地进行分配•	Allocations made linearly from one half of the heap only
    - 内存是连续分配的，所以分配速度很快（就像在标记-压缩收集器中一样）•	Memory is allocated contiguously, so allocation is fast (as in the mark- compact collector)
    - 在分配不同大小的数据时，没有碎片化的问题•	No problems with fragmentation when allocating data of different sizes
- 【**一直这样做，直到你进行分配时，你发现它放不下了。你发现你已经用完了那一半的堆，而且没有更多的空间了。在这一点上，垃圾收集器被触发了**。】 follow this through, until you get to perform an allocation and you find it won’t fit. You find you've used the entirety of that half of the heap, and there's no more space left. At that point the garbage collector is triggered.
  - 当请求的分配不适合堆的活动部分时，将触发收集	When an allocation is requested that won’t fit into the active half of the heap, a collection is triggered

---

![](/static/2022-05-06-21-45-08.png)

- 回收停止程序的执行•	Collection stops execution of the program

- 【**垃圾收集器会停止程序的执行，并在堆的活动部分，即你刚刚分配的那一半堆中进行传递。它根据程序的根集，线性地通过堆，并将它发现的任何活对象复制到另一半堆中。因此，它根据全局变量和堆栈，即堆栈框架上的变量来识别根集，并跟随这些指针进入堆中。而这些对象中的任何一个都会被添加到未使用的一半，也就是所谓的 "To Space"，即堆的另一半。它跟踪所有的指针，按顺序将它们加入到堆中。所以它把它们移到另一半堆内存的一个连续区域。它使用一种被称为Cheney算法的算法来做到这一点。一旦它跟踪了所有的指针，任何没有被复制到另一半堆中的东西都是不可及的，并被忽略。在这一点上，一旦它复制了所有的东西，它就会重新启动程序，但分配是从另一半堆内存中运行的，这一半堆是它刚刚复制了所有的活数据，"To Space"**】The garbage collector stops the execution of the program, and makes a pass through the active half of the heap, the half of the heap you were just allocating from. It passes linearly through that, through the heap, based on the root set of the program, and any live objects it finds, it copies into the other half of the heap. So it identifies the root set, based on the global variables and the stack, the variables on the stack frames, and follows the pointers from those into the heap. And any of those objects it adds to this to the unused half, what’s called the “to space”, the other half of the heap. It follows all the pointers, adding them into the heap in order. So it moves them into a contiguous region of the other half of the heap memory. It uses an algorithm known as the Cheney algorithm to do that. And once it's followed all of the pointers, anything which has not been copied into the other half of the heap is unreachable, and gets ignored. At that point, once it's copied everything over, it restarts the program, but with allocations running from the other half of the heap memory, the half of the heap towards it just copied the all of the live data, the “to space”.
  - 在活动空间中进行一次传递，所有活着的对象被复制到堆的另一半。•	A pass is made through the active space, and all live objects are copied to the other half of the heap
    - 通常使用Cheney算法来进行单次拷贝。•	Cheney algorithm is commonly used to make the copy in a single pass
    - 任何没有被复制的东西都是不可及的，并被简单地忽略（并且最终会被后来的分配阶段所覆盖）•	Anything not copied is unreachable, and is simply ignored (and will eventually be overwritten by a later allocation phase)
- 【**然后，哪一半的堆是活跃的，就切换到哪一半的堆，它就会运行，像正常一样，在另一半的堆内存中以连续的模式进行分配。因此，从本质上讲，程序只使用一半的堆。它一直使用这个区域，直到它用完了这个区域。然后收集器运行，并复制到另一半内存中，从那里进行分配。然后，一旦内存满了，收集器就会再次运行，并将其翻转回来。因此，它只是一次使用了一半的可用堆内存。所以它浪费了一半的内存。但是当收集器运行时，它只需要把活的对象复制到另一边，然后继续。它在两半的内存之间翻来覆去**。】 And which half of the heap is then active is just switched over, and it runs, and it carries on as normal, allocating in a contiguous pattern in the other half of the heap memory. So, essentially, the program only uses half of the heap. And it uses that until it run all the way through, and used that region. And then the collector runs, and it copies into the other half of the memory, allocates from there. And then, once it's full, the collector runs again and it flips back. So it's only ever using half of the available heap memory at once. So it's wasting half of the memory. But when the collector runs, it just has to copy the live objects to the other side, and carries on. It flips around between the two halves of the memory.
  - 然后，程序被重新启动，使用堆的另一半作为活动分配区域•	The program is then restarted, using the other half of the heap as the active allocation region
  - 每次触发收集时，堆的两部分（两个半空间）的角色都会颠倒过来•	The role of the two parts of the heap (the two semispaces) reverses each time a collection is triggered

# 复制算法-Cheney Algorithm

- Cheney算法：广度优先复制•	The Cheney Algorithm: breadth-first copying
- 【**其原理是，你有一个等待被复制的对象队列。你先看一下对象的根集，全局变量和所有堆栈分配的变量，对于每一个对象，你都把它们推到队列中。然后你从队列的开头开始，从队列中的第一个对象开始，你看看这个对象，看看它是否有指向我们还没有看到的其他对象的指针？如果有，你就把那些被引用的对象推到队列的末端。然后，你把队列头部的对象，标记为已被处理，并把它复制到另一个半空间，到堆的另一半。然后你继续前进，你对队列中的下一个对象这样做，你把它引用的任何东西添加到队列的末端，你把它复制到另一个半空间，如此循环**】The idea of this is that you have a queue of objects waiting to be copied. You start by looking at the root set of objects, the global variables and all the stack allocated variables, and for each of those you push them into the queue. And then you start at the beginning of the queue, with the first object in the queue, and you look at that object and you see does it have pointers to other objects we haven't seen yet? If it does, you push those objects which are referenced on to the end of the queue. Then, you take the object at the head of the queue. you mark it has as having been processed, and you copy it into the other semi-space, into the other half of the heap. And then you move on, you do this for the next object in the queue, and you add anything it references on to the end of the queue, you copy it into the other semi-space and so on
  - 创建一个队列，以容纳要复制的活对象集。•	A queue is created, to hold the set of live objects to be copied
  - 找到由全局变量和所有堆栈分配的变量组成的根对象集，并将其添加到队列中。•	The root set of objects, comprising global variables and all stack allocated variables, is found and added to the queue
- 【**所以你不断地通过这个对象队列，它们引用的任何东西都被添加到队列的末端，你一直在进行，直到最终队列用完。所以你要在队列中赛跑，把队列中的东西拿走，同时在你找到新对象时把它们加到队列的末尾。最终你到达了队列的末端，这意味着你找到了所有活着的对象，你就完成了。所有东西都被复制过来了**。】. So you're continually going through this queue of objects, anything they reference gets added to the end of the queue, and you keep going until eventually run out of the queue. So you’re sort-of racing through the queue, taking things off the head of the queue whilst adding them on to the end as you find new objects. And eventually you reach the end of the queue, that means you found all of the live objects and you're done. And everything has been copied over.
  - 队列中的对象被依次检查。•	Objects in the queue are examined in turn:
    - 它们所引用的任何未处理的对象被添加到队列的末端•	Any unprocessed objects they reference are added to end of the queue
    - 然后，队列中的对象被复制到另一个半空间中，原始对象被标记为已被处理（在复制过程中指针被更新）。•	The object in the queue is then copied into the other semispace, and the original is marked as having been processed (pointers are updated as the copy is made)
  - 一旦到达队列的末端，所有活的对象都被复制了。•	Once the end of the queue is reached, all live objects have been copied

# 复制算法-效率

- **拷贝收集器的效率**。•	Efficiency of copying collectors:
  - 【**收集内存的时间取决于有多少东西被复制了。而这取决于实时对象的数量。唯一被复制的东西是可以从根集到达的对象。唯一被复制的东西是在收集器运行时还活着的对象。死亡对象的数量并不影响性能。而堆的总大小也不影响性能。唯一影响性能的是当前可以访问的对象的集合**】 the time it takes to collect the memory depends on how many things were copied. And that depends on the number of live objects. The only things that get copied are objects which are reachable from the root set. The only things that get copied are objects which are alive at the point when the collector runs. And the number of dead objects doesn't affect the performance. And the total the size of the heap doesn't affect the performance. The only thing that affects the performance is the set of objects which are currently accessible.
    - 垃圾收集所需时间取决于复制的数据量，而数据量又取决于活对象的数量•	Time taken for garbage collection depends on the amount of data copied, which depends on the number of live objects
    - 只有在半空间满的时候才会进行收集•	Collection only happens when a semispace is full

- **如果大多数对象在年轻时就死亡，可以通过增加半空间的大小来权衡收集时间和内存的使用**。•	If most objects die young, can trade-off collection time vs. memory usage by increasing the size of the semispaces 【**如果大多数对象都是早死的，如果大多数对象的寿命都不长，那么在收集器运行的时候就不需要处理它们了。所以你可以通过改变半空间的大小，通过改变分配给系统的内存量，来权衡花在垃圾收集器上的时间**】if most objects die young, if most objects don't live very long, at the point that collector runs it doesn't need to process them. So you can trade-off the amount of time spent on the garbage collector, by changing the size of the semi-spaces, by changing the amount of memory allocated to the system.
  - 【**半空间越大，垃圾收集器的运行频率就越低。如果大多数对象在它运行的时候已经不存在了，那么它就只复制了少量的对象。所以它复制的是一个相当小的集合，而且复制的频率较低，所以垃圾收集器花费的总时间就会减少。所以你可以在系统使用多少内存、堆要多大、半空间要多大、垃圾收集器要运行多长时间之间进行权衡**】The bigger the semi-space, the less often the garbage collector has to run. And if most objects are no longer alive at the point when it runs, it's only copying a small number of objects. So it's copying a fairly small set, and it's copying it less often, so the total amount of time taken for the garbage collector goes down. So you can trade-off between how much memory the system uses, how big the heap has to be, how big the semi spaces have to be, for how long the garbage collector is running.
    - 较大的半空间需要更长的时间来填充，所以增加了对象在被复制前需要的时间。•	A larger semispace takes longer to fill, so increases the how long objects need to live before they’re copied
  - 【**大多数程序都有一组核心的、长寿的对象，这些对象构成了它们的基本数据结构，然后很多短暂的对象只是活了一小段时间，在某个特定的函数完成后就消失了。所以，很多时候，这是一个很好的权衡。通过只复制当前存活的对象，而忽略那些刚刚存活了一段时间的短暂对象，你可以通过使用复制收集器，在收集垃圾的时间上获得相当好的性能**】Most programs have a set of core, of long-lived, objects that comprise their fundamental data structures, and then a lot of ephemeral objects just live for a small amount of time, and disappear after a particular function has finished, for example. So, quite often, this is a good trade-off. By only copying the objects which are currently alive, and ignoring those that have just lived for a little while and are ephemeral, you can get quite a good performance win, in terms of time spent collecting garbage, by using a copying collector.
    - 如果大多数对象都很早死亡，那么大多数对象就不会被复制。•	If most objects die young, most aren’t copied
  - 【**缺点是它使用更多内存。在任何时候，它只使用可用堆内存的一半。你可以给它的内存越多，它在处理器开销方面的性能就越好。因此，您有一个自动内存管理方案，可以权衡未使用、浪费的内存来降低处理器开销。**。】 The disadvantage, though, is it uses more memory. At any point it's only using half of the available heap memory. And the more memory you can give it, the better it performs in terms of processor overhead. So you have an automatic memory management scheme that trades-off unused, wasted, memory for low processor overhead.
    - 使用更多的内存，但花在复制数据上的时间更少•	Uses more memory, but spends less time copying data

# Summary-基本垃圾回收

- Mark-sweep、mark-compact和复制收集器的成本相似。•	Mark-sweep, mark-compact, and copying collectors have similar cost:
  - 【它们的不同之处在于成本所在。当内存分配发生时，它们是否花费时间，】
    - 成本的支付方式不同：**是在分配的时候还是在收集的时候；是在内存的使用上还是在处理时间上**。•	Differ in where the cost is paid: at time of allocation or time of collection; in memory usage or in processing time
  - 【就像标记扫描算法一样，因为它必须在空闲列表中搜索并找到一个适当大小的空间来放置对象，所以它们分配内存的开销可能相当高】like a mark sweep algorithm, because it has to search through the free list and find an appropriate sized space to put the object, so they can have quite a high overhead to allocate memory
  - 【像标记压缩，尤其是复制收集器，有一个更复杂的收集算法，他们必须复制其中一些对象，但从快速分配内存中获益？因此，他们正在权衡内存使用以换取处理时间。】 like the mark compact, and especially the copying collectors, have a more complex collection algorithm, where they have to copy some of these objects around, but gain from making memory allocation very fast? So, they’re trading-off memory usage for processing time.  
  - 【其中一些算法，标记扫描，有较少的内存开销，但在处理时间方面，收集器的时间，在分配时间方面，以及在参考的地方性方面都很差。】And some of these algorithms, mark sweep, has less memory overhead, but it's bad in terms of processing time, time for the collector, in terms of allocation time, and in terms of poor locality of reference.

- mark-compact和copy算法会移动数据，所以不能用于不能明确识别指针的语言。•	The mark-compact and copying algorithms move data, so cannot be used with languages that cannot unambiguously identify pointers
  - 【而**复制收集器有很好的定位参考，它们非常高效，但它们浪费了大量的内存。所以你要在不同的目的之间进行权衡。标记扫描算法不移动内存，所以它可以在任何语言中工作。标记压缩算法和复制算法会移动数据，所以它们需要能够明确地识别指针，并更新被移动对象的指针**。】Whereas the copying collectors have very good locality of reference, they're very efficient, but they waste a lot of memory. So you have this trade-off between the difference purposes. The mark sweep algorithm doesn't move memory around, so it can work in any language. The mark compact, and the copying algorithms, move data, so they need to be able to unambiguously identify pointers, and update the pointers to the objects which had been moved.
    - 如果你不能确定一个对象的所有指针都已更新，就不能移动该对象•	Can’t move an object, if you can’t be sure all pointers to it have been updated
 
# ===============

# 2分代和增量垃圾收集：Generational and Incremental Garbage Collection

讲座的第二部分展示了如何在考虑到典型对象寿命的情况下改进复制垃圾收集算法，以产生广泛使用的分代垃圾收集算法。然后，它讨论了如何反过来增强分代算法以支持增量操作，从而减少程序的停顿时间。The second part of the lecture shows how copying garbage collection algorithms can be improved, taking into account typical object lifetimes, to produce the widely used generation garbage collection algorithm. Then, it discusses how generation algorithms can, in turn, be enhance to support incremental operations that reduces the pause times for the program.


# 对象生命周期：Object Lifetimes

- 【**需要被垃圾收集的对象能活多久呢？人们对很多程序做了研究，似乎大多数时候，程序中的大多数对象实际上都有相当短的寿命。有一个核心对象的寿命很长，在程序的持续时间中占了相当大的比例，它们构成了程序所使用的主要数据结构。然后，在大多数情况下，有大量的短暂对象出现，在一个特定的函数、一个特定的方法或一个特定的对象的生命周期内被处理，然后它们很快死亡，然后就不再被引用了。而这似乎是普遍真实的。人们在一系列不同的语言和不同领域的程序中做了研究，并且在很长一段时间内，同样的统计数字似乎一次又一次地出现了。大多数对象的寿命很短，但有一个核心的对象寿命非常长。现在，显然不同的程序，不同的编程语言，会产生不同数量的垃圾，但这个原则似乎是成立的**】how long do the objects that need to be garbage collected live?people have done studies of a lot of programs, and it seems that most of the time, most of the objects in the programs actually have a fairly short lifetime. There’s a core of objects that are long lived, that live for a significant fraction of the duration of the program, and that comprise the main data structure that the program is working with. And then, in most cases, there are a large number of ephemeral objects which come into being, are processed during the lifetime of a particular function, or a particular method, or a particular object, and then which die fairly quickly, and then are no longer referenced. And this seems to be generally true. People have done studies in a range of different languages, and programs in a range of different domains, and over a long time period, and the same statistic seems to be popping up again and again. Most objects live for a very short time, but there's a core of very long lived objects. Now, obviously different programs, different programming languages, produce different amounts of garbage, but the principle seems to hold.
  - 大多数对象的时间很短；一小部分对象的寿命更长•	Most objects have short time; a small percentage live much longer
    - 在众多研究中，无论考虑哪种编程语言，这似乎都是真实的。•	This seems to be generally true, no matter what programming language is considered, across numerous studies
    - 虽然，很明显，不同的程序和不同的语言产生不同数量的垃圾。•	Although, obviously, different programs and different languages produce varying amount of garbage

- 意义。•	Implications:【当涉及到构建垃圾收集器时，这有一些影响】
  - 【**首先是，当垃圾收集器运行时，活着的对象很可能是少数。会有相对较少的对象，它们已经存在了很长时间，构成了程序正在处理的核心数据。还有一些对象已经被创建，并在上一轮收集器之后被用于某种目的，现在已经无法访问了。而且，垃圾收集器所查看的大多数对象都不再是可触及的了**】The first is that, when the garbage collector runs, it's likely that live objects will be a minority. There'll be a relatively small number of objects which have been around for a long time that comprise the core data that the program is working on. And there'll be a bunch of objects that have been created, used for some purpose since the last round of the collector, and are now no longer reachable. And that the majority of objects that the garbage collector is looking at won't be any more reachable.
    - 当垃圾收集器运行时，活着的对象将是少数。•	When the garbage collector runs, live objects will be in a minority
  - 【**一个对象活得越久，它就可能活得越久。如果一个对象成为系统工作的核心数据的一部分，它就有可能在程序的大部分生命周期内存活，而如果它不是，它就有可能很快死亡。任何能在相当长的时间内存活的东西，任何能在垃圾收集器的几次运行中存活的东西，都可能是那些长寿的对象之一。对物要么死得很快，要么活得很久，没有那么多有中间寿命的对象**】 It also seems likely that the longer an object has lived, the longer it's likely to live. If an object becomes part of the core data on which the system is working, it’s likely to live for most of the lifetime of a program, whereas if it isn’t, it's likely to die very quickly. And anything which survives for a significant fraction of time, anything that lives for more than a couple of runs of the garbage collector, is likely to be one of those long lived objects. Things either die very quickly, or they live for a very long time, and there’s not so many objects that have intermediate lifetimes.
    - 据统计，一个对象存活越久，它越可能存活 •	Statistically, the longer an object has lived, the longer it is likely to live
  - 我们可以设计一个垃圾收集器来利用这个优势吗？【让它了解大多数对象寿命都短，并因此而优化它的行为？】•	Can we design a garbage collector to take advantage?

# 分代复制算法：Copying Generational Collectors

它试图根据对象寿命的统计数据来优化垃圾收集

![](/static/2022-05-06-22-27-32.png)

- 【**在典型的分代垃圾收集器中，堆被分割成两个区域。一个区域是长寿命对象，一个区域是短寿命、年轻的对象。存放年轻对象的区域被频繁地收集垃圾，而存放较老的、长寿的对象的区域则被较少地收集，因为假设这些对象喜欢保持较长的寿命。当这些对象很可能是长寿的，很可能有很长的寿命时，这些对象就会在各个区域之间移动。这通常被描述为两代：年轻代和老年代**】 In your typical generational garbage collector, the heap is split into two regions. One region for long lived objects, and one region for short lived, young, objects. And the regions holding the young objects are garbage collected quite frequently, whereas the regions holding the older, long-lived, objects are collected less frequently, on the assumption those objects like to stay alive longer. And objects are moved between the regions as it becomes clear that those objects are likely to be long lived, are likely to have a long lifetime. And the way this is typically described is with two generations: a young generation, and a long lived older generation.
  - 在分代垃圾收集器中，堆被分割成老年对象和年轻对象的区域。•	In a generational garbage collector, the heap is split into regions for long-lived and young objects
    - 持有年轻对象的区域被更频繁地收集垃圾。•	Regions holding young objects are garbage collected more frequently
    - 如果对象在多次收集后仍然存活，则被移到长寿对象的区域。•	Objects are moved to the region for long-lived objects if they’re still alive after several collections
- 【但是，当然，你没有理由不把它分成多代，如果你想的话，可以有年轻一代、中年一代和长寿一代，**尽管一旦你超过两代，多代的好处就会减少**】 But, of course, there's no reason you can't split it into multiple generations, and have a young, a middle aged, and a long lived generation if you want, although the benefits of multiple generations go down once you more than two
  - 更复杂的方法可能有多代，尽管**随着代数的增加，收益会迅速减少**。•	More sophisticated approaches may have multiple generations, although the gains diminish rapidly with increasing numbers of generations

- 例子：使用两代半空间的stop-and-copy •	Example: stop-and-copy using semispaces with two generations 【**一个典型的方法是，使用半空间的两代进行所谓的停止和复制算法**】
  - 【**这实质上是在运行我们在上一部分描述的复制收集器的两个实例，一个用于管理每一代。其工作方式是，最初，一切都以年轻对象开始。堆被划分为两个区域，一个是年轻对象，另一个是长期存在的对象。最初所有的对象都是从堆的年轻一代区域分配的。这两个区域中的每一个，即年轻对象的区域和长寿对象的区域，又被分成了两个。所以我们把堆分成了四分之一**】This is essentially running two instances of the copying collector we described in the last part, one to manage each generation. The way this works is, initially, everything starts as a young object. And the heap is partitioned into two regions, one for young objects, and one for long lived objects. And initially all the objects are allocated from the younger generation region of the heap. Each of those two regions, that for young objects, and that for long lived objects, is in turn split into two. So we've divided the heap into quarters.
  - 【**这些区域中的每一个都是用一个复制收集器来管理的。所以，在分配给年轻一代的空间中，我们最初使用该空间的一半，然后，当这一半被填满时，我们做通常的复制收集器的事情，将其复制到另一半空间中，并释放任何没有被复制的东西。因此，分配最初是在堆的年轻一代区域开始的。它们从该区域的初始半空间开始，并且以复制收集器的通常方式线性分配内存。当该区域变满时，像往常一样进行垃圾回收**。】 And each of those regions is managed using a copying collector. So, in the space allocated for the younger generation we're using half of that space initially, and then, when that half gets full, we do the usual copying collector thing of copying across into the other half of the space, and freeing up anything which wasn't copied. So allocations initially start in the younger generation’s region of the heap. They start in the initial semi-space for that region, and memory is allocated linearly in the usual way for a copying collector. When that region becomes full, a garbage collection happens as usual.
    - 所有的分配都发生在堆的年轻一代的区域内•	All allocations occurs in the younger generation’s region of the heap
    - 当该区域满了，收集就会正常进行•	When that region is full, collection occurs as normal

# 分代复制-原理

![](/static/2022-05-06-22-27-32.png)

![](/static/2022-05-06-22-28-05.png)

- 【**像往常一样，对于一个复制收集器来说，它穿过堆，任何仍然活着的东西都会被复制到年轻区域的另一半半空间里。不过，这里的补充是，在复制对象时，它会给它们打上标签，标明它们被成功复制了多少次。因此，如果一个对象在最初的垃圾收集中幸存下来，并被复制到半空间的最初一半，那么它已经存活了多少次的计数器就会递增1。而这个过程在分配给年轻一代的空间中继续进行，通常的复制收集器在半空间的两半之间翻转，每次收集时都是如此。存活超过一定数量的垃圾收集周期的对象，可能小到一个或两个周期，被认为是长寿的对象。所以，如果它们在某个阈值的收集次数之后还活着，它们就被认为是长寿的对象，当收集器下次运行时，不是复制到年轻一代半空间的另一半，而是复制到老一代的空间中**】 as usual, with a copying collector, it passes through the heap and anything which is still alive gets copied over to the other half of the semi-space for the young region. The addition here, though, is that as it’s copying the objects, it tags them with how many times they’ve successfully been copied. So, if an object survives the initial garbage collection, and gets copied into the initial half of the semi space, the counter for how many times it has lived is incremented by one. And this process continues in the space allocated for the younger generation, with the usual copying collector flipping between the two halves of the semi-space, each time it collects. Objects that survive more than a certain number of garbage collection cycles, and that may be as small as one or two cycles, are assumed to be long lived objects. So, if they're alive after, if they survived some threshold number of collections, they’re assumed to be long lived objects, and when the collector next runs, rather than copying into the other half of the younger generation semi-space, they’re copied into the space for the older generation.
  - 物体被标记为它们已经存活的年轻一代的收集次数；如果它们在某个阈值之后仍然存活，则在收集过程中被复制到老一代的空间。•	Objects are tagged with the number of collections of the younger generation they have survived; if they’re alive after some threshold, they’re copied to the older generation’s space during collection
- 【**这个过程继续下去，最终老一代的空间变得很满，因为越来越多的对象被复制到其中。这时，老一代的空间就会被垃圾回收**】And, And this process continues, and eventually the space for the older generation becomes full, as more and more objects that copied into it. And that point the older generation space is garbage collected.
  - 最终，老一代的空间被填满，并被正常收集。•	Eventually, the older generation’s space is full, and is collected as normal
- 【遵循你所期望的复制收集器的通常方法，**它占用老一代空间的一半，将活的对象复制到另一半，并删除老一代中任何未引用的对象。我们看到的是，年轻一代的收集非常频繁，而且有很多，有很多短命的对象，所以空间往往很快就会被填满。而年轻一代在这个半空间的两半之间跳动得很快**】that follows the usual approach you'd expect with a copying collector, and it takes that half of the older generation space, copies the live objects into the other half, and deallocates any unreferenced objects in the older generation. What we see is that the younger generations are collected very frequently, and there’s a lot, there's a lot of short lived objects, so that space tends to fill up quite quickly. And the younger generation is bouncing between the two halves of that semi-space quite quickly.
- 【**更慢的是，对象被复制到老一代的空间中，最终会被填满，并在那里进行收集。正如左边的图所示，我们看到年轻一代在其空间的两半之间反复跳动，然后老一代逐渐填满，最终被复制。而且，这张图的画法，看起来年轻一代和年长一代都拥有一半的堆，并且拥有同等数量的内存。在实践中，老一代可能比年轻一代需要更少的空间，因为往往有更多的短命对象，所以你可以调整不同区域的大小来匹配**。】much more slowly, objects get copied into the older generation space, and eventually that will fill up and collection will be performed there. And, as the diagram on the left shows, we see the young generation repeatedly bouncing around between the two halves of its space, and then the older generation gradually filling up and eventually being copied. And, the way this diagram is drawn, it looks like the younger generation and the older generation both have half of the heap, and have equal amounts of memory. In practice, the older generation probably needs less space than the younger generation, as there tend to be a lot more short lived objects, so you might adjust the size of the different regions to match.
  - 注：不按比例：老一代通常比年轻一代大得多，因为他们被收集的次数少得多。•	Note: not to scale: older generations are generally much larger than the younger, as they’re collected much less often

# 分代复制-引用问题

- 【现在，年轻一代和老一代必须独立收集。短命的对象被收集，而且比长命的对象要频繁得多】年轻的一代必须独立于长寿的一代而收集。•	Young generation must collected independent of long-lived generation
- 但是--各代之间可能存在引用•	But – there may be references between generations 【但是，也有可能在不同的世代之间存在着引用。可能有一些年轻的对象，短命的对象，持有对长命的对象的引用，也可能有长命的对象，持有对年轻的、短命的对象的引用 But it's also possible that there are references between the different generations. There may be young objects that, short lived objects that, hold references to long-lived objects, and there might be long lived objects that hold references to young, short-lived, objects. 】
  - 【**从短命的对象到长命的对象的引用是很直接的。大多数时候，短命的对象会在长命的对象被收集之前死亡；大多数时候，它甚至会在年轻一代的垃圾收集进行之前死亡。所以，如果确实发生了对长寿一代的收集计划，那么把年轻一代作为长寿一代的根集的一部分来处理就足够了。在年轻一代中不会有太多的活对象，所以如果你只是扫描年轻一代，找到所有这些对象，并把它们当作根集，然后它们会引用到长寿对象中**】References from short-lived objects to long-lived objects is straightforward. Most of the time, the short-lived object is going to die before the long-lived object is collected; most of the time it's even going to die before the garbage collection of the younger generation is performed. So, if it does happen that a collection of the long-lived generation is scheduled, then it's probably sufficient to treat the young generation as part of the root set for the long-lived generation. There won’t be too many live objects in the younger generation, so if you just scan through the young generation, find all of those objects, and treat them as the root set, and then they will reference into the long lived objects.
    - 从年轻对象到长寿对象的引用•	References from young objects to long-lived objects
      - 直截了当--大多数年轻对象在长寿对象被收集之前就死亡了•	Straight-forward – most young objects die before the long-lived objects are collected
      - 当需要收集长寿一代时，将年轻一代的对象作为长寿一代的根集的一部分。•	Treat the younger generation objects as part of the root set for the long-lived generation, when collection of the long-lived generation is needed
  - 从长寿对象到年轻对象的引用。•	References from long-lived objects to young objects:
    - 【 **从长寿对象到年轻对象的引用更有问题。这里的问题是，很明显，你需要扫描堆中分配给长寿对象的部分，以便发现这些对象，但是代际收集的好处来自于将堆的两个区域分离出来，这样你就不需要进行这样的扫描了。如果你要扫描整个堆来找到从长寿命对象到短寿命对象的引用，你就失去了做世代收集的很多好处**】 References from long-lived objects to younger objects more problematic. The issue here is that, obviously, you need to scan the portion of the heap allocated for the long lived objects in order to detect those, but the benefit of the generational collection comes from separating the two regions of the heap out, such that you don't need to perform such scans. If you're going to scan the whole heap to find the references from long-lived to short-lived objects, you've lost a lot of the benefits of doing the generational collection.
      - 有问题，因为需要扫描长生命周期的一代来检测•	Problematic, since requires scan of long-lived generation to detect
    - 【**因此，经常发生的情况是，从长寿命对象到短寿命对象的指针是用一个指示表完成的。长存对象指向一个区域，即所谓的中介表，这个区域保存着对短存对象的引用，所以它们是指向指针的指针，而长存代中的指针只是普通的指针**】 Quite often, therefore, what happens is that pointers from long-lived to short-lived objects are done using an indirection table. The long-lived objects points to a region, known as the indirection table, a region that holds references to short-lived objects, so they’re pointers to pointers, whereas pointers within the long-lived generation are just regular pointers
      - 也许可以使用指示表（"指针到指针"）来处理从长寿一代到年轻一代的引用。•	Maybe use indirection table (“pointers-to-pointers”) for references from long-lived generation to young generation
      - 【**这里的想法是，当你对年轻一代进行垃圾收集时，你把指示表当作年轻一代的根集的一部分，你不必扫描堆的其他部分。你只需明确地查看从长寿命对象到短寿命对象的已知指针。这也是一个好处，因为显然短命的一代被更频繁地收集垃圾，所以这些对象在年轻一代半空间的两半之间移动得相当频繁，这意味着，如果有从长命对象到短命对象的引用，你需要经常更新这些引用，因为这些对象经常被复制。而将这些引用放在一个间接表里，意味着你不必为了更新引用而去扫描整个长寿世代的堆。这往往不是一个大问题。长寿命对象引用短寿命对象的情况并不常见。在很多代码中，反过来的情况更为常见**。】And the idea here is that when you’re garbage collecting the young generation, you treat the indirection table as part of the root set of the younger generation, and you don't have to scan the rest of the heap. You only explicitly look at known pointers from long-lived objects to short-lived objects. This is also a benefit because obviously the short-lived generation gets garbage collected much more frequently, so those objects move between the two halves of the young generation semi-space quite frequently, which means that, if there are references from long lived objects to short-lived objects, you need to update those references quite often, as the objects are frequently copied around. And having those references in an indirection table means you don't have to scan the whole of long-lived generation’s heap in order to update the references as well. This tends not to be a big issue. It’s not particularly common for long-lived objects to refer to short-lived objects. It’s much more common for them to be the other way around in a lot of code.
        - 指向表是年轻一代的根集的一部分•	The indirection table forms part of the root set of the younger generation
        - 在年轻代中移动对象需要更新间接表，但不需要更新长寿命对象 。•	Moving objects in younger generation requires updating indirection table, but not long-lived objects
        - 长寿命的对象很少被收集，并且可能使年轻对象的存活时间比预期的要长。•	Long-lived objects are collected infrequently, and may keep younger objects alive longer than expected

# 分代复制-效率summary

- 分代复制收集器的变种被广泛使用•	Variations on copying generational collectors are widely used
  - 例如，HotSpot JVM使用代际垃圾收集器。•	E.g., the HotSpot JVM uses a generational garbage collector

- 复制生成的收集器是高效的。•	Copying generational collectors are efficient:【**就处理器的开销而言，它可以是非常有效的**】
  - 【**复制生成的收集器的成本取决于活对象的数量。而大多数对象都是短命的一代，大多数对象都是早死的，所以它经常对短命的一代进行垃圾收集，但通常每次都不会复制很多对象，因为大多数对象的寿命都不是很长。所以这样做并没有多少处理器的开销，而那些确实活了很久，需要反复复制的对象，是在长寿的一代，这一代并不经常被垃圾收集，所以复制它们的开销很小**】The cost of a copying generational collector depends on the number of live objects. And most objects are in the short-lived generation, most objects die young, and so it's frequently garbage collecting the short-lived generation, but it's typically not copying many objects each time, because most of the objects haven't lived very long. So there's not much processor overhead in doing that, and the objects which do live for a long time, and which would need to be repeatedly copied, are in the long-lived generation, and that's not garbage collected particularly often, and so the overhead of copying them is small.
    - 收集的成本通常与活对象的数量成正比•	Cost of collection is generally proportional to number of live objects
    - 大多数对象的寿命不足以被收集；那些被收集的对象会被转移到更少被收集的一代。•	Most objects don’t live long enough to be collected; those that do are moved to a more rarely collected generation
  - 寿命较长的一代最终必须被收集；这可能是非常缓慢的•	Longer-lived generation must eventually be collected; this can be very slow 【**尽管当它确实需要对长寿命的一代进行垃圾收集时，这可能是相当慢的**】
- 【但是，**成本是在内存方面。它将堆分成四个区域，并且一次只使用每个区域的一半，因此内存开销相当高。使用分代复制收集器时，它在任何时候都有大量未使用的内存。因此，它以低处理器开销换取高内存开销**。】The cost, though, is in terms of memory. It’s split the heap in into four regions, and it's only using half of each region at once, so there's quite a high memory overhead. It's got a lot of unused memory at any one point with a copying generational collector. So it’s trading off low processor overhead for high memory overheads.

# 增量垃圾回收：Incremental Garbage Collection

- 前面的讨论假设收集器在运行时 "停止世界"。•	Preceding discussion has assumed the collector “stops-the-world” when it runs 【**因此，正如我们所看到的，分代收集器可以是非常有效的。但是，它在运行的时候会停止世界，通常这不是一个大问题，因为它只是在为年轻的一代，即短命的一代收集堆，而这发生得相当快。但是，偶尔它需要为长寿命的一代收集堆，这可能涉及到扫描合理数量的空间，复制大量的长寿命对象，这可能是相当慢的**】So, as we saw, a generation collector can be very efficient. But, it stops the world while it runs. And often that's not a big problem. Often that's not a big problem, because it is just collecting the heap for the younger generation, the short-lived generation, and that happens quite quickly. But occasionally it needs to collect the heap for the long-lived generation, and that can involve scanning a reasonable amount of space, copying a lot of long-lived objects, and that can be quite slow. 
  - 【**增量式垃圾收集算法试图将垃圾收集的成本分散。他们试图以一种程序不需要停止以允许收集器运行的方式运行垃圾收集。这对交互式应用是有益的，你不希望出现影响用户行为的暂停，或者是用户可见的暂停，这对实时应用也很重要。例如，如果你正在构建一个视频会议工具，在一个垃圾收集语言中，你会希望约束收集器的运行时间，这样就不会干扰视频的渲染了。而且，如果你用这样的语言建立一个实时控制系统，你会想知道收集器在系统的每个超时期运行了多长时间，这样你就可以安排实时任务以满足所有的最后期限。因此，有一个可以增量运行的垃圾收集器会很有用**】Incremental garbage collection algorithms try to spread the cost of garbage collection out. They try to run the garbage collection in a way that the program doesn't need to be stopped to allow the collector to run. And this is beneficial for interactive applications, where you don't want a pause which would affect user behaviour, or be user visible, and it's important for real-time applications. If you're building a video conferencing tool, for example, in a garbage collected language you’d, want to bound the time the collector runs so that doesn't disrupt the rendering of the video. And, if you're building a real-time control system in such a language, you'd want to know how long that the collector was running, for each hyper period of the system, so you can schedule real-time tasks to meet all their deadlines. So it'd be useful to have a garbage collector that could operate incrementally
    - 对于交互式或实时的应用程序来说是有问题的•	Problematic for interactive or real-time applications
- 希望有一个可以逐步运行的收集器•	Desire a collector that can operate incrementally
  - 【**如果有一个垃圾收集器可以将少量的垃圾收集与程序执行的小规模运行交织在一起，那就很有用了。因此，与其让程序运行一段时间，然后暂停它，扫描整个堆，或在一代收集器中扫描整个堆，这必然需要很长的时间，不如有一个收集器，可以收集堆的一小部分。这需要非常小的运行时间，所以它可以将收集的执行分散开来，与程序的操作交错进行，每次执行一些指针操作，或每次进入或退出一个方法，或类似的东西，只是为了将成本大大分散。这样做的含义是，垃圾收集器不能扫描整个堆。如果你允许收集器扫描整个堆，它需要大量的时间，并要求你在它扫描时停止程序。如果你想让收集器运行得更快，它只需要扫描堆的一部分，它只有时间扫描堆的一部分。所以它每次都要扫描堆的一个片段**】It’d be useful to have a garbage collector that could interleave small amounts of garbage collection, along with small runs of the program execution. So, rather than letting the program run for a while, and then pausing it, scanning the whole heap, or the whole of one generation of the heap in a generational collector, which necessarily takes a long time, it would be useful to have a collector that could collect a small portion of the heap. That takes a very small amount of time to run, so it can spread the execution of the collection out and interleave it with the operation of the program, every time it performs some pointer operation, or every time it enters or exits a method, or something like that, just to spread the cost out significantly. The implication of that, is that the garbage collector can't scan the whole heap. If you allow the collector to scan the heap, it takes a significant amount of time, and requires you to stop the program while it does it. If you want the collector to run much more quickly, it only has the scan part of the heap, it’s only got time to scan parts of the heap. So it's got a scan a fragment of the heap each time
    - 将少量的垃圾收集与少量的程序执行交错进行•	Interleave small amounts of garbage collection with small runs of program execution
    - 意味着：垃圾收集器不能在运行时扫描整个堆；每次必须扫描堆的一个片段•	Implication: the garbage collector can’t scan the entire heap when it runs; must scan a fragment of the heap each time
  - 【**问题是，如果收集器只扫描堆的一部分，那么当程序运行时它可能会改变一些东西，而收集器会在收集器运行之间改变堆。所以你需要某种方式来协调垃圾收集器正在做什么和程序正在做什么。收集器无法停止程序并扫过整个堆，将对象标记为活动或死亡，因为当您在中途暂停收集器时，程序运行并废弃标记。所以你需要一些跟踪变化的方法，这样当程序运行时收集器也在运行，它们可以协调。**。】The problem is, if the collector is only scanning part of the heap, then there’s the risk that when the program runs it will change something, while the collector, it will change the heap between the runs up the collector. And so you need some way of coordinating what the garbage collector is doing and what the program is doing. The collector can't stop the program and sweep through the whole heap, marking the objects as alive or dead because, when you pause the collector partway through, the program runs and it obsoletes the marking. So you need some way of keeping track of changes, so as the program runs while the collector is also running, they can coordinate.
    - 问题：程序（"突变器"）可以在垃圾收集器的运行之间改变堆。•	Problem: the program (the “mutator”) can change the heap between runs of the garbage collector
      - 需要跟踪在垃圾收集器运行之间对堆所做的改变；保守一点，不要收集可能被引用的对象--总是可以在下一次完整的扫描中收集。•	Need to track changes made to the heap between garbage collector runs; be conservative and don’t collect objects that might be referenced – can always collect on the next complete scan

# 增量垃圾回收-原理

- 【**这种方式往往是使用一种被称为三色标记的算法。系统中的每个对象都被标记为一种颜色。对象的颜色会随着收集器的运行而改变。对象可以被标记为白色，这表明垃圾收集器在这个周期内还没有查看过它们。它们可以被标记为灰色，这表明垃圾收集器已经看了它们，它知道这个对象是活的，但它还没有检查这个对象的一些直接子对象。或者，它们可以被标记为黑色，这表明该对象是活的，而且它的所有直接子对象都被检查过了**】The way this tends to be done is using an algorithm known as tri-colour marking. Every object in the system is labeled with a colour. And the colour of the object is changed as the collector runs. Objects can be marked as white, which indicates that the garbage collector hasn't looked at them yet in this cycle. They can be marked as grey, which indicates that the garbage collector has looked at them, and it knows that object is alive, but it hasn't yet checked some of the direct children of that object. Or they can be marked as black, which indicates that the object is alive, and all of its directs children have been checked. 
  - 三色标记：每个对象都标有颜色。•	Tricolour marking: each object is labelled with a colour:
  - 白色--尚未检查•	White – not yet checked
  - 灰色--活着，但有些直接的孩子还没有被检查出来•	Grey	– live, but some direct children not yet checked
  - 黑色--活的•	Black – live

基本的增量收集器操作。•	Basic incremental collector operation:

- 【**因此，增量式垃圾收集器的基本工作方式是，它扫描整个堆。而且，当它走的时候，它标记，它改变对象的颜色。当它开始看一个对象时，它标记为灰色。然后它检查引用，并将其标记为灰色，一旦它引用的对象被检查过，它就将初始对象标记为黑色。而且，有一种波浪线在堆中扫过，白色的对象在前面，灰色的对象在波浪线的头，在被检查的区域的头，而黑色的对象在后面，已知是活着的**】The basic way the incremental garbage collector works, therefore, is that it scans through the heap. And, as it goes, it marks, it changes the colour of the objects. As it starts to look at an object, it marks grey. And then it checks the references, and marks them grey, and once the objects it references have been checked, it marks the initial object as black.And, there’s a sort of wavefront sweeping through the heap, with white objects ahead of it, grey objects at the head of the wavefront, at the head of the region that's being checked, and black objects behind which are known to be alive.
  - 垃圾收集以灰色对象的波阵进行，收集器正在检查它们或它们引用的对象是否有效。•	Garbage collection proceeds with a wavefront of grey objects, where the collector is checking them, or objects they reference, for liveness
  - 后面的黑色对象在波阵后面，已知是活的。•	Black objects behind are behind the wavefront, and are known to be live
- 【**最终，收集器将到达堆的末端。它将会穿过整个堆，在这一点上，任何仍然被标记为白色的、还没有被收集器发现的东西，都是不可触及的，都是已知的垃圾**】 And, eventually, the collector will reach the end of the heap. It will have passed through the whole of the heap, and at that point anything which is still labeled white, which hasn't been found by the collector, is unreachable and is known to be garbage. 
  - 在波阵前面的对象，还没有被收集器到达，是白色的；一旦所有对象都被追踪到，仍然是白色的东西就是垃圾了•	Objects ahead of the wavefront, not yet reached by the collection, are white; anything still white once all objects have been traced is garbage
- 【**其中一个关键的不变因素是，不可能从一个黑色对象得到一个直接指向白色对象的指针。最初，在堆被扫描之前，所有的对象都是白色的，它们之间有相互的指针，所以你有从白色对象到白色对象的指针。在堆中已经被检查过的部分，并且已知是活的，你有黑色的对象，它们引用其他活的黑色对象。而在波前，你有一些刚刚从白色染成灰色的对象，表明它们可能被检查。这些灰色的对象可能参考了一些已知是活的对象，它们可能参考了一些尚未被检查的对象，颜色是白色的。在那个灰色区域，在收集发生时的波前，你可以有指向黑色或白色对象的指针。但是在尚未检查的区域，或者已经检查的区域，你知道所有的对象都有指向相同颜色对象的指针。而这就是不变性。任何试图创建一个从黑色对象到白色对象的直接指针的程序操作都需要与垃圾收集器协调。**】One of the key invariants is that it's not possible to get a direct pointer from a black object to a white object. Initially, before the heap has been scanned, all the objects are coloured white, and they have pointers to each other, so you have pointers from white objects to white objects. In the part of the heap that has been checked, and is known to be alive, you have black objects which reference other live black objects. And at the wave front, you have objects which were just coloured from white to grey indicating that they may be checked. Add those grey objects may be referencing some objects which are known to be alive, and they may be referencing some objects which are not yet checked and are coloured white. At that grey region, in the wavefront when the collection is happening, you can have pointers to either black or white objects. But in the region that’s not yet checked, or the region that has been checked, you know that all the objects have pointers to the same colour objects. And this is the invariant. Any program operation that tries to create a direct pointer from a black object to a white object requires coordination with the garbage collector.
  - 没有从黑色对象到白色对象的直接指针--任何会创建这种指针的程序操作都需要与收集器协调。•	No direct pointers from black objects to white – any program operation that will create such a pointer requires coordination with the collector

---

程序和收集器必须协调•	Program and collector must coordinate

![](/static/2022-05-06-23-12-56.png)

- 垃圾收集器运行•	Garbage collector runs
  - 【**所以程序和收集器需要协调。程序运行了一段时间，产生了一些垃圾，暂停以允许部分垃圾收集扫描，然后垃圾收集器运行。在这种情况下，如果我们看一下图中的前面部分，对象A已经被扫描过了，而且已知是活的，因此被标记为黑色。对象B和C可以通过该对象到达，垃圾收集器已经找到了它们，但是还没有检查它们所有的子对象，因此，它将这些对象标记为灰色。而对象D，以及B所引用的其他对象，还没有被检查。所以，垃圾收集器一直在运行，并且已经标记了这些对象。然后垃圾收集器就暂停了**】So the program and the collector need to coordinate. The program runs for a while, generates some garbage, is paused to allow part of the garbage collection scan, and the garbage collector runs. In this case, if we look at the before portion of the diagram, object A has been scanned, and is known to be alive, and therefore is marked as black. Objects B and C are reachable via that object, and the garbage collector has found them but has not yet checked all of their children, therefore, it has marked those objects as grey. And object D, and the other object referenced by B, have not yet been checked. So the garbage collector has been running, and has marked these objects. And then the garbage collector is paused.
    - 对象A被扫描，已知是活的→黑色•	Object A scanned, known to be live → black
    - 对象B和C可以通过A到达，并且是活的，但是它们的一些子对象没有被扫描→灰色•	Objects B and C are reachable via A, and are live, but some of their children have not been scanned → grey
    - 对象D未被检查→白色•	Object D not checked → white
- 【**这是一个增量算法，它将收集器和程序的操作交错进行。因此，垃圾收集器暂停，程序运行，并改变了一些指针的位置。它交换了从对象A指向对象C的指针，以及从对象B指向对象D的指针，这样，A现在指向D，而对象B现在指向C，如果它这样做，它将创建一个从黑色对象到白色对象的指针**】 This is an incremental algorithm, and it's interleaving the operation of the collector and the program. So the garbage collector is paused, the program runs, and it changes some of the pointers around. It swaps the pointer from objects A, which was pointing from object A to object C, and the pointer from object B to object D, such that A is now pointing at D, and the object B is now pointing at C And if it does that, it will create a pointer from a black object to a white object. it will create a pointer from object A, which has already been checked and is known to be alive, and therefore its coloured black, down to object D, which has not yet been checked and is coloured white.
  - 程序运行，交换A→C和B→D的指针，使A→D和B→C的指针交换。•	Program runs, and swaps the pointers from A→C and B→D such that A→D and B→C
  - 这创建了一个从黑色到白色的指针•	This creates a pointer from black to white
- 【**当它这样做时，程序必须与垃圾收集器协调。程序必须改变一些被标记的对象的颜色。如果它不这样做，当收集器下次运行时，它会发现对象A被标记为黑色，表明它已经被检查过了，因此它不会再检查它。它将查看对象B，发现它也被标记为黑色，同样它不会再检查它。然后，它将跟踪它的子代，看看对象C和其他对象，它们被标记为灰色，并开始检查它们的子代。但它永远不会到达对象D，因为对象D是从一个已知是活的对象中引用的，该对象被标记为黑色，因此已经被检查过。因此，没有必要检查它的任何未完成的子对象，所以对象D将被遗漏，并且不会被标记为活着，尽管它是可以到达的**】 As it does that, the program has to coordinate with the garbage collector. The program has to change the colours of some of the marked objects. If it doesn’t, when the collector next runs, it will look and find that object A is marked as black, indicating that it’s already been checked, and therefore it won’t check it again. It will look at object B, and see that it's been marked black, and again it won’t check it again. And it will then follow its children, and look at object C, and the other object, which are marked as grey and start checking their children. But what it won't ever do is reach object D, because object D is referenced from an object which is known to be alive, that is marked black, and therefore has been checked. And therefore there's no need to check any of its outstanding children, so object D will be missed, and won't be marked as alive, even though it is reachable
  - 程序现在必须与收集器协调，否则收集将继续进行，将对象B标记为黑色，其子女标记为灰色，但由于A的子女已经被扫描过，D将不会被到达。•	Program must now coordinate with the collector, else collection will continue, marking object B black and its children grey, but D will not be reached since children of A have already been scanned
- 【**所以，为了避免这种情况，当程序运行时，如果它对指针做了任何操作，创建了一个从标记为黑色的对象到标记为白色的对象的指针，它需要与收集器协调，并以某种方式更新颜色**。】. So, to avoid this, when the program is running, if it does any manipulation of the pointers that creates a pointer from an object which is marked black to an object which is marked white, it needs to coordinate with the collector and somehow update the colours.

# 增量回收-协调策略:Coordination Strategies

有两种方法可以做到这一点。它可以用读屏障来做，也可以用写屏障来做

- 读取障碍：捕获程序读取白色物体指针的尝试，将这些物体染成灰色，然后让程序继续运行 •	Read barrier: trap attempts by the program to read pointers to white objects, colour those objects grey, and then let program continue 【**读取屏障方法的工作原理是：每次程序读取一个指向白色对象的指针，每次它试图获得一个对象的引用，发现该对象是白色的，那么它就把该对象的颜色改为灰色，然后让程序继续运行** The read barrier approach works by every time the program reads a pointer to a white object, every time it tries get a reference to an object and finds that object is coloured white, then it changes the colour of that object to grey, and then lets the program continue.】
  - 【**这里的意思是，程序不可能得到一个指向白色对象的指针。而且，既然它不能得到一个指向白色对象的指针，它就不能创建一个从黑色对象到白色对象的指针。程序读取的任何对象都会被标记为灰色，这使它进入收集器知道它有扫描它们的子对象的集合。它确保每一个被读取的对象，如果它被引用，如果程序确实改变了指针，使它被黑色对象引用，就被染成灰色，这样收集器就会检查它。因此，它避免了从黑色对象到白色对象的指针的产生，因为它首先使人们无法获得对白色对象的引用**】 The idea here is that it's not possible for the program to get a pointer to a white object. And, since it can't get a pointer to a white object, it can't create a pointer from a black object to a white object. Any object the program reads gets marked as grey, which puts it in the set of objects for which the collector knows it has the scan their children. It makes sure that every object that is read, if it is referenced, if the program does change the pointers so it’s referenced by black object, is coloured grey such that the collector will check it. So it avoids creating pointers from black objects to white objects, by making it impossible to get a reference to a white object in the first place
    - 使得程序不可能获得指向白色对象的指针，所以它不能使黑色对象指向白色对象。•	Makes it impossible for the program to get a pointer to a white object, so it cannot make a black object point to a white
- 写入障碍：捕获试图将黑色对象的指针改为指向白色对象的行为 •	Write barrier: trap attempts to change pointers from black objects to point to white objects 【**另一方面，一个写屏障会捕获试图改变指针的行为。因此，如果系统注意到，如果程序试图改变一个指针，比如它正在创建一个从黑色对象到白色对象的指针，那么它就会改变其中一个对象的颜色** A write barrier, on the other hand, traps attempts to change pointers. So, if the system notices that, if the program tries to change a pointer, such that it's creating a pointer from a black object to a white object, then it changes the colour of one of those objects.】
  - 然后要么把黑色对象重新着色为灰色，要么把被引用的白色对象重新着色为灰色 •	Either then re-colour the black object as grey, or re-colour the white object being referenced as grey 【**它要么把黑色对象改回灰色，这样它就会在垃圾收集器运行时被查看。或者它将白色对象重新着色为灰色，这样它就会在下次被查看**  It either changes the black object back to grey, such as it gets looked at next time the garbage collector runs. Or it recolours the white objects as grey, again so that it gets looked at next time】
  - 被染成灰色的对象被移到必须检查其子对象的列表中 •	The object coloured grey is moved onto the list of objects whose children must be checked 【**任何被读障碍或写障碍染成灰色的对象，都会被放回对象列表中，在下次收集器运行时，其子对象需要被检查** And any object which is coloured grey, by either a read barrier or a write barrier, is put back onto the list of objects whose children need to be checked next time the collector runs】
- 【**系统以这种方式进行。收集器运行，查看堆的一部分，改变这些对象的颜色，因为它正在检查它们是否可以到达，并逐渐将对象的颜色从白色变为灰色变为黑色。然后每隔一段时间，收集器就会暂停，程序运行一段时间，操作一些指针，这些指针会把一些对象改回程度，而这些指针的操作会把一些对象改回灰色。而这两者是交织在一起的，它们逐渐在堆中飞驰。采集器将对象变成黑色，而程序则将它们变回灰色，它们一直在竞赛，直到它们在堆中走完所有的路**】And the system proceeds in this way. The collector runs, looks at part of the heap, changes the colour of those objects as it's checking them to see if they’re reachable, and gradually colours the objects from white to grey to black. And then every so often the collector is paused, the program runs for a while, manipulates some pointers, and those pointers change some of the objects back degree, and that those pointer manipulations change some of those objects back to grey. And the two are interleaved, and they’re gradually racing through the heap. And the collector is turning the objects black, and the program is turning them back to grey, and they sort of race until they get all the way through the heap.

# 增量回收-效率(三色算法-协调策略)

读写障碍三色算法的许多变体•	Many variants on read- and write-barrier tricolour algorithms

- 性能的权衡取决于硬件特性和指针的表示方式•	Performance trade-off differs depending on hardware characteristics, and on the way pointers are represented 【**而这里面有一堆不同的变体。有些语言喜欢读障碍，有些语言喜欢写障碍。我认为这种权衡取决于读和写有多普遍，硬件在捕获指针访问方面的效率有多高，指针在语言和虚拟机中是如何表示的，等等** And there’s a bunch of different variants of this. Some languages prefer read barriers, some languages prefer write barriers. I think that the trade off depends on how common are reads versus write, how efficient is the hardware at trapping pointer accesses, how are pointers was represented in the language and the virtual machine, and so】
- 【**通常情况下，我认为这是用写屏障来完成的，因为写比读更不常见，这使得实现写屏障的成本更低，但两种方法都可以。你在这两者之间取得了一种平衡**】Typically, I think, this is done using a write barrier, because writes are less common than reads, which makes it cheaper to implement a write barrier, but both approaches work. And you've kind of got a balance between the two
  - 写屏障的实现通常比读屏障更便宜，因为在大多数代码中写的情况较少。•	Write barrier generally cheaper to implement than read barrier, as writes are less common in most code
  - 在收集器操作和程序操作之间存在着一种平衡•	There is a balance between collector operation and program operation
- 【**你有一个收集器，即垃圾收集器，在内存中运行，逐渐尝试收集堆。每次收集器被允许运行，它就会收集一点堆，把一些对象标记为黑色。而你有一个同时运行的程序，它正在将对象变回灰色，并且正在创建新的未选中的对象。它们在堆中飞驰，而你不得不希望垃圾收集器能跟上程序产生新垃圾的速度。当然，风险在于，垃圾收集器没有得到足够的运行周期，而程序抢在它前面，垃圾收集周期永远不会结束。程序总是在创造新的垃圾，比垃圾收集器能标记的速度快，这样收集器就永远无法到达堆扫描的终点，也永远无法回收内存**】You've got the collector, the garbage collector, running through the memory, gradually trying to collect the heap. And each time the collector is allowed to run it collects a little bit of the heap, marks some of the objects as black. And you've got the program running concurrently, which is changing the objects back to grey, and is creating new unchecked objects. And they're kind of racing through the heap, and you have to hope the garbage collector keeps up with the rate at which the program is generating new garbage. And the risk, of course, is that the garbage collector isn't given enough cycles to run, and the program gets ahead of it, and the garbage collection cycle never finishes. The program is always creating new garbage, faster than garbage collector can mark it, such that the collector never gets to the end of the heap scan, and can never reclaim the memory.
  - 如果程序试图创建太多从黑对象到白对象的新引用，需要与收集器协调，收集可能永远不会完成•	If the program tries to create too many new references from black to white objects, requiring coordination with the collector, the collection may never complete
- 【**如果这种情况发生，最终，系统将耗尽内存。它只是填满了堆空间，因为收集器还没有完成收集并释放了一些。在这一点上，你唯一能做的就是停止程序，让垃圾收集器完成，然后它就会回收这些内存。**】If that happens, eventually, the system will run out of memory. It will just have filled the heap space, because the collector hasn't finished the collection and freed some of it up. And at that point, the only thing you can do is just stop the program, let the garbage collector finish, and it will then reclaim the memory. 
  - 如果自由内存用完了，或者在一定时间后，通过强制完全停止世界的收集来解决•	Resolve by forcing a complete stop-the-world collection if free memory is exhausted, or after a certain amount of time
- 【**建立一个增量收集器的艺术在于确定给垃圾收集算法的时间量，以及给垃圾收集算法的时间片，这样它就能跟上程序，所以它能跟上分配的速度，并成功地在整个堆中工作，释放一些内存，并开始下一个周期，而程序并不总是超过它**】And the art of building an incremental collector is in sizing the amount of time given to the garbage collection algorithm, and the time slices given to the garbage collection algorithm, such it can keep up with the program, so it can keep up with the rate of allocation, and does successfully work its way through the whole heap, free up some memory, and begin the next cycle, and the program doesn't always out race it.

# ===============

# 3  实际因素：Practical Factors

本讲座的最后部分讨论了影响垃圾收集的一些实际因素。它考虑了如何在增量垃圾收集的思想基础上对垃圾收集进行调整，以支持实时系统。并考虑了垃圾收集的内存开销及其与虚拟内存的相互作用，并将这种行为与手动内存管理和基于区域的内存管理进行了比较。最后，简要考虑了弱类型编程语言的垃圾收集问题。The final part of this lecture discusses some practical factors that affect garbage collection. It considers how garbage collection can be adapted to support real-time systems, building on the ideas of incremental garbage collection. And it considers the memory overhead of garbage collection and its interactions with virtual memory, and compares this behaviour to that of manual memory management and region based memory management. Finally, garbage collection for weakly typed programming languages is briefly considered.

# ===============