# Content

第7讲讨论了并发性。它讲述了多核系统如何推动越来越多的并发编程，以及使用线程、锁和共享变异状态的常用并发代码方法的热度，是有问题的。它介绍了基于事务的模型和消息传递模型，作为可能的替代方案，这可能会使未来的并发编程更加简单。

* [Content](#content)
* [1多核意义：Implications of Multicore](#1多核意义implications-of-multicore)
* [内存模型&多核系统：Memory Models and Multicore system](#内存模型多核系统memory-models-and-multicore-system)
* [Java内存模型：Memory Models](#java内存模型memory-models)
* [其他内存模型：Other Memory Models](#其他内存模型other-memory-models)
* [并发，线程，锁：Concurrency, Threads, and locks](#并发线程锁concurrency-threads-and-locks)
* [基于锁并发局限：Limitations of Lock-based Concurrency](#基于锁并发局限limitations-of-lock-based-concurrency)
* [难以编写基于锁的代码-代码不能组合：Composition of Lock-based Code](#难以编写基于锁的代码-代码不能组合composition-of-lock-based-code)
* [其他并发模型：Alternative Concurrency Models](#其他并发模型alternative-concurrency-models)
* [================](#)
* [2事务管理并发：](#2事务管理并发)
* [事务：Transactions for managing concurrency](#事务transactions-for-managing-concurrency)
* [编程模型：Programming Model](#编程模型programming-model)
* [事务编程模型限制：Consequences](#事务编程模型限制consequences)
* [IO控制：controlling I/O](#io控制controlling-io)
* [控制副作用代码：Controlling Side Effects](#控制副作用代码controlling-side-effects)
* [Monadic STM Implementation](#monadic-stm-implementation)
* [整合Haskell:Integration into Haskell](#整合haskellintegration-into-haskell)
* [整合其他语言：Integration into Other Languages](#整合其他语言integration-into-other-languages)
* [================](#-1)
* [================](#-2)
* [================](#-3)

# 1多核意义：Implications of Multicore

讲座的第一部分谈到了多核系统对编程的影响。它概述了现代编程语言需要有一个定义明确的内存模型，并概述了Java所采用的内存模型。它谈到了线程和由锁保护的共享可变状态的常见并发模型，并讨论了这种模型的局限性和内在问题。并开始介绍其他的并发模型，这些模型将构成本讲座后面部分的讨论基础。

# 内存模型&多核系统：Memory Models and Multicore system

![](/static/2022-05-07-00-43-03.png)

- 硬件趋势：具有非统一内存访问的多核•	Hardware trends: multicore with non-uniform memory access
  - 【**计算系统正越来越多地提供多核支持。现在已经很难买到单处理器系统了，有四个或八个内核的系统已经成为主流。而拥有多达 64 个处理器内核的系统，甚至更多，也是现成的。这样做的明显后果是，并行计算现在已经成为常态。不过，也许不太明显的是，分布式内存现在也很普遍。每个处理器核心都有自己的私有缓存，不与其他核心共享。因此，每个处理器对内存都有自己独特的看法。而且，所有的处理器核心并不总是能够平等地访问内存** computing systems are increasingly providing multicore support. It’s now difficult to buy uniprocessor systems, and systems with four or eight cores are now mainstream. And systems with up to 64 processor cores, and perhaps more, are readily available. The obvious consequence of this is that parallel computation is now the norm. Perhaps less obvious, though, is that distributed memory is now also commonplace. Each processor core has its own private cache, that is not shared with other cores. And as a result, each processor has its own distinct view of memory. And memory is not always equally accessible to all the processor cores.】
    - 越来越多的核心，为了性能•	Increasing numbers of cores, for performance
    - 缓存一致性越来越昂贵 → 核心通过消息传递进行通信，内存是远程的•	Cache coherency increasingly expensive → cores communicate by message passing, memory is remote
- 【**幻灯片右上方的图显示了一个八核系统，每个核都有自己的一级缓存，但成对的核共享二级缓存。而内存通过一个共享的内存控制器集线器连接到所有的内核** The figure at the top right of the slide shows an eight core system where each core has its own level 1 cache, but pairs of cores share a level 2 cache. And where memory is connected to all of the cores via a shared memory controller hub.】
- 【**相比之下，右下角的图显示了一个系统，在这个系统中，核心不共享高速缓存，而内存被物理地连接到某些处理器上。在这种情况下，处理器内核可以直接访问附属于其所属处理器的内存，但不能直接访问其他内存。这些处理器通过硬件消息传递层进行通信，如果它们需要访问远程内存，要求其他处理器从其内存中读取并将结果传回给它们** The figure at the bottom right, in contrast, shows a system where the cores don’t share cache, and where the memory is physically attached to certain processors. In this case processor cores have direct access to the memory attached to the processor of which they are a part, but can’t directly access other memory. These processors communicate via a hardware message passing layer, if they need to access remote memory, asking the other processor to read from its memory and pass the result back to them.】
- 【**现在，这些是系统构建方式的例子。还有许多其他的例子。重要的是，内存访问不再是统一的。由于缓存的存在，不同的处理器内核对内存的内容有不同的看法。而每个内核访问内存中某一特定数值的速度将取决于缓存占用率，以及该数值在内存中的物理位置。这可能会导致不同数值的内存访问延迟出现几千倍的变化。要确保所有线程、所有内核都能看到相同的内存视图，成本太高了** Now, these are examples of the way systems are built. And there are many other examples. What’s important is that memory access is no longer uniform. The different processor cores each have a different view of the contents of memory, due to caching. And the speed at which each core can access a particular value in memory will depend on cache occupancy, and on where in memory that value is physically located. And this can lead to a several-thousand times variation in memory access latency for different values. It’s prohibitively expensive to ensure that all threads, on all cores, see the same view of memory.】
- 【**相反，为了确保良好的性能，现代系统允许不同的处理器核心看到不一致的内存视图。你在读取内存时看到的东西将取决于你的程序是在哪个核心上执行的。而且，它们引入了显式同步点。显式操作在处理器之间强制同步内存视图，每个处理器提供略微不同的基元来做到这一点。为了确保程序能够在不同类型的处理器之间可移植地运行，编程语言定义了它们的内存模型。他们需要定义语言在并发内存访问方面提供哪些保证。然后，编译器可以将其转化为机器代码，使用底层硬件提供的同步原语，以确保行为的一致性** Rather, to ensure good performance, modern systems allow different processor cores to see inconsistent views of memory. What you see when you read memory will depend what core your program is executing on. And they introduce explicit synchronisation points. Explicit operations that force synchronisation of the view of memory between processors, with each processor providing slightly different primitives to do this. To ensure that programs work portably across the different types of processor, programming languages define their memory model. They need to define what guarantees the language provides around concurrent memory accesses. And the compiler can then turn this into machine code, using the synchronisation primitives provided by the underlying hardware, to ensure consistent behaviour.】
  - 一个核的写操作何时对其他核可见？•	When do writes made by one core become visible to other cores?
    - 该语言的内存模型是什么？•	What is the memory model for the language?
    - 如果所有内核上的所有线程都有完全相同的内存视图，那就太昂贵了（"顺序一致性"）。•	Prohibitively expensive for all threads on all cores to have the exact same view of memory (“sequential consistency”)
    - 为了提高性能，允许各核对内存的看法不一致，但在同步点除外；引入具有明确语义的同步原语•	For performance, allow cores inconsistent views of memory, except at synchronisation points; introduce synchronisation primitives with well-defined semantics
    - 不同处理器的硬件保证不同•	Hardware guarantees vary between processors
    - 只要语言有明确的内存模型，语言运行时就可以隐藏差异•	Differences hidden by language runtime, provided language has a clear memory model

# Java内存模型：Memory Models

- 【**第一个定义明确内存模型的主流语言是Java。Java虚拟机保证对一个对象中的特定字段所做的改变是按程序顺序出现在做出改变的线程中的。也就是说，如果一个线程把一个值写到内存中，然后再把它读回来，只要没有其他线程写到相同的位置，那么这个线程读到的值将是它写的。这也是你所期望的**the first mainstream language to define an explicit memory model was Java. The Java virtual machine guarantees that changes made to a particular field in an object appear in program order to the thread that made the change. That is, if a single thread writes a value to memory, and then later reads it back, and provided no other threads wrote to the same location, then the value the thread reads will be that which it wrote. And this is what you’d expect.】
  - Java有一个正式定义的内存模型•	Java has a formally defined memory model
  - 在一个线程中，对一个字段的改变是按程序顺序看到的•	Changes to a field are seen in program order within a thread
- 一个线程对一个字段所做的改变对其他线程来说是可见的，如下所示。•	Changes to a field made by one thread are visible to other threads as follows: 【**然而，如果多个线程对一个字段进行读写，那么Java只能保证在某些情况下，一个线程所做的改变对其他线程是可见的** However, if multiple threads read and write to a single field, then Java only guarantees that changes made by one thread become visible to other threads in certain cases.】
  - 【**例如，如果一个线程改变了一个被标记为易失性的字段，那么这个改变是原子进行的，并立即对其他线程可见。但是，如果一个线程改变了一个没有标记为易失性的字段，那么这个改变何时对其他线程可见，取决于持有什么锁，以及线程何时被创建和销毁。有三种不同的情况** If a thread changes a field that’s marked as volatile, for example, then that change is made atomically, and immediately becomes visible to other threads. But, if a thread changes a field that’s not marked as volatile, then when that changes becomes visible to other threads depends on what locks were held, and when the threads were created and destroyed. There are three different cases.】
    - 如果一个易失性字段被改变，该改变是以原子方式完成的，并立即对其他线程可见。•	If a volatile field is changed, that change is done atomically and immediately becomes visible to other threads
  - 【**首先，如果一个线程在持有锁的同时更改了非易失性字段的值，然后释放该锁，然后某个其他线程获取该锁，则保证获取该锁的线程可以看到写入的值。其次，如果创建了一个新线程，它会看到系统的状态，就好像它刚刚获得了一个刚刚被创建线程释放的锁** Firstly, if a thread changes the value of a non-volatile field, while holding a lock, then releases that lock, and then some other thread acquires the lock, then the thread that acquires the lock is guaranteed to see the written value. Secondly, if a new thread is created, it sees the state of the system as if it had just acquired a lock that had just been released by the creating thread.】
    - 如果一个非易失性字段在持有锁的情况下被改变，然后该锁被写线程释放并被读线程获得，那么该改变对读线程是可见的。•	If a non-volatile field is changed while holding a lock, and that lock is then released by the writing thread and acquired by the reading thread, then the change becomes visible to the reading thread
    - 如果一个新的线程被创建，它就会看到系统的状态，就好像它刚刚获得了一个刚刚被创建线程释放的锁。•	If a new thread is created, it sees the state of the system as if it had just acquired a lock that had just been released by the creating thread
  - 【**第三，如果一个线程终止了，那么它所做的改变对其他线程是可见的。然而，在这三种情况之外，没有任何保证。如果两个线程同时访问一个变量而没有适当的锁，那么一个线程所做的改变可能会对另一个线程可见。也可能不可见。这取决于硬件，也取决于线程调度的具体细节，而且对程序员来说是无法预测的** And, thirdly, if a thread terminates, then the changes it made become visible to other threads. Outside of these three cases however, there are no guarantees. If two threads concurrently access a variable without proper locking, then the changes made by one thread might be visible to the other. Or they might not. It depends on hardware, and on the exact details of the thread scheduling, and it isn’t predictable to the programmer.】
    - 如果一个线程终止了，它所做的改变对其他线程是可见的•	If a thread terminates, changes it made become visible to other threads
  - 【**唯一的其他保证是，对32位字段的访问，如整数和浮点值，是原子性的。系统永远不会观察到对一个int或float的半完成的写入，即使它是错误的同步。但是这个保证对于64位的字段，比如long或double值并不成立，如果系统没有正确地锁定，就会观察到损坏的和写了一半的值。这种内存模型允许硬件的灵活性。它允许每个处理器核心可以看到不同的内存视图，而且不同线程之间的内存视图可以发生分歧。而且，只有明确使用锁的时候才需要在内核之间进行同步。如果我们注意锁定并发访问，这可以让我们写出可移植的代码，同时允许良好的性能** The only other guarantee made is that accesses to 32-bit fields, such as integer and floating point values, is atomic. The system will never observe a half-completed write to an int or a float, even if it’s incorrectly synchronised. But this guarantee doesn’t hold for 64-bit fields, such as long or double values, where corrupted and half-written, values can be observed if the system isn’t correctly locked. This memory model allows flexibility for the hardware. It allows that each processor core can see a different view of the memory, and that the views of the memory can diverge between different threads. And only the explicit use of locks requires synchronisation between cores. This lets us write portable code, if we pay attention to locking concurrent accesses, whilst allowing good performance.】
    - 对所有32位字段的访问是原子性的•	Access to all 32-bit fields is atomic
      - 也就是说，你永远无法观察到一个半途而废的写入，即使是不正确的同步。•	i.e., you can never observe a half-way completed write, even if incorrectly synchronised
      - 但对于64位的长字段和双字段来说就不是这样了，只有在字段是易失性的或持有锁的情况下，写入才是原子性的。•	This is not true for for long and double fields, which are 64-bits in size, where writes are only atomic if field is volatile or if a lock is held

# 其他内存模型：Other Memory Models

> 越来越清楚的是，所有语言都需要定义它们的内存模型。如果语言的定义没有明确说明什么时候并发访问是可见的，那么就有可能出现不同的处理器会有不同的行为，而这些差异对程序员来说是可见的。因此，要想获得正确性的希望，语言必须明确程序员可以依赖什么行为 It’s increasingly clear that all languages need to define their memory model. If the language definition isn’t explicit about when concurrent accesses become visible, it runs the risk that different processors will behave differently, and these differences will be visible to the programmer. So, to have any hope of correctness, the language has to be clear what behaviour the programmer can rely on. 

不幸的是, Java在拥有这样一个明确规定的内存模型方面是不寻常的。•	Java is unusual in having such a clearly-specified memory model

- 其他语言的规范性较差，存在新的处理器设计可能会巧妙地破坏以前的工作程序的风险•	Other languages are less well specified, running the risk that new processor designs can subtly break previously working programs
- 【**C和C++在历史上有非常糟糕的内存模型规定。这两个标准的最新版本现在已经解决了这个问题，这在很大程度上依赖于为Java所做的工作，但编译器需要很长的时间来实现这些标准，并且可以使用** C and C++ have historically had very poorly specified memory models. The recent versions of both standards have now fixed this, leaning very heavily on the work done for Java, but it’s taking a long time for compilers to implement those standards, and to become available.】
  - C和C++在历史上的内存模型规定得非常差。•	C and C++ have historically had very poorly specified memory models
    - 最新版本的标准解决了这个问题，内存模型受到了Java内存模型的很大影响。•	Latest versions of standards address this, with memory models heavily influenced by the Java memory model
    - 尚未广泛实施•	Not yet widely implemented
- 【**而Rust也还没有一个完全指定的内存模型，尽管它正在开发中。与C或C++或Java相比，为Rust指定内存模型是很复杂的，因为Rust有几种不同的引用类型和所有权规则，而且有安全和不安全代码的区别。这也是Rust目前的局限性之一** And Rust also does not yet have a fully specified memory model, although one is under development. Specifying a memory model for Rust is complicated compared to C or C++ or Java, because Rust has several different reference types and ownership rules, and because of the distinction between safe and unsafe code. This is one of the current limitations of Rust.】
  - Rust（目前）还没有一个完全指定的内存模型•	Rust does not (yet) have a fully specified memory model
    - 被认为是一个局限性--正在进行研究以解决这个问题•	Recognised as a limitation – research efforts underway to fix this
    - 多重引用类型和`unsafe`代码使其复杂化•	Complicated by multiplicity of reference types and unsafe code

# 并发，线程，锁：Concurrency, Threads, and locks

![](/static/2022-05-07-01-05-11.png)

- 【**正如我们所看到的，一种语言的内存模型明确地与它管理线程间锁定和通信的方式联系在一起。大多数操作系统以多个进程的形式向应用程序提供并发性，每个进程可能包含多个执行线程。而进程之间是相互隔离的，不共享内存。不过，一个进程中的线程会共享对公共内存池的访问，并利用同步来管理对该共享内存的访问。它们需要对访问共享资源的关键部分进行显式锁定** As we’ve seen, the memory model of a language is explicitly tied into the way it manages locking and communication between threads. Most operating systems expose concurrency to applications in the form of multiple processes, each potentially containing multiple threads of execution. And processes are isolated from each other, and don’t share memory. Threads within a process, though, share access to a common pool of memory, and make use of synchronisation to manage access to that shared memory. They require explicit locks around critical sections where shared resources are accessed.】
  - 操作系统将并发性暴露为进程 和线程•	Operating system exposes concurrency as processes and threads
    - 进程通过独立的内存区域进行隔离•	Processes are isolated with separate memory areas
    - 线程共享访问一个共同的内存池•	Threads share access to a common pool of memory
      - 大多数操作系统从进程和消息传递开始，后来由于程序员的需求而增加了线程。•	Most operating systems started with processes and message passing, and added threads later due to programmer demand
- 【**如何做到这一点取决于语言的不同。例如，在Java中，锁是由同步方法和同步块的实现提供的。在C语言中，它们由pthreads库以pthread_mutex_lock()和pthread_mutex_unlock()的形式提供，在C++中由std::线程类提供。这些提供了同步化的基元，并确保对共享数据的访问遵循语言的内存模型。而且，在这种受保护的、锁定的区域之外，对共享内存的并发访问几乎没有保证**  How this is done depends on the language. In Java, for example, the locks are provided by the implementation of synchronised methods and synchronised blocks. In C, they’re provided by the pthreads library, in the form of pthread_mutex_lock() and pthread_mutex_unlock(), in C++ by the std::thread class. And these provide the synchronisation primitives, and ensure access to shared data follows the memory model of the language. And, outside of such protected, such locked, regions, there are very few guarantees about concurrent accesses to shared memory.】
- 内存模型规定了对共享内存的并发访问是如何进行的•	The memory model specifies how concurrent access to shared memory works
  - 通过关键部分的显式锁来实现同步•	Synchronisation by explicit locks around critical sections
    - Java中的同步方法和语句•	synchronized methods and statements in Java
    - C语言中的pthread_mutex_lock()/pthread_mutex_unlock() •	pthread_mutex_lock()/pthread_mutex_unlock() in C
  - 通过易失性字段进行同步•	Synchronisation by volatile fields
  - 对共享内存的无锁并发访问的有限保证•	Limited guarantees about unlocked concurrent access to shared memory

# 基于锁并发局限：Limitations of Lock-based Concurrency

基于锁的并发性的主要问题。•	Major problems with lock-based concurrency:【**提供多个线程，并使用锁来保护对共享内存的访问，这种方法是非常普遍的。但它也确实存在问题** The approach of providing multiple threads, and using locks to protect access to shared memory, is extremely common. But it’s also really problematic.】

- 【**事实证明，很难为语言定义一个内存模型，以提供良好的性能，同时也允许程序员对代码进行推理。我们很难知道什么时候锁是正确的。失败是无声的。锁定不正确的代码往往编译得很好，但错误往往会在重负荷下表现出来。这使得这种代码难以编写，也难以调试。平衡性能和正确性是困难的。过度或不足的锁定程序是很容易的。增加太多或者太少的锁。如果你锁的太多，或者锁的时间太长，那么性能就会变差。但如果锁得太少，代码就会偶尔出现不可预知的故障。很难强制执行正确的锁，也很难保证免于死锁** It’s proven difficult to define a memory model for a languages that provides good performance, whilst also allowing programmers to reason about the code. It’s difficult to know when the locking is done correctly. Failures are silent. Incorrectly locked code tends to compile just fine, but errors tend to manifest themselves under heavy load. This make such code hard to write, and hard to debug. Balancing performance and correctness is difficult. It’s easy to over- or under-lock programs. To add too many, or too few locks. And if you lock too much, or for too long, then the performance is bad. But lock too little, and the code occasionally and unpredictably fails. It’s difficult to enforce correct locking, and difficult to guarantee freedom from deadlocks.】
  - 难以定义一个能够实现良好性能的内存模型，同时允许程序员对代码进行推理•	Difficult to define a memory model that enables good performance, while allowing programmers to reason about the code
  - 在编写代码时很难保证正确性•	Difficult to ensure correctness when composing code
  - 难以强制执行正确的锁定•	Difficult to enforce correct locking
  - 难以保证不出现死锁•	Difficult to guarantee freedom from deadlocks
  - 失败是无声的--错误往往只在重载下才会显现出来•	Failures are silent – errors tend to manifest only under heavy load
  - 难以平衡性能和正确性--容易造成系统过锁或欠锁•	Balancing performance and correctness difficult – easy to over- or under-lock systems

# 难以编写基于锁的代码-代码不能组合：Composition of Lock-based Code

![](/static/2022-05-07-01-13-59.png)

> 而且，要**编写使用锁的代码也很困难**。我认为，**这才是反对将锁作为同步机制的真正理由**。至少在原则上，使用锁来控制对共享数据的访问，是可以正确编写小规模代码的。这并不容易，而且大多数人都做错了，但原则上是可以做到的 And it’s difficult to compose code that uses locks. And this, I think, is the real argument against locks as synchronisation mechanism. In principle, at least, it’s possible to write small-scale code correctly using locks to control access to shared data. It’s not easy, and most people get it wrong, but in principle it’s possible.
>  **但问题是，基于锁的代码并不能组合。如果你有两个分别正确使用锁的函数，那么将它们组合起来的结果可能是不正确的** The problem is, though, is that lock-based code doesn’t compose. If you have two functions that each use locking correctly, then the result of combining them may not be correct.
>  大家用来说明这个问题的例子是一个银行系统。假设你有一个银行账户类，它正确地使用锁来保护对账户的访问。你想写一个程序，在两个账户之间转钱。而这个程序不应该暴露中间状态。也就是说，钱要么在A账户中，要么在B账户中，但不应该出现钱同时在两个账户中，或者两个账户都不在的情况 The example everyone uses to illustrate this is a banking system. Assume you have a bank account class, that correctly uses locks to protect access to the account. You want to write a program to transfer money between two accounts. And that program shouldn’t expose the intermediate state. That is, the money should either be in account A, or it should be in account B, but it shouldn’t be possible to see a situation where the money is in both accounts, or in neither account. 
> 不幸的是，对各个账户的锁定并不能保护这一点。即使账户被正确锁定，另一个线程仍有可能观察到中间状态，即钱从一个账户中消失，但没有到达另一个账户。单独的操作是正确的，但综合的操作是不正确的。**我们需要添加额外的锁来使组合正确。而这是锁工作方式的根本。它不能通过仔细的编码来解决。这是锁的抽象本身的一个限制**。Unfortunately, the locking on the individual accounts doesn’t protect this. Even if the accounts are correctly locked, it’s still possible for another thread to observe the intermediate state where, the money is gone from one account but not arrived in the other. The individual operations are correct, but the combined operation is not. We need to add extra locks to make the combination correct. And this is fundamental to the way locks work. It cannot be fixed by careful coding. It’s a limit of the locking abstraction itself.

- 从理论上讲，使用锁的小规模代码的正确性可以通过仔细的编码来保证•	Correctness of small-scale code using locks can, in theory, be ensured by careful coding
- 一个更基本的问题：基于锁的代码不能组合更大的规模•	A more fundamental issue: lock-based code does not compose to larger scale
- 假设一个正确锁定的银行账户类，有 方法从账户中贷出和借出资金•	Assume a correctly locked bank account class, with methods to credit and debit money from an account
- 想从a中取钱并将其转移到b中，而不暴露出钱在两个账户中的中间状态•	Want to take money from a and move it to b, without exposing an intermediate state where the money is in neither account
- 在转移过程中，如果不锁定对a和b的所有其他访问，就无法做到。•	Can’t be done without locking all other access to a and b while the transfer is in progress
- 单独的操作是正确的，但综合的操作是不正确的 •	The individual operations are correct, but the combined operation is not
- 这是缺乏抽象性，是基于锁的并发模型的限制，不能通过仔细的编码来解决。•	This is lack of abstraction a limitation of the lock-based concurrency model, and cannot be fixed by careful coding
- 锁定要求构成了一个对象的API的一部分•	Locking requirements form part of the API of an object

# 其他并发模型：Alternative Concurrency Models

> 由于这些原因，现在是我们再次思考替代性并发模型的时候了。多核系统现在已经无处不在了。并发性无处不在。**但是，由锁保护的共享访问的多线程代码是非常难以正确编写的。即使写对了，在组合成完整的系统时，也很容易出现故障。在下面的部分中，将谈论基于锁的并发的两个替代方案：事务和消息传递**。And for these reasons, it’s time we thought again about alternative concurrency models. Multicore systems are now ubiquitous. Concurrency is everywhere. But multithreaded code with shared access protected by locking is incredibly hard to write correctly. And even when written correctly, is prone to failures when combined into complete systems. In the following parts, I’ll talk about two alternatives to lock-based concurrency: transactions and message passing.

- 并发性越来越重要•	Concurrency increasingly important
- 多核系统现在无处不在•	Multicore systems now ubiquitous
- 软件和硬件设备之间的异步互动•	Asynchronous interactions between software and hardware devices
- 线程和同步基元有问题•	Threads and synchronisation primitives problematic

- 是否有替代方案可以避免这些问题？•	Are there alternatives that avoid these issues?
  - 事务•	Transactions
  - 消息传递•	Message passing

# ================

# 2事务管理并发：

本讲座的第二部分讨论了原子事务作为一种替代的并发编程模型。它回顾了事务的ACID属性，并介绍了事务编程模型及其后果和好处。它讨论了这种编程风格如何适合Haskell，以及Monad编程风格，任何为什么它不适合更多主流编程语言。The second part of this lecture discusses the atomic transactions as an alternative concurrent programming model. It reviews the ACID properties of transactions, and introduces the transactions programming model and its consequences and benefits. It discusses how this style of programming is a good fit for Haskell, and the monadic programming style, any why it's not a good fit for more mainstream programming languages.

# 事务：Transactions for managing concurrency

- 锁的替代方案：使用原子事务来管理并发性•	An alternative to locking: use atomic transactions to manage concurrency
  - 【**原子事务的目标是提供一种管理并发性的替代方法，避免使用多线程和由锁管理的共享可变状态所固有的问题。其基本思想是将一个程序构造成一个原子事务的序列，不同线程的事务可以并发进行。每个事务都包裹着一些计算，这样它要么成功，要么完全失败，因此中间状态对其他线程是不可见的** The goal of atomic transactions is to provide an alternative way of managing concurrency, that avoids the problems inherent in the use of multithreading with shared mutable state managed by locks. The fundamental idea is to structure a program as a sequence of atomic transactions, where transactions in different threads can proceed concurrently. Each transaction wraps some computation, such that it either succeeds or it fails in its entirety, and so that intermediate states are not visible to other threads The execution of the transactions is managed by a runtime, and the runtime ensures that the transactions obey the usual four ACID properties】
  - 一个程序是一连串并发的原子行动•	A program is a sequence of concurrent atomic actions
  - 原子动作的成功或失败都是完整的，中间状态对其他线程是不可见的。•	Atomic actions succeed or fail in their entirety, and intermediate states are not visible to other threads
- 运行时必须确保行动具有通常的ACID属性。•	The runtime must ensure actions have the usual ACID properties:
  - 原子性--对数据的所有改变都被执行，或者不被执行•	Atomicity – all changes to the data are performed, or none are 【**首先，每个事务都是原子性的。也就是说，它完全成功或失败，任何中间状态对其他线程都不可见。一个事务中的所有动作都会被执行，或者都不会被执行** Firstly, that each transaction is atomic. That is, it succeeds or fails in its entirety, and any intermediate states are not visible to other threads. All of the actions in a transaction are performed, or none of them are. 】
  - 一致性--当一个事务开始和结束时，数据处于一致的状态•	Consistency – data is in a consistent state when a transaction starts, and when it ends 【**其次，事务是一致的。运行时确保系统中的数据在事务开始时处于一致的状态，在事务结束时处于一致的状态，并且在任何时候，不一致的值都对系统的其他部分可见。如果事务成功，该一致状态反映了已完成的行动。如果它失败了，其影响会被干净地回滚，状态就像事务从未被尝试过一样** Secondly, that transactions are consistent. The runtime ensures that the data in the system is in a consistent state when the transaction starts, is left in a consistent state when it ends, and at no point are inconsistent values visible to the rest of the system. If the transaction succeeds, that consistent state reflects the completed action. If it fails, the effects are cleanly rolled back, and the state is as-if the transaction was never attempted.】
  - 隔离性--一个事务的中间状态对其他事务是不可见的•	Isolation – intermediate states of a transaction are invisible to other transactions 【**第三，事务是隔离的。当然，一个事务的执行将包括一些步骤，一些中间状态。运行时确保这些中间状态在事务之外是不可见的。对于程序的其他部分来说，事务的进行是不可分割的、完全的，或者根本就不是** Third, transactions are isolated. The execution of a transaction will, of course, comprise a number of steps, a number of intermediate states. The runtime ensures that none of those intermediate states are visible outside of the transaction. To the rest of the program, the transaction proceeds indivisibly and completely, or not at all.】
  - 持久性--一旦提交，事务的结果就会持续存在。•	Durability – once committed, results of a transaction persist 【**而且，最后，事务是持久的。一个事务可能成功，也可能失败并被回滚。但是，如果它成功了并提交了结果，那么这个结果将持续存在。一个成功的事务将永远不会被回滚** And, finally, transactions are durable. A transaction may succeed, or it may fail and be rolled back. But, if it succeeds and commits its result, then that result will persist. A successful transaction will never be rolled back.】
- 优点。
  - 【**这些属性被称为ACID属性，你可能很熟悉，因为它们经常适用于数据库系统。为什么以这种方式构建一个程序是有意义的呢？因为以这种方式结构的事务可以任意组成，而不影响正确性。正如我们在上一部分看到的，以银行账户类为例，两个正确锁定的银行账户对象，在组合时，可以产生一个暴露内部状态的系统。而这个问题并不发生在事务上。无论它们是如何组成的，都不会影响代码的正确性。而且，事务也避免了由于以错误的顺序获取锁而可能发生的死锁，因为没有锁。而且它们还避免了竞赛条件** These, properties, known as the ACID properties, are probably familiar to you, since they frequently apply to database systems. Why might it make sense to structure a program in this way? Because transactions structured in this way can be composed arbitrarily, without affecting correctness. As we saw in the previous part, with the example of the bank account class, how two correctly locked bank account objects, when combined, could produce a system that exposed the internal state. And this problem doesn’t occur with transactions. No matter how they are composed, it doesn’t affect correctness of the code. And transactions also avoid deadlocks that can occur due to acquiring locks in the wrong order, since there are no locks. And they avoid race conditions.】
  - 事务可以任意组成，而不影响正确性•	Transactions can be composed arbitrarily, without affecting correctness
  - 由于没有锁，所以避免了由于不正确的锁造成的死锁。•	Avoid deadlock due to incorrect locking, since there are no locks

# 编程模型：Programming Model

简单的编程模型。•	Simple programming model:

- 【**使用事务的系统的编程模型是直接的。代码块被标记为原子性的。运行时执行这些代码块，确保执行尊重ACID属性，并允许原子块相对于其他原子块并发运行** The programming model for systems using transactions is straight forward. Blocks of code are labelled as atomic. And the runtime executes those code blocks, ensuring that execution respects the ACID properties, and allows atomic blocks to run concurrently with respect to other atomic blocks】
  - 代码块可以被标记为 atomic{...}。•	Blocks of code can be labelled atomic {…}
  - 相对于每一个其他的 atomic{...}块，并发和原子地运行--控制并发并确保数据结构一致•	Run concurrently and atomically with respect to every other atomic {…} blocks – controls concurrency and ensures consistent data structures
- 通过乐观的事务来实现•	Implemented via optimistic transactions 【**而程序员不必担心锁定或同步的问题。运行时负责处理所有这些。这是用乐观的事务实现的** And the programmer doesn’t have to worry about locking or synchronisation. The runtime takes care of all that. This is implemented using optimistic transactions.】
  - 维护线程本地事务日志，记录原子块的每一次内存读写。•	A thread-local transaction log is maintained, records every memory read and write made by the atomic block 【**当一个原子块进入时，运行时开始维护一个线程本地事务日志。这个事务日志维护着原子块的每一次内存读写和每一次潜在的I/O操作的记录** When an atomic block is entered, the runtime starts to maintain a thread local transaction log. This transaction log maintains a record of every memory read or write, and every potential I/O operation, made by the atomic block.】
  - 当一个原子块完成后，日志被验证，以检查它是否看到了一致的内存视图•	When an atomic block completes, the log is validated to check that it has seen a consistent view of memory 【**当块完成后，事务日志被验证，以检查它是否看到了一个一致的内存视图** When the block completes, the transaction log is validation, to check that it saw a consistent view of memory.】
  - 【**如果验证成功，那么这个原子块，也就是事务，就会把它的变化提交给内存。如果不成功，如果这个事务与另一个事务竞争而输掉了，那么这个原子块，也就是这个事务，就会被滚动到开头，撤销任何变化，并从头开始重试** If the validation succeeds, then the atomic block, the transaction, commits its changes to memory. If not, if this transaction was competing with another transaction and lost out, then the atomic block, the transaction, is rolled block to the beginning, undoing any changes, and retried from scratch.】
    - 如果验证成功，事务就会将其变化提交给内存；如果不成功，事务就会回滚，并从头开始重试。•	If validation succeeds, the transaction commits its changes to memory; if not, the transaction is rolled-back and retried from scratch
  - 【**当然，我们的假设是，事务之间的冲突很少，而且大多数原子块在第一次就完成并提交了结果。如果情况不是这样，如果有很多冲突的事务，那么由于反复回滚，进度会很慢，但事务最终会取得进展** The assumption, of course, is that conflicts between transaction are rare, and that most atomic blocks complete and commit their results the first time. And if that’s not the case, if there are many conflicting transactions, then progress will be slow, due to repeated rollbacks, but the transactions will eventually make progress.】
    - 如果冲突的事务导致重复的验证失败，进展可能会很慢，但最终会发生。•	Progress may be slow if conflicting transactions cause repeated validation failures, but will eventually occur

# 事务编程模型限制：Consequences

![](/static/2022-05-07-03-01-23.png)

- 如果事务日志无法验证，事务可以自动重新运行。•	Transactions may be re-run automatically, if their transaction log fails to validate
  - 【**现在，正如我们所看到的，如果事务日志无法验证，运行时将回滚并重试事务，因为它们在竞争中输给了同时进行的其他事务之一。这样做的一个结果是，需要有可能回滚和重试事务。为了使之成为可能，运行时必须对事务行为进行一些限制** Now, as we’ve seen, the runtime will roll-back and retry transactions, if their transaction log fails to validate because they lose out in competition to one of the other transactions proceeding concurrently. A consequence of this, is that it needs to be possible to roll-back and retry a transaction. And to make this possible, the runtime has to place some restrictions on transaction behaviour.】
- 对事务行为进行了限制。•	Places restrictions on transaction behaviour:
  - 事务必须是参考透明的•	Transactions must be referentially transparent 【**关键的限制是，事务必须是透明的。也就是说，事务返回的结果必须只取决于它的输入，而且每次执行时必须产生相同的结果** The key restriction is that a transaction needs to be referentially transparent. That is, the result returned by a transaction must depend solely on its inputs, and it must generate the same result each time it executes.】
  - 【**而且，在事务过程中，它不能执行I/O操作。它不能做任何不可撤销的事情。例如，幻灯片上的代码样本是有问题的，因为一个并发的事务可能会修改n或k的值。现在，当事务日志被验证时，在原子块结束时，当提交或回滚事务时，这将被检测到。但这可能太晚了，无法阻止导弹的意外发射** And it must not perform I/O operations during the transaction. It must not do anything irrevocable. The code sample on the slide is problematic, for example, because a concurrent transaction might modify the values of n or k. Now, this would be detected when the transaction log is validated, at the end of the atomic block, when it’s time to commit or rollback the transaction. But that might be too late to stop the missiles being launched by accident.】
    - 事务必须不做任何不可撤销的事情。•	Transactions must do nothing irrevocable:
      - 如果由于doMoreStuff()导致的验证失败而被重新运行，可能会多次发射导弹•	Might launch the missiles multiple times, if it gets re-run due to validation failure caused by doMoreStuff()
      - 如果一个并发事务在事务运行时修改了n或k，可能会意外地发射导弹（会导致事务失败，但来不及阻止发射）。•	Might accidentally launch the missiles if a concurrent transaction modifies n or k while the transaction is running (will cause transaction failure, but too late to stop the launch)
  - 这些限制必须被强制执行，否则我们就用难以发现的锁定错误换取难以发现的事务错误•	These restrictions must be enforced, else we trade hard-to-find locking bugs for hard-to-find transaction bugs 【**所以运行时系统必须强制执行这些限制，否则我们就用难以发现的锁定错误换取难以发现的事务一致性错误** So the runtime system has to enforce these restrictions, else we’ve just traded hard to find locking bugs, for hard to find transaction consistency bugs.】

# IO控制：controlling I/O

- 【**所以，我们看到的是，不受限制的I/O打破了事务隔离。如果一个事务可以读取或写入文件，如果它可以通过网络发送或接收数据，如果它可以接受来自鼠标或键盘的输入，更新显示器，播放或录制声音，等等，那么在提交之前就可以观察到该事务的进展。这就破坏了ACID的特性。它破坏了隔离性。而且，它使事务无法回滚** So, what we see is that unrestricted I/O breaks transaction isolation. If a transaction can read or write files, if it can send or receive data over the network, if it can take input from the mouse or keyboard, update the display, play or record sound, etc., then the progress of the transaction can be observed before it commits. This breaks the ACID properties. It breaks isolation. And it makes it impossible to roll-back the transaction. 】
  - 不受限制的I/O破坏了事务隔离•	Unrestricted I/O breaks transaction isolation
    - 读取和写入文件•	Reading and writing files
    - 通过网络发送和接收数据•	Sending and receiving data over the networks
    - 接受鼠标或键盘输入；改变显示•	Taking mouse or keyboard input; changing the display
- 要求用语言控制I/O的执行时间•	Require language control of when I/O is performed 【**为了解决这个问题，语言和运行时需要控制I/O的执行时间。他们需要从标准库中移除允许不受限制的I/O的全局函数，而是用允许控制I/O发生时间的版本来取代它们** To address this, the language and runtime need to control when I/O is performed. They need to remove the global functions that allow unrestricted I/O from the standard library, instead replace them with versions that allow control over when I/O can occur.】
  - **从标准库中删除执行I/O的全局函数**•	Remove global functions to perform I/O from the standard library
  - 【**一种工作方式是，系统提供一个I/O上下文对象，作为参数传递给main()。这个对象将拥有允许读写文件、访问标准输入和标准输出的方法，等等。而诸如printf()等函数将成为I/O上下文对象的方法。如果一个函数需要执行I/O，那么它就需要通过这个I/O内容对象，这样它就可以调用适当的方法。这将允许控制哪些函数可以执行I/O。例如，如果你想阻止一个事务写入一个文件，就不要把I/O内容对象传给它，它就不能读写任何文件。现在，这不是Rust、C、Java或任何其他主流语言的I/O工作方式，尽管可以说它也许应该是。但这是I/O在Haskell中的工作方式。所描述的I/O上下文对象本质上是I/O monad，而Haskell表明这种控制I/O的方法是可行的**】 One way this could work is if the system provided an I/O context object, that was passed as a parameter to main(). This object would have methods that allow reading and writing to files, access to standard input and standard output, and so on. And functions such as printf() would become methods on the I/O context object. And if a function needs to perform I/O, then it would need to be passed this I/O content object, so it could invoke the appropriate methods. This would allow control over what functions can perform I/O. If you want to prevent a transaction from writing to a file, for example, don’t pass it the I/O context object, and it can’t read or write to any files. Now, this is not how I/O works in Rust, or in C, or in Java, or in any other mainstream languages, although arguably it maybe should be. But it is how I/O works in Haskell. The I/O context object I’m describing is essentially the I/O monad, and Haskell shows that this approach to controlling I/O can work.
    - 添加一个I/O上下文对象，在main()的本地，明确传递给需要执行I/O的函数•	Add an I/O context object, local to main(), passed explicitly to functions that need to perform I/O
      - 将以这种方式行事的套接字与通常不以这种方式行事的文件I/O进行比较。•	Compare sockets, that behave in this manner, with file I/O that typically does not
      - I/O函数（例如printf()和friends）就成为I/O上下文对象的方法。•	I/O functions (e.g., printf() and friends) then become methods on the I/O context object
      - I/O上下文不被传递给事务，所以它们不能执行I/O •	The I/O context is not passed to transactions, so they cannot perform I/O
      - 示例：Haskell中的IO monad•	Example: the IO monad in Haskell

# 控制副作用代码：Controlling Side Effects

- 必须控制有副作用的代码•	Code that has side effects must be controlled 【**除了控制I/O操作外，原子事务还需要控制副作用** In addition to controlling I/O operations, atomic transactions require control over side effects.】
  - 纯粹的和引用透明的函数可以正常执行•	Pure and referentially transparent functions can be executed normally 【**那些参考透明的函数，只依赖于它们的参数，不依赖于对共享状态和共享内存的访问，可以被正常访问。但是，如果一个函数访问了可能与其他函数共享的内存，如果它操作了可能与其他事务共享的堆上的值，那么这种访问必须被控制** Functions that are referentially transparent, that only depend on their arguments and that don’t depend on access to shared state, to shared memory, can be accessed normally. But, if a function accesses memory that might be shared with other functions, if it manipulates a value on the heap that might be shared with other transactions, then that access must be controlled】
  - 【**事务中的函数可以执行内存访问，但运行时必须跟踪这些访问。运行时必须跟踪事务中的内存读写，这样它就可以验证与其他正在进行的事务没有冲突，这样它就可以在必要时回滚任何变化，如果发生这种冲突。这可以在软件中完成，由语言运行时通过将内存访问包裹在某种智能指针对象中。这种方法被称为软件事务性内存，STM。另外，一些处理器提供硬件支持来加速这种指针跟踪**. Functions within a transaction can perform memory accesses, but the runtime must track those accesses. The runtime must track memory reads and writes during a transaction, so it can validate that there are no conflicts with other ongoing transactions, and so that it can roll-back any changes, if necessary, if such conflicts occur. And this can be done in software, by the language runtime, by wrapping memory access in some kind of smart pointer object. And this approach is known as software transactional memory, STM. Alternatively, some processors provide hardware support to accelerate such pointer tracking.】
    - 只执行内存操作的函数可以正常执行，前提是事务日志跟踪内存操作，并在事务提交前对其进行验证--并有可能将其回滚。•	Functions that only perform memory actions can be executed normally, provided transaction log tracks the memory actions and validates them before the transaction commits – and can potentially roll them back
      - 内存操作是指在堆上操作数据的操作，其他线程可以看到这些数据。•	A memory action is an operation that manipulates data on the heap, that could be seen by other threads
      - 跟踪内存操作可以通过语言运行时（STM；软件事务性内存），或者通过硬件强制事务性内存行为和回滚来完成。•	Tracking memory actions can be done by language runtime (STM; software transactional memory), or via hardware enforced transactional memory behaviour and rollback
- 与控制I/O的原理类似 •	Similar principle as controlling I/O 【**其原理与控制I/O的原理类似。不允许不受限制的堆访问，就像不允许不受限制的文件访问一样，并提供一个内存事务背景。如果原子块要访问内存，需要将这个事务上下文传递给原子块，允许它们只执行经过检查的内存访问，并在必要时提供验证和回滚内存访问的能力。再说一遍，这也许不是主流，但对于Haskell程序员来说，它是熟悉的state monad**  The principle is similar to that for controlling I/O. Disallow unrestricted heap access, in the same way unrestricted file access way disallowed, and provide a memory transaction context. And require this transaction context to be passed to atomic blocks if they are to access memory, to allow them to perform only checked memory access, and to provide the abilIty to validate and rollback memory accesses if necessary. And, again, this is not, perhaps, mainstream, but it’s familiar to Haskell programmers as the state monad.】
  - 不允许不受限制的堆访问--只看到事务上下文中的数据 •	Disallow unrestricted heap access – only see data in transaction context
  - 明确地将事务上下文传递给事务；这有执行事务性内存操作的操作，并在事务提交失败时回滚 •	Pass transaction context explicitly to transactions; this has operations to perform transactional memory operations, and rollback if the transaction fails to commit
  - 与Haskell中的state monad非常相似 •	Very similar to the state monad in Haskell

# Monadic STM Implementation

![](/static/2022-05-07-19-43-13.png)

- 【**所以，我们已经看到，Haskell限制了函数执行I/O的能力，或通过使用单子来访问内存。单子是Haskell中不太为人所知的部分之一。作为一个不是Haskell程序员的人，我对它们的看法是，Haskell定义了一组可以在特定环境下执行的动作，以及一些规则，即单子，用于在该环境下将这些动作连在一起** So, we’ve seen that Haskell limits the ability of a function to perform I/O, or access memory by using monads. Monads are one of the less well understood parts of Haskell. The way I think of them, as someone who’s not a Haskell programmer, is that Haskell defines a set of actions that can be performed in a certain context, along with some rules, a monad, for chaining together those actions in that context.】
  - 单子→功能语言中控制副作用的方法•	Monads → way to control side-effects in functional languages
  - 一个单子M a描述了一个动作（即一个函数），它产生一个类型为a的结果，可以在上下文M中执行。•	A monad M a describes an action (i.e., a function) that, produces a result of type a, that can be performed in the context M
  - 以及在该上下文中进行连锁操作的规则。•	Along with rules for chaining operations in that context
- 一个常见的用途是**控制I/O**操作。•	A common use is for controlling I/O operations:
  - 【**例如，正如我们在幻灯片上看到的，putChar函数接收一个字符，并返回一个将该字符写入I/O上下文的动作。getChar函数返回一个动作，从I/O上下文中检索一个字符。以此类推。主函数持有I/O上下文，需要读取或写入文件的函数被标记为在该上下文中操作。如果一个函数没有以这种方式被标记，它就不能读或写文件。这使我们有能力在原子事务中限制I/O**  The putChar function, for example, as we see on the slide, takes a character and returns an action that writes the character to the I/O context. The getChar function returns an action that retrieves a character from the I/O context. And so on. The main function holds the I/O context, and functions that need to read or write to files are tagged as operating in that context. And if a function is not tagged in this way, it can’t read or write to files. And this gives us the ability to restrict I/O during atomic transactions.】
    - putChar函数接收一个字符，在IO 上下文进行操作以添加该字符，并且不返回任何东西•	The putChar function takes a character, operates on the IO context to add the character, and returns nothing
    - getChar函数对IO上下文进行操作，返回一个字符。•	The getChar operates on the IO context to return a character
    - 主函数有一个IO上下文，它包裹并执行其他操作•	The main function has an IO context, that wraps and performs other actions
  - I/O单子类型的定义确保了没有被传递给IO上下文的函数不能执行I/O操作。•	The definition of the I/O monad type ensures that a function that is not passed the IO context cannot perform I/O operations
- 软件事务性内存实现的一部分：确保atomic{...}函数不允许它被传递给IO上下文，从而防止I/O. •	One part of a software transactional memory implementation: ensure type of the atomic{…} function does not allow it to be passed an IO context, hence preventing I/O 【**我们确保原子块的定义不被标记为I/O上下文的一部分。这就提供了一种防止原子事务读写文件的方法。因为Haskell的原因，它被复杂的类型理论抽象所包裹，但本质上它只是限制了对执行I/O的函数的访问** We make sure the definition of the atomic block isn’t tagged as being part of the I/O context. This gives a way of preventing atomic transactions from reading or writing files. It’s wrapped in complex type-theoretic abstractions, because Haskell, but essentially it’s just restricting access to the functions that perform I/O.】

---

![](/static/2022-05-07-21-02-16.png)
![](/static/2022-05-07-21-02-23.png)

- **如何跟踪副作用内存操作**？•	How to track side-effecting memory actions? 【**这对控制I/O是有效的，但如何控制对内存的访问呢**】
- 【**Haskell使用了一个类似的方法。状态单子被用来定义STM，软件事务性内存的上下文。函数newTVar定义了一个交易型变量，它存在于这样的上下文中。它持有一个对堆上潜在共享值的引用。readTVar和writeTVar函数返回动作，允许在STM上下文中读写该共享值，但与运行时和原子事务实现协调，以跟踪不同事务之间对该值的冲突访问。原子块的实现提供了一个STM上下文，允许在事务中使用事务性变量，但禁止在该上下文之外使用这些变量。而且，正如我们从幻灯片中看到的那样，原子块返回一个I/O上下文，实际上是将这些值读写到内存中** Haskell uses a similar approach. The state monad is used to define an STM, software transactional memory, context. The function, newTVar, defines a transactional variable, that exists within such a context. This holds a reference to a potentially shared value on the heap. And the readTVar and writeTVar functions return actions that allow reading and writing to that shared value within an STM context, but that coordinate with the runtime and atomic transaction implementation, to track conflicting access to such values between different transactions. And the implementation of an atomic block provides an STM context that allows the transactional variables to be used within a transaction, but prohibits their use outside that context. And, as we see from the slide, the atomic block returns an I/O context that actually reads and write the values to memory.】
    - 定义一个STM单子来包装事务•	Define an STM monad to wrap transactions
    - 基于状态单子；通过TVar类型管理副作用•	Based on the state monad; manages side-effects via a TVar type
    - newTVar函数接收一个类型为a的值，返回新的 持该值的TVar，用STM单子包装。•	The newTVar function takes a value of type a, returns new TVar to hold the value, wrapped in an STM monad
    - readTVar函数接收一个TVar并返回一个STM上下文；当执行时，返回该TVar的值；writeTVar函数接收一个TVar和一个值，返回一个STM上下文，可以验证事务并将值提交到TVar中。•	readTVar takes a TVar and returns an STM context; when performed this returns the value of that TVar; writeTVar function takes a TVar and a value, returns an STM context that can validate the transaction and commit the value to the TVar
  - atomic {...}函数在一个STM上下文中操作，并返回一个IO上下文，执行验证和提交事务所需的操作 •	The atomic {…} function operates in an STM context and returns an IO context that performs the operations needed to validate and commit the transaction
    - newTVar、readTVar和writeTVar函数需要一个STM动作，所以只能在提供这种动作的原子块的上下文中运行。•	The newTVar, readTVar, and writeTVar functions need an STM action, and so can only run in the context of an atomic block that provides such an action
    - 在事务中禁止I/O，因为原子{...}中的操作不能访问I/O上下文 •	I/O prohibited within transactions, since operations in atomic {…} don’t have access to I/O context

# 整合Haskell:Integration into Haskell

> 事务性内存与Haskell很适合。它之所以有效，是因为Haskell提供了必要的类型系统特性来控制I/O和控制其他副作用。纯函数的使用、懒惰评估和单体，都确保了交易语义和ACID属性得以保留。Transactional memory is a good fit with Haskell. And the reason it works is that Haskell provides the necessary type system features to control I/O and control other side effects. The use of pure functions, lazy evaluation, and monads, all ensure that the transaction semantics, the ACID properties, are preserved.
> STM上下文和事务变量的使用，约束和限制了对内存的访问，并跟踪副作用，允许冲突的事务被检测和回滚。原子块的定义，确保了事务不在IO上下文中，防止了对文件的读写，或以其他方式执行I/O。 The STM context, and the use of transactional variables, constrains and limits access to memory, and tracks side effects, allowing conflicting transactions to be detected and rolled back. And the definition of the atomic block, that ensures the transaction is not in the IO context, prevents reading or writing to files, or otherwise performing I/O.
> 其结果是干净而优雅的。这是一个很好的关于并发的抽象。它允许函数的组合，而不需要担心锁定问题。它不会出现死锁。而且，它很容易推理，很容易使用。 The result is clean and elegant. It’s a nice abstraction for concurrency. It allows composition of functions without worrying about locking. It can’t deadlock. And it’s easy to reason about, easy to use.

- 事务性内存与Haskell很适合•	Transactional memory is a good fit with Haskell
  - 纯函数和单子确保交易语义得以保留•	Pure functions and monads ensure transaction semantics are preserved
  - 副作用包含在一个原子{...}块的STM上下文中•	Side-effects are contained in STM context of an atomic {…} block
    - TVar实现负责跟踪副作用•	The TVar implementation is responsible for tracking side effects
    - 原子{...}块验证，然后提交事务（通过返回一个在IO上下文中执行的动作）。•	The atomic {…} block validates, then commits the transaction (by returning an action to perform in the IO context)
    - 一个TVar需要一个STM上下文，但这些只在原子{...}块中可用。不能在事务之外更新TVar，所以不能破坏原子性准则 - Haskell不允许通过指针无限制地访问堆，所以不能颠覆 •	A TVar requires an STM context, but these are only available in an atomic {…} block; can’t update a TVar outside a transaction, so can’t break atomicity guidelines – Haskell doesn’t allow unrestricted heap access via pointers, so can’t subvert
- I/O不能在原子性的{...}块内执行•	I/O cannot be performed within an atomic {…} block
  - 事务不在IO上下文中•	The transaction is not in the IO context

# 整合其他语言：Integration into Other Languages

- 原子事务Haskell非常强大--但要依靠类型系统来确保安全组合和重试 •	Atomic transactions Haskell are very powerful – but rely on the type system to ensure safe composition and retry
- 集成到主流语言中是困难的 •	Integration into mainstream languages is difficult
  - 大多数语言不能强制使用纯函数 •	Most languages cannot enforce use of pure functions
  - 大多数语言不能限制I/O和副作用的使用 •	Most languages cannot limit the use of I/O and side effects
  - 事务内存可以在没有这些的情况下使用，但是需要程序员的纪律来确保正确性--并且有无声的失败模式 •	Transaction memory can be used without these, but requires programmer discipline to ensure correctness – and has silent failure modes
- 不清楚事务性方法是否可以推广到其他语言 •	Unclear if the transactional approach generalises to other languages

# ================
# ================
# ================