# Week1

* [Week1](#week1)
* [How it works without assignment](#how-it-works-without-assignment)
* [Expressions](#expressions)
* [Equations](#equations)
* [Reduction](#reduction)
  * [Unique reduction path](#unique-reduction-path)
  * [Multiple Reduction](#multiple-reduction)
  * [The result doesn’t depend on reduction path!](#the-result-doesnt-depend-on-reduction-path)
* [==============](#)
* [Functions](#functions)
  * [Function definitions](#function-definitions)
  * [匿名函数：Anonymous Function](#匿名函数anonymous-function)
  * [高阶函数：Higher-order functions](#高阶函数higher-order-functions)
* [函数返回多个值](#函数返回多个值)
* [Types](#types)
* [函数组合：Function Composition](#函数组合function-composition)
  * [map组合：composition of maps](#map组合composition-of-maps)
* [函数整体作为（方程）值返回](#函数整体作为方程值返回)
* [函数生成器/参数化函数：parameterised functions](#函数生成器参数化函数parameterised-functions)
* [==============](#-1)
* [Lists](#lists)
* [列表操作](#列表操作)
  * [列表拼接：++](#列表拼接)
  * [索引：!](#索引)
  * [head tail](#head-tail)
  * [添加元素 - ：](#添加元素---)
  * [length](#length)
  * [elem](#elem)
  * [zip](#zip)
  * [zipWith](#zipwith)
* [列表递归/条件函数：Recursion on List, Conditioanl functions](#列表递归条件函数recursion-on-list-conditioanl-functions)
  * [length: 递归计算列表长](#length-递归计算列表长)
  * [filter：Recursive definition](#filterrecursive-definition)
  * [sum](#sum)
* [列表(循环)计算 - for/while Loops](#列表循环计算---forwhile-loops)
* [列表折叠：Folding a list (Reduction)](#列表折叠folding-a-list-reduction)
  * [FoldL](#foldl)
  * [foldr](#foldr)
  * [其他应用](#其他应用)
* [列表函数映射map,folds - 命令式循环关联：Functional Maps and Folds versus Imperative Loops](#列表函数映射mapfolds---命令式循环关联functional-maps-and-folds-versus-imperative-loops)
* [列表懒惰计算](#列表懒惰计算)
  * [lazy evaluation](#lazy-evaluation)
* [列表推导式：List comprehensions](#列表推导式list-comprehensions)
* [==============](#-2)
* [双参函数func->infix运算符](#双参函数func-infix运算符)
* [infix操作符->prefix 操作符/function](#infix操作符-prefix-操作符function)
* [序列：Sequences](#序列sequences)
* [Bool/Relational Operators](#boolrelational-operators)
  * [and, or](#and-or)
* [If Expression](#if-expression)
* [I/O](#io)
  * [putStrLn, getLine, do](#putstrln-getline-do)
  * [read](#read)
  * [show](#show)
* [IO Monads](#io-monads)
  * [Pure Function](#pure-function)
  * [IO Type](#io-type)
  * [Sequencing Actions](#sequencing-actions)
* [==============](#-3)
* [用户自定义类型：User Defined Types](#用户自定义类型user-defined-types)
  * [Recursive Data types - Tree 例子](#recursive-data-types---tree-例子)
* [Type classes](#type-classes)
* [Type parameter](#type-parameter)
* [==============](#-4)
* [作用域：let,where](#作用域letwhere)
  * [let](#let)
  * [where](#where)
  * [let,where区别](#letwhere区别)
* [guard](#guard)
* [case表达式（模式匹配）：Case expression](#case表达式模式匹配case-expression)
  * [case全匹配（通配符）](#case全匹配通配符)
* [模式匹配&guard区别](#模式匹配guard区别)
* [==============](#-5)
* [Maybe: Optional容器](#maybe-optional容器)
* [fmap & maybe](#fmap--maybe)
* [提取Maybe值](#提取maybe值)
* [Maybe用于Do块](#maybe用于do块)
* [==============](#-6)
* [Monads: QUick Primer](#monads-quick-primer)
* [Parser combinators](#parser-combinators)
* [Parsec: monadic parsing combinators](#parsec-monadic-parsing-combinators)
* [varname:Variable names](#varnamevariable-names)
* [Expression Parsers](#expression-parsers)
* [Form of a parser](#form-of-a-parser)
* [parser结构](#parser结构)
* [parser combinator结构](#parser-combinator结构)
* [例子：Parsing alternative strings](#例子parsing-alternative-strings)

# How it works without assignment

never destroy old values, compute new values

* if old value was useless, would be collected by garbage collector

# Expressions

haskell only has expressions， no statements

Pure functional programming languages don’t have any statements — no assignments, no jumps.
纯函数式编程语言没有任何语句ーー没有赋值，没有跳转。

Instead, all computation is performed by evaluating expressions
相反，所有的计算都是通过计算表达式来执行的

---

* **表达式可以包含函数调用**
* id & 形参空格隔开
  * 如果参数是表达式，表达式包括在括号里

```haskell
abs 5 -- > 5
abs (-6) -- > 6
```

# Equations

不是赋值语句，给一个值取名称

* 一个name只能对应一个value
  * “变量”，值不可变

```haskell
n = 1    -- just fine!
x = 3*n  -- fine
n = x    -- Wrong: can have only one definition of n

n = n+1 --可以通过编译，但fail
```

# Reduction

对于命令式程序，我们可以逐条执行语句，跟踪变量(堆栈)的值以及我们在程序中的位置(程序计数器)。

* 归约是将表达式转换为更简单形式的过程。从概念上讲，通过一次简化一个可约表达式(称为“ redex”)来简化表达式。每一步都称为归约，我们将使用 -- > 来显示结果。
* 归约是重要的，因为它是执行函数式程序的唯一手段。没有命令式语言中的语句; 所有的计算都是通过减少表达式来实现的。

## Unique reduction path

![](/static/2022-01-20-03-12-31.png)

## Multiple Reduction

![](/static/2022-01-20-03-13-21.png)

## The result doesn’t depend on reduction path!

A fundamental theorem (the **Church-Rosser theorem**):

一个基本定理(丘奇-罗瑟定理) :

Every terminating reduction path gives the same result

每个终止归约路径给出相同的结果

![](/static/2022-01-20-03-15-01.png)

# ==============

# Functions

* no need to include parenthesis
* concatenation operator `++`

```python
 def hello(name):
        return "Hello, "+name
```

```haskell
hello name = "Hello, " ++name
```

## Function definitions

![](/static/2022-01-20-03-32-38.png)
![](/static/2022-01-20-03-33-28.png)

## 匿名函数：Anonymous Function

![](/static/2022-01-20-01-31-48.png)

```haskell
f = \x y -> x*y+x+y
f 2 3

(\x -> x+1 ) 4
```

## 高阶函数：Higher-order functions

![](/static/2022-01-20-01-36-42.png)

# 函数返回多个值

![](/static/2022-01-20-03-46-29.png)

```haskell
λ sumprod = \x y -> [x+y,x*y]
[x + y,x * y]
:: [Expr]
λ sumprod 3 8
[11,24]
:: Num t => [t]
```

# Types

```c
 int f (int x, int y) {
        return x*y+x+y;
    }
```

```haskell
f :: Int -> Int -> Int
f x y =  x*y+x+y
```

# 函数组合：Function Composition

链式函数

* `g::a->b`
* `f::b->c`
* `f·g`
  * 计算**右到左**

```haskell
(.) :: (b->c) -> (a->b) -> a -> c
(f . g) x = f (g x)

map f (map g xs) = map (f . g) xs

map (+5) (map (*3) [1..10])
map ((+5).(*3)) [1..10]

[8,11,14,17,20,23,26,29,32,35]
:: (Enum b, Num b) => [b]

```

## map组合：composition of maps

```haskell
map f (map g xs) = map (f . g) xs
```

# 函数整体作为（方程）值返回

![](/static/2022-02-03-03-01-26.png)
![](/static/2022-02-03-03-25-48.png)

# 函数生成器/参数化函数：parameterised functions

```haskell
-- 相当于 \n x -> x+n
gen_add_n = \n ->
    \x -> x+n

-- 提供第一个参数N
add_3 = gen_add_n 3
add_7 = gen_add_n 7

-- 后序提供第二个参数 x 
add_3 5 --> 8
add_7 4 --> 11
```

这当然不仅限于数值型常量，例如，下面的函数生成对常数及其参数执行给定算术运算的函数:For example, the following function generates functions that perform a given arithmetic operation on a constant number and their argument:

```haskell
gen_op_n = \op n ->
    \x -> x `op` n

-- 提供 op n
add_3 = gen_op_n (+) 3
mult_7 = gen_op_n (*) 7

-- 提供 x (x `op` n)
add_3 5 --> 8
mult_7 4 --> 28
```

# ==============

# Lists

列表实质由 `:` 和空列表创建而来

* `foldr (:) [] xs`

列表不可变

```haskell
lst = [ "A", "list", "of", "strings"]
lst = [1,2] ++ [3,4]
```

infinity lists

![](/static/2022-01-25-15-45-32.png)

---

# 列表操作

## 列表拼接：++

![](/static/2022-01-20-03-48-50.png)

## 索引：!

![](/static/2022-01-20-03-58-33.png)

## head tail

标准库

![](/static/2022-01-20-04-09-21.png)

## 添加元素 - ：

`:` 底层是 `foldr (:) [] xs`

```haskell
λ 23 : [48, 41, 44]
[23,48,41,44]

λ 42 : []
[42]
:: Num a => [a]
```

## length

```haskell
λ length [23, 29] + length [48, 41, 44] == length ([23, 29] ++ [48, 41, 44])
True
:: Bool
```

```haskell
length ["A","list","of","strings"]
4
```

## elem

判断值是不是列表元素，返回bool

* `elem 1 [1,2,3]` 函数用法
* `3 `elem` [1, 2, 3, 4, 5]` 运算符用法
  * The elem function can be written infix, like an arithmetic operator, by enclosing its name in backquotes ``.

## zip

![](/static/2022-01-20-04-54-21.png)
![](/static/2022-01-20-05-00-04.png)

* 输出长度基于最短输入列表

```haskell

zip [1,2,3] [4,5,6]
[(1,4), (2,5), (3,6)]

-- string is list of char
zip [1,2,3] "abc"
[(1,'a'), (2,'b'), (3,'c')]

zip3 "glasgow" "beijing" "nairobi"
[('g','b','n'), ...]
```

## zipWith

provide function how to combine the elements from the input lists

```haskell
zipWith max [1,2,3] [0,2,4]
[1,2,4]

-- infix op -> prefix func
zipWith (+) [1,2,3] [0,2,4]
[1,4,7]

-- how zip is implemented
zipWith (\x->(\y->(x,y))) [1,2,3] "abc"
[(1,'a'), (2,'b'), (3,'c')]

zipWith (\x y->(x,y)) [1,2,3] "abc"

```

# 列表递归/条件函数：Recursion on List, Conditioanl functions

即conditional functions

![](/static/2022-01-24-23-11-14.png)

* list built from the empty list `[]` and function `cons`
  * base case - `[]`
  * induction case - `(x:xs)`
    * `x` - head
    * `xs` - tail

`():[]` -> `[()]`

`[1,2,3]` -> `1,2,3:[]`

---

length

![](/static/2022-01-25-21-42-41.png)

```haskell
length :: [a] -> Int           -- function type
length [] = 0                  -- base case
length (x:xs) = 1 + length xs  -- recursion case

-- or (in haskell, not web)
length :: [a] -> Int
length [] = 0
length lst = let x:xs = lst in 1 + length xs

-- guard
length :: [a] -> Int
length lst
  | lst == [] = 0
  | otherwise let x:xs in 1 + length xs

  -- one line guard
len lst | lst == [] = 0 | otherwise = 1 + len xs where x:xs
=lst

len lst | lst == [] = 0 | otherwise = let x:xs=lst in 1 + l
en xs

-- not allowed
ghci> len2 (x:xs) | (x:xs) == [] = 0 | otherwise = 1 + len2 xs
ghci> len2 [1..3]
*** Exception: <interactive>:4:1-56: Non-exhaustive patterns in function len2
```

## length: 递归计算列表长

```haskell
length :: [a] -> Int           -- function type
length [] = 0                  -- base case
length (x:xs) = 1 + length xs  -- recursion case

-- []:xs = []?

-- or (in haskell, not web)
length :: [a] -> Int
length [] = 0
length lst = let x:xs = lst in 1 + length xs
```

## filter：Recursive definition

The function filter is given a predicate (a function that gives a Boolean result) and a list, and returns a list of the elements that satisfy the predicate.

Filtering is useful for the “generate and test” programming paradigm.

```haskell
filter::(z->bool)->[a]->[a]
filter f [] = []
filter f (x:xs) = if f x then x:filter f xs 
                  otherwise filter f xs

-- one line guard (注意不分割arg，递归定义的base case包括在里面了)
fil2 pred lst | null lst = [] | otherwise = let x:xs = lst
in if pred x then x:fil2 pred xs else fil2 pred xs

-- base case正常写法
fil pred lst | lst == [] = [] | otherwise = let x:xs=lst in if pred x then x:fil pred xs else fil pred xs

-- one line guard (using where)
fil3 pred lst | null lst = [] | otherwise = if pred x then x:fil3 pred xs else fil3 pred xs where x:xs = lst

filter (<5) [3,9,2,12,6,4]
[3,2,4]
:: (Num a, Ord a) => [a]
```

![](/static/2022-01-24-23-18-57.png)
![](/static/2022-01-24-23-45-14.png)

## sum

sum, fold

# 列表(循环)计算 - for/while Loops

![](/static/2022-01-25-15-34-12.png)

* `map`
  * 列表每个元素计算
  * `map f [x0,x1,x2] -- > [f x0, f x1, f x2]`
* `foldl`
  * left to right
* `foldr`
  * right to left

# 列表折叠：Folding a list (Reduction)

归约后产生标量scalar

accumulator - 初始值

## FoldL

![](/static/2022-01-25-20-06-57.png)

* `foldl f z xs`

```haskell
-- 递归定义，recursive definition of foldl
foldl        :: (b -> a -> b) -> b -> [a] -> b
foldl f z0 xs0 = lgo z0 xs0
             where
                lgo z []     =  z
                lgo z (x:xs) = lgo (f z x) xs

foldl (\acc elt -> elt:acc) "" "Reversing a string"
```
![](/static/2022-01-25-22-56-41.png)

`foldl (\acc elt -> acc++[elt]) "" "A string"`

* 注意 `[]`，因为`++`只能拼接字符串



---

![](/static/2022-01-25-20-09-28.png)

中缀符号例子 Examples of foldl with infix notation

![](/static/2022-01-25-20-23-30.png)

## foldr

![](/static/2022-01-25-20-39-06.png)
![](/static/2022-01-25-20-42-44.png)

```haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr k z = go
          where
            go []     = z
            go (y:ys) = y `k` go ys
```

foldr & cons（`:`）

![](/static/2022-01-25-20-48-47.png)

## 其他应用

![](/static/2022-01-25-20-56-49.png)

```haskell
sum xs = foldr (+) 0 xs
product xs = foldr (*) 1 xs

-- “point free” style
sum      = foldr (+) 0
product  = foldr (*) 1
```

# 列表函数映射map,folds - 命令式循环关联：Functional Maps and Folds versus Imperative Loops

https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103586

```haskell
map :: (a -> b) -> [a] -> [b]
foldl :: (b -> a -> b) -> b -> [a] -> b 
foldr :: (a -> b -> b) -> b -> [a] -> b
```

# 列表懒惰计算

![](/static/2022-01-20-04-11-30.png)
![](/static/2022-01-20-04-20-25.png)

## lazy evaluation

![](/static/2022-01-20-03-47-23.png)

# 列表推导式：List comprehensions

![](/static/2022-01-20-03-55-44.png)

* 列表操作推导为表达式
* 左边|我们有一个表达式，对右边的列表的每个元素都进行了计算。表达式中的参数是用左箭头<-指定的。

```haskell
[3*x | x <- [1..10]]
-- >
[3,6,9,12,15,18,21,24,27,30]

[2*x | x <- [0..10]]
-- >
[0,2,4,6,8,10,12,14,16,18,20]

[2*x + 1 | x <- [0..10]]
-- >  
[1,3,5,7,9,11,13,15,17,19,21]

[[a,b] | a <- [10,11,12] , b <- [20,21]]
-- >
[[10,20],[10,21],[11,20],[11,21],[12,20],[12,21]]

[2*x+1 | x <- [0,2..10]]
-- >
[1,5,9,13,17,21]
```

# ==============

# 双参函数func->infix运算符

In fact, **Haskell permits any two-argument function to be written as an infix operator**  using **backquote** characters. For a further example, try the max function as an infix operator: 42 `max` 13

```haskell
42 `max` 13
42
:: (Num a, Ord a) => a
```

# infix操作符->prefix 操作符/function

Also note that any Haskell infix operator, e.g. +, can be written as a **prefix operator/function by enclosing it in parentheses**, like (+) 1 1

```haskell
(+) 1 1
2
:: Num a => a
```



# 序列：Sequences

![](/static/2022-01-20-03-51-35.png)

* 序列生成列表
  * 序列写入方括号，[start..end]
* 序列值
  * 枚举
    * char
    * int

```haskell
λ [0x0A .. 0x1F]
[10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]
```

# Bool/Relational Operators

* 不能比较两个具有不同类型的值
* `==`
* `/=`
* `<, <=, >, >=`
  * `[1,2,3] < [1,2,3,4]` Note that relational operators also work on lists, in a dictionary-order manner (lexicographic).
  * Since **strings are lists of characters** in Haskell, we can do the same kinds of comparison operations on strings. Check whether Aardvark comes before Aaronic in the dictionary with this code: `"Aardvark" < "Aaronic"`
* `not`
  * `not True`
  * `not (not False)`
* `&&` infix
  * `True && True`
* `||` infix
* `xor` function

```haskell
-- Notice that we specify xor as an infix function with the backquotes here
True `xor` False
```

枚举双输入布尔函数的全部真值表是很直接的。我们可以用一个列表理解表达式来列举输入值。[(x,y) | x<-[False, True], y<-[False, True]] 。然后我们可以在这些输入值上映射布尔函数（从对中提取）。例如，这里是xor函数的列举的输出值：map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]]It's straightforward to enumerate the full truth table for two-input boolean functions. We could use a list comprehension expression to enumerate the input values: [(x,y) | x<-[False, True], y<-[False, True]]. Then we could map the boolean function over these input values (extracted from the pairs). For instance, here are the enumerated output values for the xor function: map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]].

```haskell
[(x,y) | x<-[False, True], y<-[False, True]]
[(False,False),(False,True),(True,False),(True,True)]

map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]]
[False,True,True,False]
:: [Bool]
```

## and, or

有时，像AND和OR这样的布尔逻辑函数有两个以上的输入。Haskell支持这些多输入的布尔运算，有and和or函数，这些函数将布尔值列表作为单一输入。实际上，这是对输入布尔值列表的&&或||运算符的折叠。Sometimes, boolean logic functions like AND and OR have more than two inputs. Haskell supports these multi-input boolean operations with and and or functions that take a list of boolean values as a single input. Effectively, this is a fold of the && or || operator over the input list of boolean values.

```haskell
and [False, True, False, True]
False

or [True, True, False]
True
```

# If Expression

Haskell有if表达式，它根据if值，评估为then值或else值。

* Haskell的if表达式等同于类C语言中的?: 三元运算符。第一个子表达式（在if之后）的类型必须是Bool，然后后面的两个子表达式（分别在then和else之后）的类型必须是相同的 The Haskell if expression is equivalent to the ?: ternary operator in C-like languages. The first subexpression (after the if) must have type Bool, then the subsequent two subexpressions (after then and else respectively) must have the same type as each other.
  * 无效
    * `if 1 then 0 else -1`
    * `if False then 42 else "foo"`

```haskell
if 2*2==4 then "happy" else "sad"
"happy"
:: [Char]

-- 有可能两个值是相似的，也就是说，根据它们的类型类别，它们可以被专门化为同一类型
-- It is possible to have two values that are similar, i.e. they could be specialized to the same type, based on their type classes.
if True then 42 else pi
42.0
```

# I/O

## putStrLn, getLine, do

向终端打印字符串的Haskell函数叫做`putStrLn`（像Java中的println或Python中的print）。

* `putStrLn ("good " ++ "morning" ++ " everyone")`

读入 & do structure

* `do`
  * 排列IO操作
  * <-用于在do块中把名字和值联系起来，而->则用于定义函数。<- is for associating names with values in do blocks whereas -> is used for defining functions.

```haskell
λ getLine
> read
"read"
:: IO String

-- 正如我们所看到的，你可以用do结构来排列IO操作。用左边的箭头将值绑定到变量上。我们可以把它理解为x从getLine中获得一个值。请注意，你不能对getLine使用标准的赋值（等价操作），因为它是一个IO操作 As we have seen, you can sequence IO operations with the do construct. Values are bound to variables using the left arrow. We could read this as x gets a value from getLine. Be aware that you can't use the standard assignment (with the equals operator) for getLine, since it is an IO operation.
do { putStrLn "what is your name?"; x <- getLine; putStrLn ("hello " ++ x) }

-- 一旦我们从getLine得到一个值，并把它绑定到一个变量上，那么我们就可以对这个值进行标准的函数调用，并把它绑定到另一个变量上 Once we have got a value from getLine, and bound it to a variable, then we can do standard function calls on this value, and bind it to another variable
do { putStrLn "what is your name?"; n<-getLine; let nUpper = map toUpper n in putStrLn ("HELLO " ++ nUpper) } 
```

$ 中缀操作

* `($) :: (a -> b) -> a -> b`
* 给一个 a->b函数，和参数a，输出b
  * `putStrLn $ "hello"++name`

## read

可以将数值读成字符串，并将其转换为其他类型。这就像C语言中的atoi函数一样。试试读 "42":: Int。你需要::Int类型注释，否则就不清楚输入的String是代表什么类型的数字 It is possible to read values as strings, and convert them into other types. This is like the atoi function in C. Try read "42" :: Int. You need the ::Int type annotation otherwise it is not clear what type of number the input String is meant to represent.

```haskell
read "42" :: Int
42
:: Int

read "42"::Float
42.0
:: Float
```

## show

![](/static/2022-01-26-14-08-20.png)

* 自动提供引号。。
* 然后`print "hello world"`输入是show类型，输出成IO()类型，结果其实打印的是 `\"hello world\"`

show函数是read函数的对偶。 show接收一个值并返回该值的一个字符串表示 The show function is the dual of the read function. show takes a value and returns a String representation of that value. 

* 请注意，返回的值具有String类型。只有一些类型（派生出Show的类型）可以转换为字符串 Notice that the returned value has the String type. Only some types (those that derive Show) can be converted to Strings
* show函数(之后的结果)，允许打印出任意的值
  * `putStrLn (show (6*7))`
    * 等价于 `print (6*7)`

```haskell
show 42
"42"
:: String
```

# IO Monads

## Pure Function

https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103578

到目前为止，我们集中讨论了纯函数。这些类型的函数将值作为参数，对这些值进行一些处理，然后返回结果值。一个纯函数不依赖于“世界的状态”。计算是完全自包含和独立的。给定相同的参数，纯函数总是返回相同的结果。So far, we have concentrated on pure functions. These kinds of functions take values as arguments, do some processing of those values, then return a result value. A pure function does not depend on the ‘state of the world’. The computation is entirely self-contained and independent. Given the same arguments, a pure function will always return the same result.

## IO Type

![](/static/2022-01-20-05-42-54.png)

## Sequencing Actions

```haskell
let greet() = do 
    planet <- getLine
    home <- getLine
    putStrLn ("greetings " ++ planet ++ "ling.")
    putStrLn ("I am from " ++ home ++ ".")
    putStrLn "Take me to your leader."

-- 在 do 中，我们使用 <-将 IO 函数的结果与名称关联起来。在 let 中，我们使用 = 将纯函数结果与名称关联起来。
do { planet <- getLine; home <- getLine; putStrLn ("greetings " ++ planet ++ "ling."); putStrLn ("I am from " ++ home ++ "."); putStrLn "Take me to your leader."}
```

Order of function evaluation doesn’t matter in pure code - e.g. **函数求值**的顺序在纯代码中并不重要。

```haskell
-- 我们是否在第二次之前做第一次反转并不重要ーー表达式的结果仍然是相同的。
-- 然而，在 i/o 方面并非如此。排序对 i/o 操作至关重要。
let a = reverse "winston"
    b = reverse "churchill"
in "sir " ++ a ++ " " ++ b

-- 在 do 中，我们使用 <-将 IO 函数的结果与名称关联起来。在 let 中，我们使用 = 将纯函数结果与名称关联起来。
let a= reverse "winston"; b = reverse "churchill"  in "sir " ++a ++" "++ b
```

# ==============

# 用户自定义类型：User Defined Types

(algebraic data types)

user-defined types

* sum type - valled variant type
  * Called “sum” because in algebraic terms, “OR” and sum are related
* product type - record type
  * Called “sum” because in algebraic terms, “AND” and product are related


`data Xxx = ...|...|... deriving Show`

* alternative values relate to algebraic sums

`data Bool = False | True`

* data = 的左端标明类型的名称即 Bool，= 的右端就是值构造子 (Value Constructor)，它们明确了该类型可能的值。| 读作"或" 以上可以理解为：Bool 类型的值可以是 True 或 False。
* **类型名和值构造子的首字母必大写**。
* 项（field）：可以在值构造子后面选择性的加入一些type（s），如下例中Circle 的值构造子有三个项，也可以理解成有三个参数，皆为浮点数
  * `data Shape = Circle Float Float Float`
  * 值构造子本质函数，可以返回一个类型的值
    * `:t Circle`
    * `Circle :: Float -> Float -> Float -> Shape`

![](/static/2022-01-26-12-07-54.png)

* 类型标识符大写
* 如果需要打印type的值，必须包括`deriving Show`

record types (product data types)

* 利用type constructors
  * `Score [Char] Int Int`
    * `Score`是constructor name，可以和type name相同，但是为了避免混淆建议不一样
* record values relate to algebraic products

![](/static/2022-01-26-12-10-51.png)

---

constant

![](/static/2022-01-26-14-55-47.png)
![](/static/2022-01-26-14-55-57.png)

non constant

![](/static/2022-01-26-14-56-42.png)
![](/static/2022-01-26-14-57-24.png)

pattern matching

![](/static/2022-01-26-14-59-45.png)

example product type (record)

![](/static/2022-01-26-20-41-26.png)
![](/static/2022-01-26-20-55-47.png)

## Recursive Data types - Tree 例子

![](/static/2022-01-26-13-08-16.png)

```haskell
let l = Node 3 Leaf Leaf

:t l
l :: Tree

:t Node
Node :: Int -> Tree -> Tree -> Tree
```

![](/static/2022-01-26-13-14-23.png)

* `treeSum :: Tree -> Int`

![](/static/2022-01-26-13-24-39.png)
![](/static/2022-01-26-13-39-40.png)

# Type classes

type class就类似类型的基类/接口

* 表示后面的type variable is instance of 某个type class
* ![](/static/2022-01-26-13-53-05.png)

```haskell
:t read
-- 注意输入 String,输出a必须显式指明类型
read :: Read a => String -> a
```

利用`deriving`指定某type属于某type class

![](/static/2022-01-26-13-56-00.png)
![](/static/2022-01-26-13-56-30.png)
![](/static/2022-01-26-13-57-17.png)

---

* a type class constrains member types (instances) to conform to an API
* Type classes are like interfaces in C# and Java
* Types in the type class are like concrete implementations of interfaces
* Type classes enable **operator overloading**

# Type parameter

![](/static/2022-02-03-02-28-43.png)

![](/static/2022-02-03-02-28-54.png)
![](/static/2022-02-03-02-29-28.png)

# ==============

# 作用域：let,where

## let

```haskell
let x = 2
    y = 3
in x+y
```

在一个 let 中，一个变量可能依赖于另一个变量

```haskell
journeycost :: Float -> Float -> Float
journeycost miles fuelcostperlitre = 
 let milespergallon = 35
     litrespergallon = 4.55
     gallons = miles/milespergallon
 in (gallons*litrespergallon*fuelcostperlitre)

let diameter = 2*radius
    circumference = pi*diameter
in (diameter, circumference)
```

## where

方程式中的 where 关键字提供了**方程式**中使用的变量的定义。The where keyword, inside an equation, provides definitions for variables that are used in the equation.

![](/static/2022-02-03-02-58-36.png)

* 注意位置

```haskell
-- 注意where缩进
squareplusone :: Int -> Int
squareplusone x = xsquared + 1
 where xsquared = x*x

cel2fahr :: Float -> Float
cel2fahr x = (x*scalingfactor) + freezingpoint
 where scalingfactor = 9.0/5.0
       freezingpoint = 32
```

## let,where区别

![](/static/2022-02-03-01-55-00.png)

对于let和where混用，那么是let的优先级高，也就是说优先使用let定义的变量，而不是where定义的变量，比如

```haskell
-- 等于11而不是12
f x =
    let y = x+1
    in y
    where y = x+2
*Main> f 10
11
```

# guard

Haskell 提供了一种基于**谓词值定义函数**的符号。

* `otherwise`
  * 如果前面没有guard评估为True，otherwise一定为True

```
f x
  | predicate1 = expression1
  | predicate2 = expression2
  | predicate3 = expression3
```

---

例子1

`absolute x = if (x<0) then (-x) else x `

```haskell
absolute x
  | x<0 = -x
  | otherwise = x
```

Guards are easier to read than if/then/else if there are more than two conditional outcomes

---

如果有两个以上的条件结果，guard比 if/then/else 更容易理解

例子2

```haskell
holeScore :: Int -> Int -> String
holeScore strokes par
  | strokes < par = show (par-strokes) ++ " under par"
  | strokes == par = "level par"
  | strokes > par = show(strokes-par) ++ " over par"

  -- clean up ,用where重构

holeScore :: Int -> Int -> String
holeScore strokes par
  | score < 0 = show (abs score) ++ " under par"
  | score == 0 = "level par"
  | otherwise = show(score) ++ " over par"
where score = strokes-par
```

# case表达式（模式匹配）：Case expression

模式匹配

![](/static/2022-02-03-02-17-36.png)

```haskell
data Pet = Cat | Dog | Fish

-- 每个模式后面都有一个箭头和一个值
hello :: Pet -> String
hello x = 
  case x of
    Cat -> "meeow"
    Dog -> "woof"
    Fish -> "bubble"
```

---

```haskell
data Pet = Cat | Dog | Fish | Parrot String

hello :: Pet -> String
hello x = 
  case x of
    Cat -> "meeow"
    Dog -> "woof"
    Fish -> "bubble"
    Parrot name -> "pretty " ++ name

-- 注意Parrot这个值构造子
hello (Parrot "polly")
> "pretty polly"
```

## case全匹配（通配符）

guard有otherwise，case有 `_`

```haskell
data Pet = Cat | Dog | Fish | Parrot String

hello :: Pet -> String
hello x =
  case x of
    Parrot name -> "pretty " ++ name
    _ -> "grunt"
```

# 模式匹配&guard区别

![](/static/2022-02-03-02-02-04.png)

# ==============

# Maybe: Optional容器

maybe数据类型data type（Prelude）

* `Nothing`
* `Just a`

![](/static/2022-02-03-02-34-44.png)

---

例子

![](/static/2022-02-03-02-44-14.png)
![](/static/2022-02-03-02-44-42.png)

# fmap & maybe

![](/static/2022-02-03-05-26-38.png)

```haskell
let inc = (+1)
:t inc
Num a -> a -> a

-- 通过fmap使inc能应用于Maybe
fmap inc (Just 1)
> Just 2

fmap inc Nothing
> Nothing
```

# 提取Maybe值

![](/static/2022-02-03-05-18-42.png)

* `fromJust :: Prelude.Maybe a -> a`

# Maybe用于Do块

![](/static/2022-02-03-05-28-26.png)

# ==============

# Monads: QUick Primer

You may have heard the term monad before, and we will discuss the concept in detail in a later session. Haskell uses monads to structure computations. You have already encountered the IO monad, which you need to use to perform IO in a Haskell program. A typical example is 您可能以前听说过单子这个术语，我们将在以后的会议中详细讨论这个概念。Haskell 使用单子来构造计算。您已经遇到了 IO monad，需要使用它在 Haskell 程序中执行 IO。一个典型的例子是

* 这说明了 monad 的关键语法特性: do 关键字、命令序列、使用左箭头 <-和 return 关键字从一元计算中提取信息的方法。事实上，do-notation 的使用与命令式编程非常相似。 This illustrates the key syntactic features of a monad: the do keyword, the sequence of commands, the way to extract information from a monadic computation using the left arrow <- and the return keyword. In fact, using the do-notation is quite similar to imperative programming.
* 还要注意 hello 函数的返回值: 不只是 String，还有 IO String。在单子中完成的计算返回一个“单子”类型，我们说字符串在单子中返回。Also note the return value of our hello function: **not just String but IO String**. **A computation done in a monad returns a “monadic” type**, we say that the **string is returned inside the monad**.

```haskell
hello :: String -> IO String
hello x =
  do
     putStrLn ("Hello, " ++ x)
     putStrLn "What's your name?"
     name <- getLine
     return name
```

# Parser combinators

![](/static/2022-02-03-03-33-58.png)

# Parsec: monadic parsing combinators

![](/static/2022-02-03-03-34-27.png)

导入Parsec

* ` import Text.ParserCombinators.Parsec`

Parsec 提供了方便的 parseTest 函数，该函数接受一个解析器和一个字符串并运行它。让我们尝试在字符串“ cons”上运行解析器 char‘ b’:

* `parseTest (char 'b') "cons"`

---

![](/static/2022-02-03-04-06-03.png)

# varname:Variable names

![](/static/2022-02-03-04-07-15.png)

# Expression Parsers

![](/static/2022-02-03-04-08-01.png)
![](/static/2022-02-03-04-09-39.png)
![](/static/2022-02-03-04-09-55.png)
![](/static/2022-02-03-04-11-11.png)
![](/static/2022-02-03-04-11-22.png)

# Form of a parser

例如，假设我们要解析表单的字符串(< Tag >) ，其中(Tag)必须是一个单词，并将标记作为类型(Tag)返回。For example, suppose we want to parse a string of the form (< tag>), where (tag) must be a word, and return the tag as a type (Tag).

```haskell
data Tag = MkTag String

parseTag :: Parser Tag
parseTag =
  do  char '<'
      x <- identifier
      char '>'
      return (MkTag x)
```

正如您所看到的，解析器由许多按顺序调用的**函数**(例如 **char** 和 **identifier**)组成。此外，**返回值的类型是 Parser Tag**，而不是简单的 Tag。这是**因为 parse Tag 不返回值，而是返回一个解析器**。我们可以将这个解析器与其他解析器结合起来，然后可以对数据执行最终的解析器。我们将在本教程中更详细地介绍这种方法。As you can see, the parser consists of a number of functions (e.g. char and identifier) that are called sequentially. Also, the return value is of type Parser Tag, not simply Tag. This is because parseTag is not returning a value, instead it returns a parser. We can combine this parser with other parsers, and then we can execute the final parser on our data. We will cover this approach in more detail in the tutorial.

# parser结构

![](/static/2022-02-03-03-54-48.png)
![](/static/2022-02-03-03-55-39.png)

# parser combinator结构

![](/static/2022-02-03-03-56-39.png)

---

alternative parsers

![](/static/2022-02-03-03-58-04.png)

![](/static/2022-02-03-03-59-02.png)

# 例子：Parsing alternative strings

![](/static/2022-02-03-04-01-31.png)
![](/static/2022-02-03-04-01-51.png)
![](/static/2022-02-03-04-02-59.png)
![](/static/2022-02-03-04-04-48.png)
![](/static/2022-02-03-04-05-02.png)
