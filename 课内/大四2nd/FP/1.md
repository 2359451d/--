# Week1

* [Week1](#week1)
* [How it works without assignment](#how-it-works-without-assignment)
* [Expressions](#expressions)
* [Equations](#equations)
* [Reduction](#reduction)
  * [Unique reduction path](#unique-reduction-path)
  * [Multiple Reduction](#multiple-reduction)
  * [The result doesn’t depend on reduction path!](#the-result-doesnt-depend-on-reduction-path)
* [==============](#)
* [Functions](#functions)
  * [Function definitions](#function-definitions)
  * [匿名函数：Anonymous Function](#匿名函数anonymous-function)
  * [高阶函数：Higher-order functions](#高阶函数higher-order-functions)
* [函数返回多个值](#函数返回多个值)
* [函数组合：Function Composition](#函数组合function-composition)
  * [map组合：composition of maps](#map组合composition-of-maps)
* [函数整体作为（方程）值返回](#函数整体作为方程值返回)
* [函数生成器/参数化函数：parameterised functions](#函数生成器参数化函数parameterised-functions)
* [Monomorphic functions](#monomorphic-functions)
* [参数化多态 & Ad-hoc多态： Parametric polymorphism，Ad hoc polymorphism.](#参数化多态--ad-hoc多态-parametric-polymorphismad-hoc-polymorphism)
* [多态函数：Polymorphic functions](#多态函数polymorphic-functions)
* [柯里化: Currying](#柯里化-currying)
* [偏函数应用：Partial Application](#偏函数应用partial-application)
* [分组&函数应用：Grouping - arrow to the right, application left](#分组函数应用grouping---arrow-to-the-right-application-left)
* [Lambda](#lambda)
  * [转换规则-归约(Reduction)：Conversion rules](#转换规则-归约reductionconversion-rules)
* [==============](#-1)
* [Lists](#lists)
* [列表操作](#列表操作)
  * [列表比较](#列表比较)
  * [列表拼接：++](#列表拼接)
  * [索引：!](#索引)
  * [head tail](#head-tail)
  * [添加元素 - ：](#添加元素---)
  * [length](#length)
  * [elem](#elem)
  * [zip](#zip)
  * [zipWith](#zipwith)
* [可枚举List-序列：Sequences](#可枚举list-序列sequences)
* [无限序列：Infinite Data Structure](#无限序列infinite-data-structure)
* [列表递归/条件函数：Recursion on List, Conditioanl functions](#列表递归条件函数recursion-on-list-conditioanl-functions)
  * [length: 递归计算列表长](#length-递归计算列表长)
  * [filter：Recursive definition](#filterrecursive-definition)
  * [sum](#sum)
* [列表(循环)计算 - for/while Loops](#列表循环计算---forwhile-loops)
* [列表折叠：Folding a list (Reduction)](#列表折叠folding-a-list-reduction)
  * [FoldL](#foldl)
  * [foldr](#foldr)
  * [其他应用](#其他应用)
* [列表函数映射map,folds - 命令式循环关联：Functional Maps and Folds versus Imperative Loops](#列表函数映射mapfolds---命令式循环关联functional-maps-and-folds-versus-imperative-loops)
* [列表懒惰计算](#列表懒惰计算)
  * [lazy evaluation](#lazy-evaluation)
* [列表推导式：List comprehensions](#列表推导式list-comprehensions)
* [==============](#-2)
* [元组：Tuple](#元组tuple)
* [==============](#-3)
* [双参函数func->infix运算符](#双参函数func-infix运算符)
* [前缀，中缀：infix操作符->prefix 操作符/function](#前缀中缀infix操作符-prefix-操作符function)
* [dollar函数 - `$`](#dollar函数---)
* [布尔/关系操作符：Bool/Relational Operators](#布尔关系操作符boolrelational-operators)
  * [and, or](#and-or)
* [==============](#-4)
* [Monad](#monad)
* [: Optional容器](#-optional容器)
* [Functors](#functors)
* [Functor Law](#functor-law)
* [fmap &](#fmap-)
* [提取值](#提取值)
* [用于Do块](#用于do块)
* [==============](#-5)
* [Monad](#monad-1)
* [>>= Monadic Bind](#-monadic-bind)
* [I/O](#io)
  * [putStrLn, getLine, do](#putstrln-getline-do)
  * [read](#read)
  * [show](#show)
* [IO Monads](#io-monads)
  * [Pure Function](#pure-function)
  * [IO Type](#io-type)
  * [Sequencing Actions](#sequencing-actions)
* [Do](#do)
* [Monad类型类&接口：Monad and Type classes](#monad类型类接口monad-and-type-classes)
* [Monad规则：monad laws](#monad规则monad-laws)
* [Utility Functions](#utility-functions)
* [==============](#-6)
* [Maps](#maps)
* [==============](#-7)
* [用户自定义/代数数据类型：User Defined Types/algebraic data types](#用户自定义代数数据类型user-defined-typesalgebraic-data-types)
* [data关键字：声明自定义类型](#data关键字声明自定义类型)
  * [Recursive Data types - Tree 例子](#recursive-data-types---tree-例子)
* [函数类型](#函数类型)
* [Type classes](#type-classes)
* [派生：deriving](#派生deriving)
* [Record类型](#record类型)
* [类型参数(泛型)](#类型参数泛型)
* [与Either](#与either)
* [类型别名 type synonym](#类型别名-type-synonym)
* [==============](#-8)
* [class关键字：定义typeclass（接口）](#class关键字定义typeclass接口)
* [定义类型类&实例：例子](#定义类型类实例例子)
* [==============](#-9)
* [内置类型类](#内置类型类)
  * [Num](#num)
  * [其他数值类的层次结构 Hierarchy of numeric classes](#其他数值类的层次结构-hierarchy-of-numeric-classes)
  * [其他](#其他)
* [Show](#show-1)
  * [自定义Show类型类实例](#自定义show类型类实例)
  * [Deriving Show](#deriving-show)
* [例子 -（+）类型类](#例子--类型类)
* [类型推断：Type Inference](#类型推断type-inference)
* [参数化类型例子(类型构造器：泛型)-Type parameter](#参数化类型例子类型构造器泛型-type-parameter)
* [==============](#-10)
* [作用域：let,where](#作用域letwhere)
  * [let-in表达式](#let-in表达式)
  * [where子句](#where子句)
  * [let,where区别](#letwhere区别)
* [条件语句：If Expression](#条件语句if-expression)
* [模式匹配基础：pattern matching](#模式匹配基础pattern-matching)
* [guard](#guard)
* [case表达式：Case expression](#case表达式case-expression)
  * [case全匹配（通配符）](#case全匹配通配符)
* [模式匹配&guard区别](#模式匹配guard区别)
* [Applicative](#applicative)
* [==============](#-11)
* [Monads: QUick Primer](#monads-quick-primer)
* [解析组合器：Parser combinators](#解析组合器parser-combinators)
* [parser combinator结构](#parser-combinator结构)
* [基本组合器](#基本组合器)
  * [char](#char)
  * [anyChar](#anychar)
  * [many](#many)
  * [noneOf](#noneof)
  * [<|>, parenns](#-parenns)
* [try](#try)
* [一元解析组合器：Parsec: monadic parsing combinators](#一元解析组合器parsec-monadic-parsing-combinators)
* [varname解析例子:Variable names](#varname解析例子variable-names)
* [表达式解析器：Expression Parsers](#表达式解析器expression-parsers)
* [makeTokenParser](#maketokenparser)
* [Form of a parser](#form-of-a-parser)
* [parser结构](#parser结构)
* [例子：Parsing alternative strings](#例子parsing-alternative-strings)
* [解析xml标签例子](#解析xml标签例子)
  * [xml格式](#xml格式)
  * [parseList（生成list标签）](#parselist生成list标签)
  * [parseTuples (生成tuple标签)](#parsetuples-生成tuple标签)
  * [parseRecord (解析record类型string，生成record标签)](#parserecord-解析record类型string生成record标签)
  * [parseDiv（生成div数据类型）](#parsediv生成div数据类型)
  * [parseShow](#parseshow)
  * [record type](#record-type)
  * [module - ShowParser](#module---showparser)

# How it works without assignment

never destroy old values, compute new values

* if old value was useless, would be collected by garbage collector

# Expressions

haskell only has expressions， no statements

Pure functional programming languages don’t have any statements — no assignments, no jumps.
纯函数式编程语言没有任何语句ーー没有赋值，没有跳转。

Instead, all computation is performed by evaluating expressions
相反，所有的计算都是通过计算表达式来执行的

---

* **表达式可以包含函数调用**
* id & 形参空格隔开
  * 如果参数是表达式，表达式包括在括号里

```haskell
abs 5 -- > 5
abs (-6) -- > 6
```

# Equations

不是赋值语句，给一个值取名称

* 一个name只能对应一个value
  * “变量”，值不可变

```haskell
n = 1    -- just fine!
x = 3*n  -- fine
n = x    -- Wrong: can have only one definition of n

n = n+1 --可以通过编译，但fail
```

# Reduction

对于命令式程序，我们可以逐条执行语句，跟踪变量(堆栈)的值以及我们在程序中的位置(程序计数器)。

* 归约是将表达式转换为更简单形式的过程。从概念上讲，通过一次简化一个可约表达式(称为“ redex”)来简化表达式。每一步都称为归约，我们将使用 -- > 来显示结果。
* 归约是重要的，因为它是执行函数式程序的唯一手段。没有命令式语言中的语句; 所有的计算都是通过减少表达式来实现的。

## Unique reduction path

![](/static/2022-01-20-03-12-31.png)

## Multiple Reduction

![](/static/2022-01-20-03-13-21.png)

## The result doesn’t depend on reduction path!

A fundamental theorem (the **Church-Rosser theorem**):

一个基本定理(丘奇-罗瑟定理) :

Every terminating reduction path gives the same result

每个终止归约路径给出相同的结果

![](/static/2022-01-20-03-15-01.png)

# ==============

# Functions

* no need to include parenthesis
* concatenation operator `++`

```python
 def hello(name):
        return "Hello, "+name
```

```haskell
hello name = "Hello, " ++name
```

## Function definitions

![](/static/2022-01-20-03-32-38.png)
![](/static/2022-01-20-03-33-28.png)

## 匿名函数：Anonymous Function

![](/static/2022-01-20-01-31-48.png)

```haskell
f = \x y -> x*y+x+y
f 2 3

(\x -> x+1 ) 4
```

## 高阶函数：Higher-order functions

![](/static/2022-01-20-01-36-42.png)

# 函数返回多个值

![](/static/2022-01-20-03-46-29.png)

```haskell
λ sumprod = \x y -> [x+y,x*y]
[x + y,x * y]
:: [Expr]
λ sumprod 3 8
[11,24]
:: Num t => [t]
```

# 函数组合：Function Composition

链式函数

* `g::a->b`
* `f::b->c`
* `f·g`
  * 计算**右到左**，右结合

```haskell
(.) :: (b->c) -> (a->b) -> a -> c
(f . g) x = f (g x)

map f (map g xs) = map (f . g) xs

map (+5) (map (*3) [1..10])
map ((+5).(*3)) [1..10]

[8,11,14,17,20,23,26,29,32,35]
:: (Enum b, Num b) => [b]

```

函数组合可以用来制造新函数，并且能够把参数抽出来

* 通过组合把内层参数抽离出来，并利用柯里化特性去掉。这种只通过函数组合得到的，不涉及实际参数的函数风格被称为pointfree style

```haskell
-- f x = 2 * (sqrt x) + 1
-- 对应的pointfree style
f = (+ 1) . (* 2) . sqrt
```

## map组合：composition of maps

```haskell
map f (map g xs) = map (f . g) xs
```

# 函数整体作为（方程）值返回

![](/static/2022-02-03-03-01-26.png)
![](/static/2022-02-03-03-25-48.png)

# 函数生成器/参数化函数：parameterised functions

```haskell
-- 相当于 \n x -> x+n
gen_add_n = \n ->
    \x -> x+n

-- 提供第一个参数N
add_3 = gen_add_n 3
add_7 = gen_add_n 7

-- 后序提供第二个参数 x 
add_3 5 --> 8
add_7 4 --> 11
```

这当然不仅限于数值型常量，例如，下面的函数生成对常数及其参数执行给定算术运算的函数:For example, the following function generates functions that perform a given arithmetic operation on a constant number and their argument:

```haskell
gen_op_n = \op n ->
    \x -> x `op` n

-- 提供 op n
add_3 = gen_op_n (+) 3
mult_7 = gen_op_n (*) 7

-- 提供 x (x `op` n)
add_3 5 --> 8
mult_7 4 --> 28
```

# Monomorphic functions

单形的意思是“具有一种形式”。 Monomorphic means “having one form”.

```haskell
f :: Int -> Char
f i = "abcdefghijklmnopqrstuvwxyz" !! i

x :: Int
x = 3

f :: Char->String
f x = x:" There is a kind of character in thy life"
```

# 参数化多态 & Ad-hoc多态： Parametric polymorphism，Ad hoc polymorphism.

Parametric polymorphism

![](/static/2022-02-08-22-43-09.png)

Ad hoc polymorphism

多态类型，可以被**实例化**为**从一个集合中选择的任何类型**，称为 "类型类" A polymorphic type that can be instantiated to any type chosen from a set, called a “type class”

* 通常用`=>`**约束**类型变量 Represented by a type variable that is constrained using the `=>` notation.
  * 限制了多态性
* ![](/static/2022-02-08-22-45-06.png)
  * 感觉类似 `<Class extends Num>`

# 多态函数：Polymorphic functions

多态意味着“有多种形式”。Polymorphic means “having many forms”.

```haskell
fst :: (a,b) -> a
fst (x,y) = x

snd :: (a,b) -> b
snd (x,y) = y

fst :: (a,b) -> a
fst (a,b) = a

snd :: (a,b) -> b
snd (a,b) = b
```

# 柯里化: Currying

柯里化(Currying)是把**接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数**, 并且返回接受余下的参数且返回结果的新函数的技术

* 柯里化是为了把一个多参函数转换成单参函数，这个单参函数返回另一个单参函数（参数数量不足），或者求值（参数数量够了）

![](/static/2022-02-08-22-13-02.png)

---

函数签名右结合（`->`右结合）

![](/static/2022-02-08-23-00-01.png)

Haskell函数默认都是柯里化的，都只接受一个参数：

![](/static/2022-03-16-19-06-20.png)
![](/static/2022-03-16-19-08-27.png)

# 偏函数应用：Partial Application

![](/static/2022-02-08-23-00-25.png)
![](/static/2022-02-08-23-01-48.png)

* 用一个参数将一个具有多个参数的函数重写成一系列函数的技巧称为局部套用
* 部分应用程序意味着我们**不需要为一个函数提供所有参数**

---

![](/static/2022-03-16-19-10-27.png)

# 分组&函数应用：Grouping - arrow to the right, application left

The arrow operator takes two types `a->b`, and gives the type of a function with argument type `a` and result type `b` 箭头运算符接受两种类型 `a->b`，并给出参数类型为 `a` 和结果类型为 `b` 的函数的类型

An application `e1 e2` applies a function `e1` to an argument `e2` 函数应用 `e1 e2`, 将e1应用于参数e2

Note that for both types and applications, a function has only one argument 请注意，对于类型和函数应用，函数只有一个参数

* To make the notation work smoothly, arrows group to the right, and application groups to the left. 为了使符号工作顺利，箭头组向右，函数应用组向左。
* ![](/static/2022-02-08-22-55-43.png)
* lambda同理![](/static/2022-02-08-22-56-35.png)
  * ![](/static/2022-02-08-22-58-23.png)

```haskell
-- 下面等价的，函数签名右结合，每一步take一个参数返回一个函数，，（除了参数c）
f :: a -> b -> c -> d
f :: a -> (b -> (c -> d))

-- 左结合...每结合一个返回下一个的函数
-- 结合第一个参数x返回函数 (b->(c->d))
f x y z = ((f x) y) z
```

# Lambda

![](/static/2022-02-09-00-53-16.png)
![](/static/2022-02-09-00-54-07.png)

变量约束：free, bound

![](/static/2022-02-09-00-37-26.png)
![](/static/2022-02-09-00-37-51.png)

## 转换规则-归约(Reduction)：Conversion rules

![](/static/2022-02-09-00-38-45.png)

Alpha conversion

![](/static/2022-02-09-00-35-00.png)

Beta conversion
![](/static/2022-02-09-00-40-07.png)

---

Eta conversion
![](/static/2022-02-09-00-40-47.png)
![](/static/2022-02-09-00-41-39.png)

Removing a common trailing argument 剔除共同尾参数

![](/static/2022-02-09-00-49-16.png)
![](/static/2022-02-09-00-46-12.png)

# ==============

# Lists

字符串字面量只是个List语法糖

---

列表实质由 `:` 和空列表创建而来

* `foldr (:) [] xs`
* `[1, 2, 3]`实际上是`1 : 2 : 3 : []`的语法糖，:右结合得到完整List

列表不可变

```haskell
lst = [ "A", "list", "of", "strings"]
lst = [1,2] ++ [3,4]
-- 或者用concat,, concat [[1,2],[3,4]]
```

infinity lists

![](/static/2022-01-25-15-45-32.png)

---

# 列表操作

## 列表比较

如果List中元素可比较，则List可比较（遍历比较各元素）：

```haskell
> "hello" == ['h', 'e', 'l', 'l', 'o']
True
> "0110" > "0101"
True
```

## 列表拼接：++

注意，++操作会遍历左边的List，所以性能不高

![](/static/2022-01-20-03-48-50.png)

## 索引：!

![](/static/2022-01-20-03-58-33.png)

## head tail

标准库

![](/static/2022-01-20-04-09-21.png)

## 添加元素 - ：

`:` 底层是 `foldr (:) [] xs`

```haskell
λ 23 : [48, 41, 44]
[23,48,41,44]

λ 42 : []
[42]
:: Num a => [a]
```

## length

```haskell
λ length [23, 29] + length [48, 41, 44] == length ([23, 29] ++ [48, 41, 44])
True
:: Bool
```

```haskell
length ["A","list","of","strings"]
4
```

## elem

判断值是不是列表元素，返回bool

* `elem 1 [1,2,3]` 函数用法
* `3 `elem` [1, 2, 3, 4, 5]` 运算符用法
  * The elem function can be written infix, like an arithmetic operator, by enclosing its name in backquotes ``.

## zip

![](/static/2022-01-20-04-54-21.png)
![](/static/2022-01-20-05-00-04.png)

* 输出长度基于最短输入列表

```haskell

zip [1,2,3] [4,5,6]
[(1,4), (2,5), (3,6)]

-- string is list of char
zip [1,2,3] "abc"
[(1,'a'), (2,'b'), (3,'c')]

zip3 "glasgow" "beijing" "nairobi"
[('g','b','n'), ...]
```

## zipWith

provide function how to combine the elements from the input lists

```haskell
zipWith max [1,2,3] [0,2,4]
[1,2,4]

-- infix op -> prefix func
zipWith (+) [1,2,3] [0,2,4]
[1,4,7]

-- how zip is implemented
zipWith (\x->(\y->(x,y))) [1,2,3] "abc"
[(1,'a'), (2,'b'), (3,'c')]

zipWith (\x y->(x,y)) [1,2,3] "abc"

```

# 可枚举List-序列：Sequences

一种用来生成可枚举List的便捷方式，例如：

* 浮点数存在精度的问题

![](/static/2022-01-20-03-51-35.png)

* 序列生成列表
  * 序列写入方括号，[start..end]
* 序列值
  * 枚举
    * char
    * int

```haskell
λ [0x0A .. 0x1F]
[10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]
```

# 无限序列：Infinite Data Structure

[1..]

repeat 1

![](/static/2022-02-08-20-53-13.png)

```haskell
--  不设上限的Range
> take 3 [1..]
[1,2,3]
--  或者cycle函数无限重复
> take 7 (cycle [1..3])
[1,2,3,1,2,3,1]
--  或者repeat生成单元素无限重复的List
> take 6 (repeat 3)
[3,3,3,3,3,3]
--  上一句结果等价于
> replicate 6 3
[3,3,3,3,3,3]
```

# 列表递归/条件函数：Recursion on List, Conditioanl functions

即conditional functions

![](/static/2022-01-24-23-11-14.png)

* list built from the empty list `[]` and function `cons`
  * base case - `[]`
  * induction case - `(x:xs)`
    * `x` - head
    * `xs` - tail

`():[]` -> `[()]`

`[1,2,3]` -> `1,2,3:[]`

---

length

![](/static/2022-01-25-21-42-41.png)

```haskell
length :: [a] -> Int           -- function type
length [] = 0                  -- base case
length (x:xs) = 1 + length xs  -- recursion case

-- or (in haskell, not web)
length :: [a] -> Int
length [] = 0
length lst = let x:xs = lst in 1 + length xs

-- guard
length :: [a] -> Int
length lst
  | lst == [] = 0
  | otherwise let x:xs in 1 + length xs

  -- one line guard
len lst | lst == [] = 0 | otherwise = 1 + len xs where x:xs
=lst

len lst | lst == [] = 0 | otherwise = let x:xs=lst in 1 + l
en xs

-- not allowed
ghci> len2 (x:xs) | (x:xs) == [] = 0 | otherwise = 1 + len2 xs
ghci> len2 [1..3]
*** Exception: <interactive>:4:1-56: Non-exhaustive patterns in function len2
```

## length: 递归计算列表长

```haskell
length :: [a] -> Int           -- function type
length [] = 0                  -- base case
length (x:xs) = 1 + length xs  -- recursion case

-- []:xs = []?

-- or (in haskell, not web)
length :: [a] -> Int
length [] = 0
length lst = let x:xs = lst in 1 + length xs
```

## filter：Recursive definition

The function filter is given a predicate (a function that gives a Boolean result) and a list, and returns a list of the elements that satisfy the predicate.

Filtering is useful for the “generate and test” programming paradigm.

```haskell
filter::(z->bool)->[a]->[a]
filter f [] = []
filter f (x:xs) = if f x then x:filter f xs 
                  otherwise filter f xs

-- one line guard (注意不分割arg，递归定义的base case包括在里面了)
fil2 pred lst | null lst = [] | otherwise = let x:xs = lst
in if pred x then x:fil2 pred xs else fil2 pred xs

-- base case正常写法
fil pred lst | lst == [] = [] | otherwise = let x:xs=lst in if pred x then x:fil pred xs else fil pred xs

-- one line guard (using where)
fil3 pred lst | null lst = [] | otherwise = if pred x then x:fil3 pred xs else fil3 pred xs where x:xs = lst

filter (<5) [3,9,2,12,6,4]
[3,2,4]
:: (Num a, Ord a) => [a]
```

![](/static/2022-01-24-23-18-57.png)
![](/static/2022-01-24-23-45-14.png)

## sum

sum, fold

# 列表(循环)计算 - for/while Loops

![](/static/2022-01-25-15-34-12.png)

* `map`
  * 列表每个元素计算
  * `map f [x0,x1,x2] -- > [f x0, f x1, f x2]`
* `foldl`
  * left to right
* `foldr`
  * right to left

# 列表折叠：Folding a list (Reduction)

归约后产生标量scalar

accumulator - 初始值

## FoldL

![](/static/2022-01-25-20-06-57.png)

* `foldl f z xs`

```haskell
-- 递归定义，recursive definition of foldl
foldl        :: (b -> a -> b) -> b -> [a] -> b
foldl f z0 xs0 = lgo z0 xs0
             where
                lgo z []     =  z
                lgo z (x:xs) = lgo (f z x) xs

foldl (\acc elt -> elt:acc) "" "Reversing a string"
```
![](/static/2022-01-25-22-56-41.png)

`foldl (\acc elt -> acc++[elt]) "" "A string"`

* 注意 `[]`，因为`++`只能拼接字符串



---

![](/static/2022-01-25-20-09-28.png)

中缀符号例子 Examples of foldl with infix notation

![](/static/2022-01-25-20-23-30.png)

## foldr

![](/static/2022-01-25-20-39-06.png)
![](/static/2022-01-25-20-42-44.png)

```haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr k z = go
          where
            go []     = z
            go (y:ys) = y `k` go ys
```

foldr & cons（`:`）

![](/static/2022-01-25-20-48-47.png)

## 其他应用

![](/static/2022-01-25-20-56-49.png)

```haskell
sum xs = foldr (+) 0 xs
product xs = foldr (*) 1 xs

-- “point free” style
sum      = foldr (+) 0
product  = foldr (*) 1
```

# 列表函数映射map,folds - 命令式循环关联：Functional Maps and Folds versus Imperative Loops

https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103586

```haskell
map :: (a -> b) -> [a] -> [b]
foldl :: (b -> a -> b) -> b -> [a] -> b 
foldr :: (a -> b -> b) -> b -> [a] -> b
```

# 列表懒惰计算

![](/static/2022-01-20-04-11-30.png)
![](/static/2022-01-20-04-20-25.png)

## lazy evaluation

![](/static/2022-01-20-03-47-23.png)

# 列表推导式：List comprehensions

![](/static/2022-01-20-03-55-44.png)

* 列表操作推导为表达式
* 左边|我们有一个表达式，对右边的列表的每个元素都进行了计算。表达式中的参数是用左箭头<-指定的。

```haskell
[3*x | x <- [1..10]]
-- >
[3,6,9,12,15,18,21,24,27,30]

[2*x | x <- [0..10]]
-- >
[0,2,4,6,8,10,12,14,16,18,20]

[2*x + 1 | x <- [0..10]]
-- >  
[1,3,5,7,9,11,13,15,17,19,21]

[[a,b] | a <- [10,11,12] , b <- [20,21]]
-- >
[[10,20],[10,21],[11,20],[11,21],[12,20],[12,21]]

[2*x+1 | x <- [0,2..10]]
-- >
[1,5,9,13,17,21]

-- 还可以添加更多限制条件（predicate）：

> [ 2 * x | x <- [1..5], 2 * x `mod` 3 == 1, x `mod` 5 /= 0 ]
[4]

-- 除了加限制条件过滤，还可以通过let声明变量/函数：

> [ doubleX | x <- [1..5], let doubleX =  2 * x, doubleX `mod` 3 == 1, x `mod` 5 /= 0 ]
[4]
```

# ==============

# 元组：Tuple

元组不要求单一元素类型，从类型约束来看，相当于结构体

* 如果元组中的元素可比较，那么同类型元组也可以比较

```haskell
> :t (1, "Leon")
(1, "Leon") :: Num t => (t, [Char])
```

---

常用函数

`fst/snd`

* 注意，这两个函数只能用于二元组。一般元组没有类似的工具函数，但可以通过模式匹配来自己实现：
  * -- 取三元组首元
    * first (x, _, _) = x

```haskell
fst (1, 2)
snd (1, 2)

-- zip从List组合出元组：
zip [1, 2] ['A', 'B', 'C']
[(1,'A'),(2,'B')]
```

# ==============

# 双参函数func->infix运算符

In fact, **Haskell permits any two-argument function to be written as an infix operator**  using **backquote** characters. For a further example, try the max function as an infix operator: 42 `max` 13

```haskell
42 `max` 13
42
:: (Num a, Ord a) => a
```

# 前缀，中缀：infix操作符->prefix 操作符/function

Also note that any Haskell infix operator, e.g. +, can be written as a **prefix operator/function by enclosing it in parentheses**, like (+) 1 1

```haskell
(+) 1 1
2
:: Num a => a
```

```haskell
--  前缀转中缀
prefixFunc a b
a `prefixFunc` b

--  中缀转前缀
a infixFunc b
(infixFunc) a b
```

# dollar函数 - `$`

![](/static/2022-03-16-18-50-40.png)

中缀函数，要求左边函数，右边参数

![](/static/2022-03-16-18-51-24.png)



# 布尔/关系操作符：Bool/Relational Operators

* 不能比较两个具有不同类型的值
* `==`
* `/=`
* `<, <=, >, >=`
  * `[1,2,3] < [1,2,3,4]` Note that relational operators also work on lists, in a dictionary-order manner (lexicographic).
  * Since **strings are lists of characters** in Haskell, we can do the same kinds of comparison operations on strings. Check whether Aardvark comes before Aaronic in the dictionary with this code: `"Aardvark" < "Aaronic"`
* `not`
  * `not True`
  * `not (not False)`
* `&&` infix
  * `True && True`
* `||` infix
* `xor` function

```haskell
-- Notice that we specify xor as an infix function with the backquotes here
True `xor` False
```

枚举双输入布尔函数的全部真值表是很直接的。我们可以用一个列表理解表达式来列举输入值。[(x,y) | x<-[False, True], y<-[False, True]] 。然后我们可以在这些输入值上映射布尔函数（从对中提取）。例如，这里是xor函数的列举的输出值：map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]]It's straightforward to enumerate the full truth table for two-input boolean functions. We could use a list comprehension expression to enumerate the input values: [(x,y) | x<-[False, True], y<-[False, True]]. Then we could map the boolean function over these input values (extracted from the pairs). For instance, here are the enumerated output values for the xor function: map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]].

```haskell
[(x,y) | x<-[False, True], y<-[False, True]]
[(False,False),(False,True),(True,False),(True,True)]

map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]]
[False,True,True,False]
:: [Bool]
```

## and, or

有时，像AND和OR这样的布尔逻辑函数有两个以上的输入。Haskell支持这些多输入的布尔运算，有and和or函数，这些函数将布尔值列表作为单一输入。实际上，这是对输入布尔值列表的&&或||运算符的折叠。Sometimes, boolean logic functions like AND and OR have more than two inputs. Haskell supports these multi-input boolean operations with and and or functions that take a list of boolean values as a single input. Effectively, this is a fold of the && or || operator over the input list of boolean values.

```haskell
and [False, True, False, True]
False

or [True, True, False]
True
```

# ==============

#  Monad

Example use of : Safe head and tail
![](/static/2022-02-09-01-58-57.png)

Monad类型的数据类型实例

![](/static/2022-02-09-02-00-45.png)
![](/static/2022-02-09-02-01-07.png)

---

![](/static/2022-02-09-02-10-41.png)
![](/static/2022-02-09-02-12-07.png)
![](/static/2022-02-09-02-12-52.png)
![](/static/2022-02-09-02-21-54.png)
![](/static/2022-02-09-02-22-40.png)

# : Optional容器

数据类型data type（Prelude）

* `Nothing`
* `Just a`

![](/static/2022-02-03-02-34-44.png)

```haskell
data  a = Just a | Nothing
```

Effectively we are extending the set of values in type variable a, by adding one additional value that indicates the absence of a meaningful value. We can define our own functions that return  values – try defining 实际上，我们正在扩展类型变量a的值集，增加一个额外的值，表示没有一个有意义的值。我们可以定义我们自己的函数来返回也许值--尝试定义

```haskell
safeHead :: [a] ->  a
safeHead [] = Nothing
safeHead (x:xs) = Just x

safeTail :: [a] ->  [a]
safeTail [] = Nothing
safeTail (x:xs) = safeTail Just xs

```

使用值可以确保函数总是富有成效的--它们总是为每个输入返回一个值......它们不会抛出异常（这通常会杀死一个Haskell程序）。Using  values ensure functions are always productive – they always return a value for every input … they do not throw exceptions (which generally kill a Haskell program).

在一个特定的库中，有一些处理值的实用函数。There are a few utility functions for dealing with  values, in a specific library:

* `import Data.`

---

例子

![](/static/2022-02-03-02-44-14.png)
![](/static/2022-02-03-02-44-42.png)

# Functors

Given some data (like an Int value) wrapped up in a structure (like a ), how do we apply a function to the wrapped Int value? The answer is to use fmap, which operates on the Functor typeclass. 给定一些数据（如一个Int值）被包裹在一个结构（如一个）中，我们如何将一个函数应用于被包裹的Int值？答案是使用fmap，它在Functor类型类上操作。

* 容器context

```haskell
-- :: hastype
-- f a - context
fmap :: Functor f => (a -> b) -> f a -> f b

•	fmap (+1) (Just 3)
•	fmap (*2) [1,2,3]
•	fmap (fmap Data.Char.toUpper) getLine
```

---

自定义Functor, & fmap

```haskell
data MagicBox a = MagicBox a deriving (Read,Show,Eq,Ord)
instance Functor MagicBox where 
  fmap f (MagicBox x) = MagicBox (f x)

fmap not (MagicBox True)
```

中序符号

* `<$>`
* `(+1) <$> [1,2,3]`

---

# Functor Law

The Functor typeclass is used for types that can be mapped over. Instances of Functor are expected to follow these rules: Functor类型类用于可以被映射的类型。Functor的实例被期望遵循这些规则。

identity:

    fmap id  ==  id

composition:

    fmap (f . g)  ==  fmap f . fmap g

# fmap & 

map the function over the  context

![](/static/2022-02-03-05-26-38.png)

```haskell
let inc = (+1)
:t inc
Num a -> a -> a

-- 通过fmap使inc能应用于
fmap inc (Just 1)
> Just 2

fmap inc Nothing
> Nothing
```

# 提取值

![](/static/2022-02-03-05-18-42.png)

* `fromJust :: Prelude. a -> a`

# 用于Do块

![](/static/2022-02-03-05-28-26.png)

# ==============

# Monad

它被用来描述一系列步骤的计算，并处理诸如状态和 i/o 之类的副作用

![](/static/2022-02-09-00-59-37.png)

结构

![](/static/2022-02-09-01-00-48.png)

* type constructor `M`
  * ![](/static/2022-02-09-01-02-44.png)
* function `return::a->M a`
  * ![](/static/2022-02-09-01-03-42.png)
* function `(>>=)::M a->(a->M b)-> M b`
  * ![](/static/2022-02-09-01-07-16.png)

# >>= Monadic Bind

All Monads are Applicatives, and all Applicatives are Functors. This typeclass inheritance is now baked into the Haskell standard library. The key extra function in a Monad instance is the “bind” function, written >>=. The behaviour of  >>= is related to fmap and <*>. Let’s compare their types: 所有单体都是应用体，而所有应用体都是函子。这种类型的继承现在已经被植入了Haskell标准库。Monad实例中的关键额外函数是 "绑定 "函数，写成>>=。>>=的行为与fmap和<*>有关。让我们比较一下它们的类型。

```haskell
fmap :: Functor f => (a->b) -> f a -> f b -- <$>
(<*>) :: Applicative f => f (a->b) -> f a -> f b
(>>=) :: Monad f => f a -> (a -> f b) -> f b
```

So the bind function takes a value embedded inside a structure, and a function that expects the non-embedded value, then returns a new embedded value. Let’s demonstrate this with a simple example on Lists. 所以绑定函数接收一个嵌入在结构中的值，以及一个期望非嵌入值的函数，然后返回一个新的嵌入值。让我们用一个关于Lists的简单例子来证明这一点。

```haskell
[1,2,3] >>= (\n -> [(show n), "mississippi"])
["1","mississippi","2","mississippi","3","mississippi"]
```

---

According to the Monad typeclass specification, a Monad type m must provide implementations of three characteristic functions: 根据单体类型规范，一个单体类型m必须提供三个特征函数的实现。

```haskell
return :: a -> m a                      -- embed
(>>)   :: m a -> m b -> m b             -- sequence
(>>=)  :: m a -> (a -> m b) -> m b      -- bind
```

In fact, the default implementation of >> is defined in terms of >>= so it’s not necessary to provide the >> definition when typeclassing Monad. Note that >> and >>= are both used in the desugaring of do blocks. 事实上，>>的默认实现是用>>=来定义的，所以在对Monad进行类型化时，没有必要提供>>的定义。注意，>>和>>=都用于do块的析构。

# I/O

## putStrLn, getLine, do

向终端打印字符串的Haskell函数叫做`putStrLn`（像Java中的println或Python中的print）。

* `putStrLn ("good " ++ "morning" ++ " everyone")`

读入 & do structure

* `do`
  * 排列IO操作
  * <-用于在do块中把名字和值联系起来，而->则用于定义函数。<- is for associating names with values in do blocks whereas -> is used for defining functions.

```haskell
λ getLine
> read
"read"
:: IO String

-- 正如我们所看到的，你可以用do结构来排列IO操作。用左边的箭头将值绑定到变量上。我们可以把它理解为x从getLine中获得一个值。请注意，你不能对getLine使用标准的赋值（等价操作），因为它是一个IO操作 As we have seen, you can sequence IO operations with the do construct. Values are bound to variables using the left arrow. We could read this as x gets a value from getLine. Be aware that you can't use the standard assignment (with the equals operator) for getLine, since it is an IO operation.
do { putStrLn "what is your name?"; x <- getLine; putStrLn ("hello " ++ x) }

-- 一旦我们从getLine得到一个值，并把它绑定到一个变量上，那么我们就可以对这个值进行标准的函数调用，并把它绑定到另一个变量上 Once we have got a value from getLine, and bound it to a variable, then we can do standard function calls on this value, and bind it to another variable
do { putStrLn "what is your name?"; n<-getLine; let nUpper = map toUpper n in putStrLn ("HELLO " ++ nUpper) } 
```

$ 中缀操作

* `($) :: (a -> b) -> a -> b`
* 给一个 a->b函数，和参数a，输出b
  * `putStrLn $ "hello"++name`

## read

![](/static/2022-03-17-00-05-56.png)

可以将数值读成字符串，并将其转换为其他类型。这就像C语言中的atoi函数一样。试试读 "42":: Int。**你需要::Int类型注释，否则就不清楚输入的String是代表什么类型的数字** It is possible to read values as strings, and convert them into other types. This is like the atoi function in C. Try read "42" :: Int. You need the ::Int type annotation otherwise it is not clear what type of number the input String is meant to represent.

```haskell
read "42" :: Int
42
:: Int

read "42"::Float
42.0
:: Float
```

## show

![](/static/2022-01-26-14-08-20.png)

* **自动提供引号**。。
  * ![](/static/2022-02-08-17-20-40.png)
* 然后`print "hello world"`输入是show类型，输出成IO()类型，结果其实打印的是 `\"hello world\"`

show函数是read函数的对偶。 show接收一个值并返回该值的一个字符串表示 The show function is the dual of the read function. show takes a value and returns a String representation of that value. 

* 请注意，返回的值具有String类型。只有一些类型（派生出Show的类型）可以转换为字符串 Notice that the returned value has the String type. Only some types (those that derive Show) can be converted to Strings
* show函数(之后的结果)，允许打印出任意的值
  * `putStrLn (show (6*7))`
    * 等价于 `print (6*7)`

```haskell
show 42
"42"
:: String
```

# IO Monads

One way of thinking about monads is that they allow scoping of effects within the type system. The IO Monad allows us to ‘contain’ side-effects, or identify non-pure code from the type signature of that code. 关于单体的一种思考方式是，它们允许在类型系统内对效果进行范围界定。IO单体允许我们 "包含 "副作用，或者从代码的类型签名中识别非纯代码。

```haskell
getLine :: IO String  -- not actually a function!
putStrLn :: String -> IO( )
main :: IO ()  -- not actually a function!
readFile :: FilePath -> IO String
writeFile :: FilePath -> String -> IO ()
randomIO :: Random a => IO a
getCurrentTime :: IO UTCTime -- not actually a function!
```

## Pure Function

https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103578

到目前为止，我们集中讨论了纯函数。这些类型的函数将值作为参数，对这些值进行一些处理，然后返回结果值。一个纯函数不依赖于“世界的状态”。计算是完全自包含和独立的。给定相同的参数，纯函数总是返回相同的结果。So far, we have concentrated on pure functions. These kinds of functions take values as arguments, do some processing of those values, then return a result value. A pure function does not depend on the ‘state of the world’. The computation is entirely self-contained and independent. Given the same arguments, a pure function will always return the same result.

## IO Type

![](/static/2022-01-20-05-42-54.png)

## Sequencing Actions

```haskell
let greet() = do 
    planet <- getLine
    home <- getLine
    putStrLn ("greetings " ++ planet ++ "ling.")
    putStrLn ("I am from " ++ home ++ ".")
    putStrLn "Take me to your leader."

-- 在 do 中，我们使用 <-将 IO 函数的结果与名称关联起来。在 let 中，我们使用 = 将纯函数结果与名称关联起来。
do { planet <- getLine; home <- getLine; putStrLn ("greetings " ++ planet ++ "ling."); putStrLn ("I am from " ++ home ++ "."); putStrLn "Take me to your leader."}
```

Order of function evaluation doesn’t matter in pure code - e.g. **函数求值**的顺序在纯代码中并不重要。

```haskell
-- 我们是否在第二次之前做第一次反转并不重要ーー表达式的结果仍然是相同的。
-- 然而，在 i/o 方面并非如此。排序对 i/o 操作至关重要。
let a = reverse "winston"
    b = reverse "churchill"
in "sir " ++ a ++ " " ++ b

-- 在 do 中，我们使用 <-将 IO 函数的结果与名称关联起来。在 let 中，我们使用 = 将纯函数结果与名称关联起来。
let a= reverse "winston"; b = reverse "churchill"  in "sir " ++a ++" "++ b
```

# Do

需要编写 "命令式 "的代码，为我们排列基于IO的计算。do块语法糖提供了一个方便的方法来做到这一点。

```haskell
import Data.Time.Clock
import Data.Time.Calendar


currentYear = do
  x <- getCurrentTime -- IO UTCTIME
  let d = utctDay x
  let (y,_,_) = toGregorian d
  return y

-- 等同

currentYear =
  getCurrentTime >>=
    (\x -> let d=utctDay x in let (y,_,_)=toGregorian d in return y)
```

---

![](/static/2022-02-09-01-55-05.png)

Syntax rules for do

```haskell
do { x }  -- >  x

-- 执行x，，执行<xs>
do {x ; <xs> }  -- >  x >> do { <xs> }

-- 执行 x结果传入<xs>继续执行
do { a <- x ; <xs> }  -- >  x >>= \a -> do { <xs> }

do { let <declarations> ; xs }
  -- >
let <declarations> in do { xs }
```

# Monad类型类&接口：Monad and Type classes

![](/static/2022-02-09-01-08-12.png)

![](/static/2022-02-09-01-12-04.png)
![](/static/2022-02-09-01-12-33.png)

# Monad规则：monad laws

Like Functors and Applicatives, there are laws that govern the behaviour of functions in the Monad typeclass. All implementations of Monad should respect these laws. 就像Functors和Applicatives一样，在Monad类型中也有一些规律来约束函数的行为。所有Monad的实现都应该尊重这些规律。

* right unit law:
  * `m >>= return        ==    m`
  * ![](/static/2022-05-11-03-27-52.png)
* The left unit law:
  * `return x >>= f      ==    f x`
* The associativity law:
  * `(m >>= f) >>= g     ==    m >>= (\x -> f x >>= g)`

![](/static/2022-02-09-01-54-32.png)

# Utility Functions

![](/static/2022-05-11-04-12-44.png)
![](/static/2022-05-11-04-22-41.png)

```haskell

liftM
liftM2
liftM<n>

mapM
mapM_

replicateM
replicateM_

```

# ==============

# Maps

The type Map k a corresponds to a generic dictionary with keys of type k and values of type a. The key typeclass constraint is that k belongs to the Ord typeclass, i.e. we can use comparison operators and assume a total ordering of its values. 类型Map k a对应于一个通用的字典，其键为k类型，值为a类型。键的类型约束是k属于Ord类型，即我们可以使用比较运算符并假定其值的总排序。

```haskell
m = Data.Map.fromList [("london", 2012), ("rio", 2016), ("tokyo", 2020)]
m1 = insert "beijing" 2008 m
size m1
cities = keys m1
years = elems m1
next = lookup "tokyo" m1
```

关于Haskell Maps有两件有趣的事情需要注意。

1）这些是纯粹的功能数据结构--没有破坏性的更新。m和m1（在上面的例子中）可以愉快地共存，并尽可能地共享状态。这意味着频繁地修改这种数据结构可能需要大量的内存。1) these are purely functional data structures – there is no destructive update. m and m1 (in the above example) can co-exist happily and share state where possible. This means frequent modification of such data structures can be memory-intensive.

2）查找函数返回一个值--如果键在Map中丢失，则返回Nothing。这意味着许多Map的计算可能是在 monad中进行的。2) the lookup function returns a  value – if the key is missing from the Map then Nothing is returned. This means many Map computations might be in the  monad.



# ==============

# 用户自定义/代数数据类型：User Defined Types/algebraic data types

代数数据类型是结合其他类型作为记录(“乘积”)的类型，Algebraic data types are types that combine other types either as records (‘products’),

(**algebraic data types**) 代数数据类型

user-defined types

* sum type - valued variant type
  * Called “sum” because in algebraic terms, “OR” and sum are related
  * sum：逻辑或，例如类型的可能值之间是逻辑或关系
* product type - record type
  * Called “product” because in algebraic terms, “AND” and product are related
  * product：逻辑与，例如元组分量之间是逻辑与的关系
* ![](/static/2022-03-17-00-09-44.png)
* 通过逻辑或和逻辑与能造出来任意复杂的数据结构，都可以称为代数数据类型

---

# data关键字：声明自定义类型

通过data关键字来声明自定义类型：

* **值构造器**本质上是**函数**
  * 值构造器的参数（field）
* **模式匹配**也可以用于自定义类型

![](/static/2022-03-17-00-12-36.png)

`data Xxx = ...|...|... deriving Show`

* alternative values relate to algebraic sums
* **variants**

`data Bool = False | True`

* data = 的左端标明类型的名称即 Bool，= 的右端就是值构造子 (Value Constructor)，它们明确了该类型可能的值。| 读作"或" 以上可以理解为：Bool 类型的值可以是 True 或 False。
* **类型名和值构造子的首字母必大写**。
* 项（field）：可以在值构造子后面选择性的加入一些type（s），如下例中Circle 的值构造子有三个项，也可以理解成有三个参数，皆为浮点数
  * `data Shape = Circle Float Float Float`
  * 值构造子本质函数，可以返回一个类型的值
    * `:t Circle`
    * `Circle :: Float -> Float -> Float -> Shape`

![](/static/2022-01-26-12-07-54.png)

* 类型标识符大写
* 如果需要打印type的值，必须包括`deriving Show`

record types (product data types)

* 利用type constructors
  * `Score [Char] Int Int`
    * `Score`是constructor name，可以和type name相同，但是为了避免混淆建议不一样
* record values relate to algebraic products

![](/static/2022-01-26-12-10-51.png)

---

constant

![](/static/2022-01-26-14-55-47.png)
![](/static/2022-01-26-14-55-57.png)

non constant

![](/static/2022-01-26-14-56-42.png)
![](/static/2022-01-26-14-57-24.png)

pattern matching

![](/static/2022-01-26-14-59-45.png)

example product type (record)

![](/static/2022-01-26-20-41-26.png)
![](/static/2022-01-26-20-55-47.png)

## Recursive Data types - Tree 例子

![](/static/2022-01-26-13-08-16.png)

```haskell
let l = Node 3 Leaf Leaf

:t l
l :: Tree

:t Node
Node :: Int -> Tree -> Tree -> Tree
```

![](/static/2022-01-26-13-14-23.png)

* `treeSum :: Tree -> Int`

![](/static/2022-01-26-13-24-39.png)
![](/static/2022-01-26-13-39-40.png)

# 函数类型

```haskell
show :: Show a => a -> String
odd :: Integral a => a -> Bool
fromIntegral :: (Num b, Integral a) => a -> b
(+) :: Num a => a -> a -> a
(++) :: [a] -> [a] -> [a]
```

::到=>之间的部分是**类型约束**（声明类型变量），

* =>之后的部分是其类型。类型声明中的小写字母（例如a）叫做**类型变量**，
* **未加限定的类型变量（如++类型中的a）相当于泛型**，用到类型变量的函数称之为多态函数

# Type classes

Eq被称为typeclass，相当于interface，即定义了该类型成员必须具有的行为

```haskell
(==) :: Eq a => a -> a -> Bool
```

---

其他常见typeclass

![](/static/2022-03-17-00-04-37.png)

---

type class就类似类型的基类/接口

* 类型类是定义了某些操作的一组类型。A type class is a set of types for which some operations are defined.
* 表示后面的type variable is instance of 某个type class
* ![](/static/2022-01-26-13-53-05.png)

```haskell
:t read
-- 注意输入 String,输出a必须显式指明类型
read :: Read a => String -> a
```

利用`deriving`指定某type属于某type class

![](/static/2022-01-26-13-56-00.png)
![](/static/2022-01-26-13-56-30.png)
![](/static/2022-01-26-13-57-17.png)

---

* a type class constrains member types (instances) to conform to an API
* Type classes are like interfaces in C# and Java
* Types in the type class are like concrete implementations of interfaces
* Type classes enable **operator overloading**

# 派生：deriving

通过deriving关键字声明类型派生，让一个类型的值也成为其它类型的成员。

除Show外，其它几个能够自动添上默认行为的typeclass是`Eq, Ord, Enum, Bounded, Read`。

* 比如派生自Eq后可以通过==和/=来比较值的相等性：
  * 当然，要求参数也必须是Eq类成员，否则无法自动比较（如果不满足，就会抛个错出来）

```haskell
-- 派生自Eq时自动添的相等性判断就是检查输入参数是否一致：
-- 1.检查值构造器是否一致
-- 2.检查值构造器的参数是否一致
data Mytype = Mytype Int String deriving (Show, Eq)
> Mytype 3 "a" == Mytype 4 "b"
False
> Mytype 3 "a" == Mytype 3 "a"
True
```

**Show, Read**

* 用来完成字符串与值之间的互相转换：

```haskell
data Mytype = Mytype Int String deriving (Show, Eq, Read)
> Mytype 3 "a"
Mytype 3 "a"
> read "Mytype 3 \"a\"" :: Mytype
Mytype 3 "a"
```

`Ord`

* 表示成员是可排序的
* 首先看**类型声明中的次序**，或（|）在一起的，**最先出现的值构造器，造出来的值最小，然后再按照类似的规则比较值构造器的参数，所以同样要求参数都得是Ord成员**

```haskell
data Mytype = EmptyValue | Singleton | Mytype Int String deriving (Show, Eq, Read, Ord)
> EmptyValue < Singleton
True
> Singleton < Mytype 3 "a"
True
> Mytype 3 "a" < Mytype 4 "a"
True
```

`Enum, Bounded`用来**定义枚举类型**，即**有限集合**，

* Enum要求每个值都有前驱/后继，这样就可以用于**Range/Sequence**了，
* Bounded要求值具有上下界，例如：

```haskell
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Show, Bounded, Enum)
-- 上下界
> maxBound :: Day
Sunday
> minBound :: Day
Monday
-- 前驱/后继
> pred Wednesday
Tuesday
> succ Wednesday
Thursday
-- Range
> [Wednesday ..]
[Wednesday,Thursday,Friday,Saturday,Sunday]
```

# Record类型

![](/static/2022-03-17-00-29-59.png)

```haskell
data Person = Person {
  age :: Float,
  height :: Float,
  weight :: Float,
  xw :: Float,
  yw :: Float,
  tw :: Float
} deriving (Show)

person =  Person {age=1, height=2, xw=4, yw=5, tw=6, weight=3}

-- 会自动创建一堆getter
> :t age
age :: Person -> Float
> weight person
3.0

```

# 类型参数(泛型)

**类型构造器**可以**传入参数**，返回新的类型。例如：

* 其中，`a`是**类型参数**，
* <font color='red'>不是类型，而是类型构造器</font>，
  * **具体的 xxx才是类型**，
  * Nothing和Just xxx都是该类型的值，例如：
* 这样做能够得到一堆行为相似的类型，从应用场景上来看，**带参数的类型相当于泛型**，是在具体类型之上的一层抽象
  * ![](/static/2022-03-17-00-34-34.png)

```
data  a = Nothing | Just a

Just 'a' ::  Char
Nothing ::  a
```

# 与Either

```haskell
data  a = Nothing | Just a     -- Defined in ‘GHC.Base’
data Either a b = Left a | Right b  -- Defined in ‘Data.Either’
```

---

应用场景上，用来表示可能出错的结果，成功就是Just a，失败就是Nothing。适用于单一错误原因的场景，比如elemIndex：

* 找到了返回Just Int类型的下标，找不到就返回Nothing，没有第三种结果

```
Data.List.elemIndex :: Eq a => a -> [a] ->  Int
```

---

单看**异常处理**的场景，Either更强大一些，**一般把失败原因放到Left a，成功结果放到Right b**，

* 形式上与非常像，**但Left a可以携带任意信息**，相比之下，Nothing就太含糊了
* ![](/static/2022-03-17-00-38-14.png)

# 类型别名 type synonym

　作用和C中的typedef差不多，形式如：

　　type Message = (String, Int)

　　首字母大写。

---

通过type关键字给类型定义别名，让String等价于[Char]，从而给类型声明带来语义上的好处

* 让**类型声明更加易读**
* **替换掉那些重复率高的长名字类型**(如[(String, String)])

```haskell
> :i String
type String = [Char]    -- Defined in ‘GHC.Base’

type PhoneNumber = String
type Name = String
type PhoneBook = [(Name,PhoneNumber)]

inPhoneBook :: Name -> PhoneNumber -> PhoneBook -> Bool
inPhoneBook name pnumber pbook = (name, pnumber) `elem` pbook

-- 输入姓名、电话和电话簿，返回电话簿里有没有这条记录。如果不起别名的话，类型声明就只能是这样：
-- inPhoneBook :: String -> String -> [(String, String)] -> Bool

```

---

**类型别名也可以有参数**，比如，自定义的关联列表：

* 保证其通用性

![](/static/2022-03-17-00-43-21.png)

# ==============

# class关键字：定义typeclass（接口）

Class在函数式上下文指的就是**接口**

* 派生自某类（deriving (SomeTypeclass)）是说具有某类定义的行为，相当于OOP中的实现了某个接口，所以具有接口定义的行为

```haskell
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  x == y = not (x /= y)
  x /= y = not (x == y)
```

其中，a是个类型变量，在定义instance时给出具体类型。前两条类型声明是接口所定义的行为（通过定义函数类型来描述）。后两条函数实现是可选的，通过间接递归定义来描述这两个函数的关系，这样只需要提供一个函数的实现就够了（这种方式称为minimal complete definition，最小完整定义）

# 定义类型类&实例：例子

```haskell
data Bright
  = Blue
  | Red
  deriving (Read, Show)

darkBright :: Bright -> Bool
darkBright Blue = True
darkBright Red  = False

lightenBright :: Bright -> Bright
lightenBright Blue = Red
lightenBright Red = Red

data Pastel
  = Turquoise
  | Tan
  deriving (Read, Show)

darkPastel :: Pastel -> Bool
darkPastel Turquoise = True
darkPastel Tan       = False

lightenPastel :: Pastel -> Pastel
lightenPastel Turquoise = Tan
lightenPastel Tan       = Tan
```

定义类型类 & 类型类实例(声明某类型是类型类成员)

```haskell
-- 定义类型类Color
-- 类型变量a代表特定类型的Color
-- 任何类型Color可以使用dark, lighten

class Color a where
  dark :: a -> Bool
  lighten :: a -> a

-- 声明类型类成员
-- 声明实例时，需要定义类函数
-- 声明Bright实例，dark功能实际是darkBright
instance Color Bright where
    dark = darkBright
    lighten = lightenBright

-- 同理
instance Color Pastel where
      dark = darkPastel
      lighten = lightenPastel
```

# ==============

# 内置类型类

## Num

![](/static/2022-02-09-00-21-04.png)

## 其他数值类的层次结构 Hierarchy of numeric classes

![](/static/2022-02-09-00-22-14.png)
![](/static/2022-02-09-00-22-47.png)

## 其他

![](/static/2022-02-09-00-28-39.png)

# Show

![](/static/2022-02-08-16-48-58.png)
![](/static/2022-02-09-00-23-51.png)

## 自定义Show类型类实例

![](/static/2022-02-09-00-24-54.png)
![](/static/2022-02-09-00-25-03.png)

## Deriving Show

![](/static/2022-02-09-00-25-39.png)

自动定义一个类型Show的Foo2实例

# 例子 -（+）类型类

![](/static/2022-02-08-22-40-44.png)

# 类型推断：Type Inference

![](/static/2022-02-08-22-48-52.png)

类型推断规则

![](/static/2022-02-08-22-49-27.png)
![](/static/2022-02-08-22-50-12.png)

![](/static/2022-02-08-22-51-31.png)
![](/static/2022-02-08-22-52-11.png)
![](/static/2022-02-08-22-52-55.png)

# 参数化类型例子(类型构造器：泛型)-Type parameter

![](/static/2022-02-03-02-28-43.png)

![](/static/2022-02-03-02-28-54.png)
![](/static/2022-02-03-02-29-28.png)

![](/static/2022-02-10-22-31-23.png)



# ==============

# 作用域：let,where

## let-in表达式

```haskell
let x = 2
    y = 3
in x+y
```

在一个 let 中，一个变量可能依赖于另一个变量

```haskell
journeycost :: Float -> Float -> Float
journeycost miles fuelcostperlitre = 
 let milespergallon = 35
     litrespergallon = 4.55
     gallons = miles/milespergallon
 in (gallons*litrespergallon*fuelcostperlitre)

let diameter = 2*radius
    circumference = pi*diameter
in (diameter, circumference)
```

## where子句

方程式中的 where 关键字提供了**方程式**中使用的变量的定义。The where keyword, inside an equation, provides definitions for variables that are used in the equation.

![](/static/2022-02-03-02-58-36.png)

* 注意位置

```haskell
-- 注意where缩进
squareplusone :: Int -> Int
squareplusone x = xsquared + 1
 where xsquared = x*x

cel2fahr :: Float -> Float
cel2fahr x = (x*scalingfactor) + freezingpoint
 where scalingfactor = 9.0/5.0
       freezingpoint = 32
```

非要单行的话，可以用分号隔开多个声明

```haskell
sayHello = hello ++ " " ++ greeting
  where hello = "Hi"; greeting = "girls"
```

## let,where区别

![](/static/2022-02-03-01-55-00.png)

对于let和where混用，那么是**let的优先级高**，也就是说优先使用let定义的变量，而不是where定义的变量，比如

```haskell
-- 等于11而不是12
f x =
    let y = x+1
    in y
    where y = x+2
*Main> f 10
11
```

---

形式上：let xxx in...与...where xxx的声明位置区别，let把定义放在前面了

语法上：**let-in是表达式，而where是语法结构，前者可以随便放**

作用域上：let-in的作用域限制更严格，在let部分定义的变量/函数只对in部分可见

# 条件语句：If Expression

Haskell有if表达式，它根据if值，评估为then值或else值。

* Haskell的if表达式等同于类C语言中的?: 三元运算符。**第一个子表达式（在if之后）的类型必须是Bool，然后后面的两个子表达式（分别在then和else之后）的类型必须是相同的** The Haskell if expression is equivalent to the ?: ternary operator in C-like languages. The first subexpression (after the if) must have type Bool, then the subsequent two subexpressions (after then and else respectively) must have the same type as each other.
  * 无效
    * `if 1 then 0 else -1`
    * `if False then 42 else "foo"`
* if-then-else完整结构，**else部分不可省略**
* <font color="red">if语句本身也是表达式</font>
  * `gte10 x = not (if x < 10 then True else False)`

```haskell
if 2*2==4 then "happy" else "sad"
"happy"
:: [Char]

-- 有可能两个值是相似的，也就是说，根据它们的类型类别，它们可以被专门化为同一类型
-- It is possible to have two values that are similar, i.e. they could be specialized to the same type, based on their type classes.
if True then 42 else pi
42.0
```

# 模式匹配基础：pattern matching

模式匹配是基本的**函数调用机制**

* 调用函数时会按声明顺序匹配参数类型
* 模式匹配如果有遗漏且失败，报错

![](/static/2022-03-16-19-22-29.png)
![](/static/2022-03-16-19-24-06.png)

# guard

Haskell 提供了一种基于**谓词值定义函数**的符号。

* 参数列表后面多了| 条件表示不同的函数体分支，**被调用时满足条件就执行对应函数体并返回，否则就按顺序依次向下检查**
* `otherwise`
  * 如果前面没有guard评估为True，otherwise一定为True
  * otherwise只是语义需要，直接用True作为默认分支的条件也可以
* 单行形式也是合法的（但可读性差，不建议用）
  * `isPositive n | n > 0 = True | otherwise = Fal;se`

```
f x
  | predicate1 = expression1
  | predicate2 = expression2
  | predicate3 = expression3
```

---

例子1

`absolute x = if (x<0) then (-x) else x `

```haskell
absolute x
  | x<0 = -x
  | otherwise = x
```

Guards are easier to read than if/then/else if there are more than two conditional outcomes

---

如果有两个以上的条件结果，guard比 if/then/else 更容易理解

例子2

```haskell
holeScore :: Int -> Int -> String
holeScore strokes par
  | strokes < par = show (par-strokes) ++ " under par"
  | strokes == par = "level par"
  | strokes > par = show(strokes-par) ++ " over par"

  -- clean up ,用where重构

holeScore :: Int -> Int -> String
holeScore strokes par
  | score < 0 = show (abs score) ++ " under par"
  | score == 0 = "level par"
  | otherwise = show(score) ++ " over par"
where score = strokes-par
```

# case表达式：Case expression

最常见的case表达式就是函数定义时参数的模式匹配（case表达式的语法糖）：

* 用expression依次尝试匹配pattern，匹配成功就执行对应的代码块并返回结果，否则尝试下一个，都不匹配就报错
* 作为表达式，**case-of可以用于任何地方，比模式匹配灵活得多**（模式匹配只能用于函数声明、where、let、List Comprehension等特定场景）

```haskell
tail' [] = "empty list"
tail' [x] = "no tail"
tail' (_:xs) = show xs

-- 等价于case

tail'' xs = case xs of  [] -> "empty list"
                        [x] -> "no tial"
                        (_:xs) -> show xs
```

---

模式匹配

![](/static/2022-02-03-02-17-36.png)

```haskell
data Pet = Cat | Dog | Fish

-- 每个模式后面都有一个箭头和一个值
hello :: Pet -> String
hello x = 
  case x of
    Cat -> "meeow"
    Dog -> "woof"
    Fish -> "bubble"
```

---

```haskell
data Pet = Cat | Dog | Fish | Parrot String

hello :: Pet -> String
hello x = 
  case x of
    Cat -> "meeow"
    Dog -> "woof"
    Fish -> "bubble"
    Parrot name -> "pretty " ++ name

-- 注意Parrot这个值构造子
hello (Parrot "polly")
> "pretty polly"
```

## case全匹配（通配符）

guard有otherwise，case有 `_`

```haskell
data Pet = Cat | Dog | Fish | Parrot String

hello :: Pet -> String
hello x =
  case x of
    Parrot name -> "pretty " ++ name
    _ -> "grunt"
```

# 模式匹配&guard区别

![](/static/2022-02-03-02-02-04.png)

# Applicative

Suppose we have a function (like (+1)) wrapped up inside a context (like a ). How do we apply this function to values inside other  contexts? The answer is the Applicative typeclass, particularly the <*> “apply over” function. 假设我们有一个函数（如(+1)）被包裹在一个上下文（如）中。我们如何将这个函数应用于其他上下文中的值？答案是Applicative类型，特别是<*>"apply over "函数。

某函数在容器中

* `<*>`
* ![](/static/2022-05-10-19-17-38.png)

```haskell
(<*>) :: Applicative f => f (a->b) -> f a -> f b
```

应用型类型需要另一个函数，称为pure，它将一个值嵌入到一个上下文中。The Applicative typeclass requires another function, called pure, which embeds a value inside a context.

```
pure :: Applicative f => a -> f a
```

In fact, the fmap function of the Functor may be defined in terms of pure and <*> ---can you see how? 事实上，Functor的fmap函数可以用pure和<*>来定义

```
fmap f x =(pure f) <*> x
```

It’s possible to ‘lift’ two-operand functions into Applicative structures, e.g. using the utility liftA2 function. 有可能将双操作函数 "提升 "到Applicative结构中，例如使用实用的lifA2函数。

```
import Control.Applicative
liftA2 (+) (Just 1) (Just 2)
liftA2 (+) [1,2,3] [4,5,6]
```

![](/static/2022-05-10-19-52-15.png)

# ==============

# Monads: QUick Primer

You may have heard the term monad before, and we will discuss the concept in detail in a later session. Haskell uses monads to structure computations. You have already encountered the IO monad, which you need to use to perform IO in a Haskell program. A typical example is 您可能以前听说过单子这个术语，我们将在以后的会议中详细讨论这个概念。Haskell 使用单子来构造计算。您已经遇到了 IO monad，需要使用它在 Haskell 程序中执行 IO。一个典型的例子是

* 这说明了 monad 的关键语法特性: do 关键字、命令序列、使用左箭头 <-和 return 关键字从一元计算中提取信息的方法。事实上，do-notation 的使用与命令式编程非常相似。 This illustrates the key syntactic features of a monad: the do keyword, the sequence of commands, the way to extract information from a monadic computation using the left arrow <- and the return keyword. In fact, using the do-notation is quite similar to imperative programming.
  * return
  * `<-Z`
* 还要注意 hello 函数的返回值: 不只是 String，还有 IO String。在单子中完成的计算返回一个“单子”类型，我们说字符串在单子中返回。Also note the return value of our hello function: **not just String but IO String**. **A computation done in a monad returns a “monadic” type**, we say that the **string is returned inside the monad**.

```haskell
hello :: String -> IO String
hello x =
  do
     putStrLn ("Hello, " ++ x)
     putStrLn "What's your name?"
     name <- getLine
     return name
```

# 解析组合器：Parser combinators

![](/static/2022-02-03-03-33-58.png)

解析组合器是高阶函数，它结合了较小的组合器（解析器）来构建更复杂的组合器。 Parse combinators are high-order functions that combine smaller combinators (parsers) to build more complex ones.

* 所有 Bison、 Yacc 和 Antlr 都不是实际的解析器，而是解析器生成器。它们获取一个语法文件，并为这些语法所描述的语言生成解析器。
* Parsec 是您自己编写的解析器。

# parser combinator结构

解析组合器是高阶函数，它结合了较小的组合器（解析器）来构建更复杂的组合器。 Parse combinators are high-order functions that combine smaller combinators (parsers) to build more complex ones.

* 所有 Bison、 Yacc 和 Antlr 都不是实际的解析器，而是解析器生成器。它们获取一个语法文件，并为这些语法所描述的语言生成解析器。
* Parsec 是您自己编写的解析器。

![](/static/2022-02-03-03-56-39.png)

---

alternative parsers

![](/static/2022-02-03-03-58-04.png)

![](/static/2022-02-03-03-59-02.png)

# 基本组合器

提供了许多基本的解析器。每个参数都接受由 makeTokenParser 使用语言定义生成的 lexer 参数。这里我们使用 Language 模块中的 emptyDef。

```haskell
lexer       = P.makeTokenParser emptyDef

parens          = P.parens lexer    
brackets        = P.brackets lexer    
braces          = P.braces lexer    
commaSep        = P.commaSep lexer
whiteSpace      = P.whiteSpace lexer    
symbol          = P.symbol lexer    
identifier      = P.identifier lexer
integer         = P.integer lexer    
stringLiteral   = P.stringLiteral lexer 
```

![](/static/2022-02-04-00-51-11.png)

## char

![](/static/2022-02-04-00-52-22.png)
![](/static/2022-02-04-00-53-57.png)

## anyChar

![](/static/2022-02-04-00-54-57.png)

## many

![](/static/2022-02-04-00-56-23.png)

## noneOf

![](/static/2022-02-04-00-58-08.png)

## <|>, parenns

要求其他parser作为参数之一

```haskell
parens = \p ->
    \str ->
        -- first match "("
        -- perform the parse of p if "(" was found
        -- then match ")"
        -- return the result
```

---

![](/static/2022-02-04-15-41-09.png)

# try

![](/static/2022-02-04-14-00-16.png)

可以让解析器在匹配失败时不消耗输入:

![](/static/2022-02-04-14-00-30.png)

# 一元解析组合器：Parsec: monadic parsing combinators

Parsec monadic库

![](/static/2022-02-03-03-34-27.png)

导入Parsec

* ` import Text.ParserCombinators.Parsec`

Parsec 提供了方便的 parseTest 函数，该函数接受一个解析器和一个字符串并运行它。让我们尝试在字符串“ cons”上运行解析器 char‘ b’:

* `parseTest (char 'b') "cons"`

---

![](/static/2022-02-03-04-06-03.png)

# varname解析例子:Variable names

![](/static/2022-02-03-04-07-15.png)

# 表达式解析器：Expression Parsers

![](/static/2022-02-03-04-08-01.png)
![](/static/2022-02-03-04-09-39.png)
![](/static/2022-02-03-04-09-55.png)
![](/static/2022-02-03-04-11-11.png)
![](/static/2022-02-03-04-11-22.png)

# makeTokenParser

通过 makeTokenParser 定义语法和关键字的机制

* `makeTokenParser :: Stream s m Char => GenLanguageDef s u m -> GenTokenParser s u m`
* 表达式 makeTokenParser 语言创建一个 GenTokenParser 记录，其中包含使用语言记录中的定义定义的词法解析器。 The expression makeTokenParser language creates a GenTokenParser record that contains lexical parsers that are defined using the definitions in the language record.
* 导入合适的语言定义，并从结果 GenTokenParser 中选择所需的词法解析器。

对于简单的情况，可以使用 emptyDef。

```haskell
import Text.ParserCombinators.Parsec.Expr
import qualified Text.ParserCombinators.Parsec.Token as P
lexer       = P.makeTokenParser emptyDef

parens          = P.parens lexer
commaSep        = P.commaSep lexer
-- and many more
```

# Form of a parser

例如，假设我们要解析表单的字符串(< Tag >) ，其中(Tag)必须是一个单词，并将标记作为类型(Tag)返回。For example, suppose we want to parse a string of the form (< tag>), where (tag) must be a word, and return the tag as a type (Tag).

```haskell
data Tag = MkTag String

parseTag :: Parser Tag
parseTag =
  do  char '<'
      x <- identifier
      char '>'
      return (MkTag x)
```

正如您所看到的，解析器由许多按顺序调用的**函数**(例如 **char** 和 **identifier**)组成。此外，**返回值的类型是 Parser Tag**，而不是简单的 Tag。这是**因为 parse Tag 不返回值，而是返回一个解析器**。我们可以将这个解析器与其他解析器结合起来，然后可以对数据执行最终的解析器。我们将在本教程中更详细地介绍这种方法。As you can see, the parser consists of a number of functions (e.g. char and identifier) that are called sequentially. Also, the return value is of type Parser Tag, not simply Tag. This is because parseTag is not returning a value, instead it returns a parser. We can combine this parser with other parsers, and then we can execute the final parser on our data. We will cover this approach in more detail in the tutorial.

# parser结构

![](/static/2022-02-03-03-54-48.png)

* 解析组合器都返回函数

![](/static/2022-02-03-03-55-39.png)

# 例子：Parsing alternative strings

![](/static/2022-02-03-04-01-31.png)
![](/static/2022-02-03-04-01-51.png)
![](/static/2022-02-03-04-02-59.png)
![](/static/2022-02-03-04-04-48.png)
![](/static/2022-02-03-04-05-02.png)

# 解析xml标签例子

## xml格式

header

```xml
<?xml version="1.0" encoding="utf-8"?>
```

```haskell
xml_header =  "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
```

---

`<Tag>`

* `Tag`为任意文本内容，
* Token作为 `Tag`类型返回
* `<tag> ... </tag>`

```haskell
data Tag = MkTag String

-- 返回Parser Tag为了和其他解析器结合使用
parseTag :: Parser Tag
parseTag =
  do  char '<'
      x <- identifier
      char '>'
      return (MkTag x)

-- 拼接新tag
otag t = "<"++t++">"
ctag t = "</"++t++">"
tag t v = concat [otag t,v,ctag t]
```

---

带属性tag

* `<tag attr1="..." attr2="...">`

```haskell
-- 拼接带属性tag，tag, attr, value
 tagAttrs :: String -> [(String,String)] -> String -> String 
    tagAttrs t attrs v = 
        --  concat :: [[a]] -> [a] -- join lists
        -- concat 接受数组列表，拼接成一个列表
        -- concat [[1,2,3], [1,2,3]]
        -- [1,2,3,1,2,3]
        concat [
          -- 开标签进行拼接
          -- unwords:: [String] -> String
          -- 将String数组转为string，中间插入空格
          -- unwords ["aa","bb","cc","dd","ee"]
          -- > "aa bb cc dd ee"

          -- 完成会拼接成[tag(str)]++[[属性="属性值"]]的列表
          -- 然后unwords展开为一个str，中间每个元素插入空格
          --  unwords $ ["str"] ++ (map (\(k,v)-> concat [k,"=\"",
-- v,"\""]) [("attr1","v1"), ("attr2", "v2")])
          -- "str attr1=\"v1\" attr2=\"v2\""
            otag (unwords $ [t]++(map (\(k,v) -> concat [k,"=\"",v,"\""]) attrs))
            ,v
            ,ctag t
            ]
```

---

## parseList（生成list标签）

list

* `[ ..., ..., ... ]` str输入

```xml
<list>
<list-elt>...</list-elt>
...
</list>
```

```haskell
list_parser = do
    -- 根据str消耗brackets，逗号，Parser String存入ls
    ls <- brackets $ commaSep showParser 
    -- 生成list标签，拼接换行符，拼接内部标签列表list-elt 
    return $ tag "list" $ joinNL $ map (tag "list-elt") ls
```

## parseTuples (生成tuple标签)

`: ( ..., ..., ... )`

```haskell
<tuple>
<tuple-elt>...</tuple-elt>
...
</tuple>
```

```haskell
tuple_parser = do
    -- 消耗括号，后序lexer消耗逗号和其他parser，生成的字符串存入ls
    ls <- parens $ commaSep showParser 
    -- 返回解析str后生成的tuple标签str，拼接
    return $ tag "tuple" $ unwords $ map (tag "tuple-elt") ls
```

## parseRecord (解析record类型string，生成record标签)

`Rec { k=v, ... } `

![](/static/2022-02-08-18-13-50.png)


```xml
<record>
<elt key="k">v</elt>
...
</record>

<!-- key-value pairs: k = v -- v can be anything -->
```

```haskell
record_parser = do
    -- 识别类型标识，大写字母开头 + 任意字母数字组合标识
    ti <- type_identifier
    -- 消耗{，消耗kv，消耗comma，返回解析后str
    ls <- braces $ commaSep kvparser
    -- 做带属性record标签
    return $ tagAttrs "record" [("name",ti)] (joinNL ls)

kvparser = do
-- 消耗id
    k <- identifier
    symbol "="
    -- value可以为任何内容，调showParser，选择alternative parsers
    t <- showParser
    return $ tagAttrs "elt" [("key",k)] t
    
type_identifier = do
    fst <- oneOf ['A' .. 'Z']
    rest <- many alphaNum
    whiteSpace
    return $ fst:rest    
```

## parseDiv（生成div数据类型）

div标签

```haskell
-- Tag类型打印
-- the "deriving Show" is needed to let `ghci` print the result
data Tag = MkTag String deriving Show 

-- 识别div标记，返回Parser Tag类型
parseDiv :: Parser Tag
parseDiv = do 
  string "<div>" 
  return (MkTag "div")

-- 括号，分号代替缩进写法
let parseDiv  = do { string "<div>";return $ MkTag "div" }
```

## parseShow

解析解析器内容，以xml格式返回

```haskell
parseShow :: String -> String
parseShow = \str -> xml_header++(run_parser showParser str)
```

## record type

```haskell
data PersonRecord  = MkPersonRecord {
    name :: String,
    address :: Address,
    id :: Integer,
    labels :: [Label]    
} deriving (Show)

data Address = MkAddress {
    line1 :: String,
    number :: Integer,
    street :: String,
    town :: String,
    postcode :: String
} deriving (Show)

data Label = Green | Red | Blue | Yellow deriving (Show)
```

```haskell
-- 创建PersonRecord实例
rec1 = MkPersonRecord 
    "Wim Vanderbauwhede" 
    (MkAddress "School of Computing Science" 17 "Lilybank Gdns" "Glasgow" "G12 8QQ")
    557188
    [Green, Red]

rec2 = MkPersonRecord 
    "Jeremy Singer" 
    (MkAddress "School of Computing Science" 17 "Lilybank Gdns" "Glasgow" "G12 8QQ")
    42
    [Blue, Yellow]
```

## module - ShowParser

暴露接口 parseShow

