# Week1

* [Week1](#week1)
* [How it works without assignment](#how-it-works-without-assignment)
* [Expressions](#expressions)
* [Equations](#equations)
* [Reduction](#reduction)
  * [Unique reduction path](#unique-reduction-path)
  * [Multiple Reduction](#multiple-reduction)
  * [The result doesn’t depend on reduction path!](#the-result-doesnt-depend-on-reduction-path)
* [==============](#)
* [Functions](#functions)
  * [Function definitions](#function-definitions)
  * [匿名函数：Anonymous Function](#匿名函数anonymous-function)
  * [高阶函数：Higher-order functions](#高阶函数higher-order-functions)
* [函数返回多个值](#函数返回多个值)
* [函数组合：Function Composition](#函数组合function-composition)
  * [map组合：composition of maps](#map组合composition-of-maps)
* [函数整体作为（方程）值返回](#函数整体作为方程值返回)
* [函数生成器/参数化函数：parameterised functions](#函数生成器参数化函数parameterised-functions)
* [Monomorphic functions](#monomorphic-functions)
* [参数化多态 & Ad-hoc多态： Parametric polymorphism，Ad hoc polymorphism.](#参数化多态--ad-hoc多态-parametric-polymorphismad-hoc-polymorphism)
* [多态函数：Polymorphic functions](#多态函数polymorphic-functions)
* [柯里化&部分函数应用: Currying, Partial Application](#柯里化部分函数应用-currying-partial-application)
* [分组&函数应用：Grouping - arrow to the right, application left](#分组函数应用grouping---arrow-to-the-right-application-left)
* [Lambda](#lambda)
  * [转换规则-归约(Reduction)：Conversion rules](#转换规则-归约reductionconversion-rules)
* [==============](#-1)
* [Lists](#lists)
* [列表操作](#列表操作)
  * [列表拼接：++](#列表拼接)
  * [索引：!](#索引)
  * [head tail](#head-tail)
  * [添加元素 - ：](#添加元素---)
  * [length](#length)
  * [elem](#elem)
  * [zip](#zip)
  * [zipWith](#zipwith)
* [列表递归/条件函数：Recursion on List, Conditioanl functions](#列表递归条件函数recursion-on-list-conditioanl-functions)
  * [length: 递归计算列表长](#length-递归计算列表长)
  * [filter：Recursive definition](#filterrecursive-definition)
  * [sum](#sum)
* [列表(循环)计算 - for/while Loops](#列表循环计算---forwhile-loops)
* [列表折叠：Folding a list (Reduction)](#列表折叠folding-a-list-reduction)
  * [FoldL](#foldl)
  * [foldr](#foldr)
  * [其他应用](#其他应用)
* [列表函数映射map,folds - 命令式循环关联：Functional Maps and Folds versus Imperative Loops](#列表函数映射mapfolds---命令式循环关联functional-maps-and-folds-versus-imperative-loops)
* [列表懒惰计算](#列表懒惰计算)
  * [lazy evaluation](#lazy-evaluation)
* [列表推导式：List comprehensions](#列表推导式list-comprehensions)
* [==============](#-2)
* [双参函数func->infix运算符](#双参函数func-infix运算符)
* [infix操作符->prefix 操作符/function](#infix操作符-prefix-操作符function)
* [序列：Sequences](#序列sequences)
* [Bool/Relational Operators](#boolrelational-operators)
  * [and, or](#and-or)
* [If Expression](#if-expression)
* [I/O](#io)
  * [putStrLn, getLine, do](#putstrln-getline-do)
  * [read](#read)
  * [show](#show)
* [IO Monads](#io-monads)
  * [Pure Function](#pure-function)
  * [IO Type](#io-type)
  * [Sequencing Actions](#sequencing-actions)
* [Monad](#monad)
* [Monad类型类&接口：Monad and Type classes](#monad类型类接口monad-and-type-classes)
* [Monad规则：monad laws](#monad规则monad-laws)
* [Do](#do)
* [==============](#-3)
* [类型别名 type synonym](#类型别名-type-synonym)
* [用户自定义类型：User Defined Types/algebraic data types](#用户自定义类型user-defined-typesalgebraic-data-types)
  * [Recursive Data types - Tree 例子](#recursive-data-types---tree-例子)
* [Type classes](#type-classes)
* [定义类型类&实例：例子](#定义类型类实例例子)
* [内置类型类](#内置类型类)
  * [Num](#num)
  * [其他数值类的层次结构 Hierarchy of numeric classes](#其他数值类的层次结构-hierarchy-of-numeric-classes)
  * [其他](#其他)
* [Show](#show-1)
  * [自定义Show类型类实例](#自定义show类型类实例)
  * [Deriving Show](#deriving-show)
* [例子 -（+）类型类](#例子--类型类)
* [类型推断：Type Inference](#类型推断type-inference)
* [参数化类型例子(类型构造器：泛型)-Type parameter](#参数化类型例子类型构造器泛型-type-parameter)
* [Infinite Data Structure](#infinite-data-structure)
* [==============](#-4)
* [作用域：let,where](#作用域letwhere)
  * [let](#let)
  * [where](#where)
  * [let,where区别](#letwhere区别)
* [guard](#guard)
* [case表达式（模式匹配）：Case expression](#case表达式模式匹配case-expression)
  * [case全匹配（通配符）](#case全匹配通配符)
* [模式匹配&guard区别](#模式匹配guard区别)
* [==============](#-5)
* [Maybe Monad](#maybe-monad)
* [Maybe: Optional容器](#maybe-optional容器)
* [fmap & maybe](#fmap--maybe)
* [提取Maybe值](#提取maybe值)
* [Maybe用于Do块](#maybe用于do块)
* [==============](#-6)
* [Monads: QUick Primer](#monads-quick-primer)
* [解析组合器：Parser combinators](#解析组合器parser-combinators)
* [parser combinator结构](#parser-combinator结构)
* [基本组合器](#基本组合器)
  * [char](#char)
  * [anyChar](#anychar)
  * [many](#many)
  * [noneOf](#noneof)
  * [<|>, parenns](#-parenns)
* [try](#try)
* [一元解析组合器：Parsec: monadic parsing combinators](#一元解析组合器parsec-monadic-parsing-combinators)
* [varname解析例子:Variable names](#varname解析例子variable-names)
* [表达式解析器：Expression Parsers](#表达式解析器expression-parsers)
* [makeTokenParser](#maketokenparser)
* [Form of a parser](#form-of-a-parser)
* [parser结构](#parser结构)
* [例子：Parsing alternative strings](#例子parsing-alternative-strings)
* [解析xml标签例子](#解析xml标签例子)
  * [xml格式](#xml格式)
  * [parseList（生成list标签）](#parselist生成list标签)
  * [parseTuples (生成tuple标签)](#parsetuples-生成tuple标签)
  * [parseRecord (解析record类型string，生成record标签)](#parserecord-解析record类型string生成record标签)
  * [parseDiv（生成div数据类型）](#parsediv生成div数据类型)
  * [parseShow](#parseshow)
  * [record type](#record-type)
  * [module - ShowParser](#module---showparser)

# How it works without assignment

never destroy old values, compute new values

* if old value was useless, would be collected by garbage collector

# Expressions

haskell only has expressions， no statements

Pure functional programming languages don’t have any statements — no assignments, no jumps.
纯函数式编程语言没有任何语句ーー没有赋值，没有跳转。

Instead, all computation is performed by evaluating expressions
相反，所有的计算都是通过计算表达式来执行的

---

* **表达式可以包含函数调用**
* id & 形参空格隔开
  * 如果参数是表达式，表达式包括在括号里

```haskell
abs 5 -- > 5
abs (-6) -- > 6
```

# Equations

不是赋值语句，给一个值取名称

* 一个name只能对应一个value
  * “变量”，值不可变

```haskell
n = 1    -- just fine!
x = 3*n  -- fine
n = x    -- Wrong: can have only one definition of n

n = n+1 --可以通过编译，但fail
```

# Reduction

对于命令式程序，我们可以逐条执行语句，跟踪变量(堆栈)的值以及我们在程序中的位置(程序计数器)。

* 归约是将表达式转换为更简单形式的过程。从概念上讲，通过一次简化一个可约表达式(称为“ redex”)来简化表达式。每一步都称为归约，我们将使用 -- > 来显示结果。
* 归约是重要的，因为它是执行函数式程序的唯一手段。没有命令式语言中的语句; 所有的计算都是通过减少表达式来实现的。

## Unique reduction path

![](/static/2022-01-20-03-12-31.png)

## Multiple Reduction

![](/static/2022-01-20-03-13-21.png)

## The result doesn’t depend on reduction path!

A fundamental theorem (the **Church-Rosser theorem**):

一个基本定理(丘奇-罗瑟定理) :

Every terminating reduction path gives the same result

每个终止归约路径给出相同的结果

![](/static/2022-01-20-03-15-01.png)

# ==============

# Functions

* no need to include parenthesis
* concatenation operator `++`

```python
 def hello(name):
        return "Hello, "+name
```

```haskell
hello name = "Hello, " ++name
```

## Function definitions

![](/static/2022-01-20-03-32-38.png)
![](/static/2022-01-20-03-33-28.png)

## 匿名函数：Anonymous Function

![](/static/2022-01-20-01-31-48.png)

```haskell
f = \x y -> x*y+x+y
f 2 3

(\x -> x+1 ) 4
```

## 高阶函数：Higher-order functions

![](/static/2022-01-20-01-36-42.png)

# 函数返回多个值

![](/static/2022-01-20-03-46-29.png)

```haskell
λ sumprod = \x y -> [x+y,x*y]
[x + y,x * y]
:: [Expr]
λ sumprod 3 8
[11,24]
:: Num t => [t]
```

# 函数组合：Function Composition

链式函数

* `g::a->b`
* `f::b->c`
* `f·g`
  * 计算**右到左**

```haskell
(.) :: (b->c) -> (a->b) -> a -> c
(f . g) x = f (g x)

map f (map g xs) = map (f . g) xs

map (+5) (map (*3) [1..10])
map ((+5).(*3)) [1..10]

[8,11,14,17,20,23,26,29,32,35]
:: (Enum b, Num b) => [b]

```

## map组合：composition of maps

```haskell
map f (map g xs) = map (f . g) xs
```

# 函数整体作为（方程）值返回

![](/static/2022-02-03-03-01-26.png)
![](/static/2022-02-03-03-25-48.png)

# 函数生成器/参数化函数：parameterised functions

```haskell
-- 相当于 \n x -> x+n
gen_add_n = \n ->
    \x -> x+n

-- 提供第一个参数N
add_3 = gen_add_n 3
add_7 = gen_add_n 7

-- 后序提供第二个参数 x 
add_3 5 --> 8
add_7 4 --> 11
```

这当然不仅限于数值型常量，例如，下面的函数生成对常数及其参数执行给定算术运算的函数:For example, the following function generates functions that perform a given arithmetic operation on a constant number and their argument:

```haskell
gen_op_n = \op n ->
    \x -> x `op` n

-- 提供 op n
add_3 = gen_op_n (+) 3
mult_7 = gen_op_n (*) 7

-- 提供 x (x `op` n)
add_3 5 --> 8
mult_7 4 --> 28
```

# Monomorphic functions

单形的意思是“具有一种形式”。 Monomorphic means “having one form”.

```haskell
f :: Int -> Char
f i = "abcdefghijklmnopqrstuvwxyz" !! i

x :: Int
x = 3

f :: Char->String
f x = x:" There is a kind of character in thy life"
```

# 参数化多态 & Ad-hoc多态： Parametric polymorphism，Ad hoc polymorphism.

Parametric polymorphism

![](/static/2022-02-08-22-43-09.png)

Ad hoc polymorphism

多态类型，可以被**实例化**为**从一个集合中选择的任何类型**，称为 "类型类" A polymorphic type that can be instantiated to any type chosen from a set, called a “type class”

* 通常用`=>`**约束**类型变量 Represented by a type variable that is constrained using the `=>` notation.
  * 限制了多态性
* ![](/static/2022-02-08-22-45-06.png)
  * 感觉类似 `<Class extends Num>`

# 多态函数：Polymorphic functions

多态意味着“有多种形式”。Polymorphic means “having many forms”.

```haskell
fst :: (a,b) -> a
fst (x,y) = x

snd :: (a,b) -> b
snd (x,y) = y

fst :: (a,b) -> a
fst (a,b) = a

snd :: (a,b) -> b
snd (a,b) = b
```

# 柯里化&部分函数应用: Currying, Partial Application

柯里化(Currying)是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数, 并且返回接受余下的参数且返回结果的新函数的技术

![](/static/2022-02-08-22-13-02.png)

---

函数签名右结合（`->`右结合）

![](/static/2022-02-08-23-00-01.png)

部分函数应用：Partial Application

![](/static/2022-02-08-23-00-25.png)
![](/static/2022-02-08-23-01-48.png)

* 用一个参数将一个具有多个参数的函数重写成一系列函数的技巧称为局部套用
* 部分应用程序意味着我们不需要为一个函数提供所有参数


# 分组&函数应用：Grouping - arrow to the right, application left

The arrow operator takes two types `a->b`, and gives the type of a function with argument type `a` and result type `b` 箭头运算符接受两种类型 `a->b`，并给出参数类型为 `a` 和结果类型为 `b` 的函数的类型

An application `e1 e2` applies a function `e1` to an argument `e2` 函数应用 `e1 e2`, 将e1应用于参数e2

Note that for both types and applications, a function has only one argument 请注意，对于类型和函数应用，函数只有一个参数

* To make the notation work smoothly, arrows group to the right, and application groups to the left. 为了使符号工作顺利，箭头组向右，函数应用组向左。
* ![](/static/2022-02-08-22-55-43.png)
* lambda同理![](/static/2022-02-08-22-56-35.png)
  * ![](/static/2022-02-08-22-58-23.png)

```haskell
-- 下面等价的，函数签名右结合，每一步take一个参数返回一个函数，，（除了参数c）
f :: a -> b -> c -> d
f :: a -> (b -> (c -> d))

-- 左结合...每结合一个返回下一个的函数
-- 结合第一个参数x返回函数 (b->(c->d))
f x y z = ((f x) y) z
```

# Lambda

![](/static/2022-02-09-00-53-16.png)
![](/static/2022-02-09-00-54-07.png)

变量约束：free, bound

![](/static/2022-02-09-00-37-26.png)
![](/static/2022-02-09-00-37-51.png)

## 转换规则-归约(Reduction)：Conversion rules

![](/static/2022-02-09-00-38-45.png)

Alpha conversion

![](/static/2022-02-09-00-35-00.png)

Beta conversion
![](/static/2022-02-09-00-40-07.png)

---

Eta conversion
![](/static/2022-02-09-00-40-47.png)
![](/static/2022-02-09-00-41-39.png)

Removing a common trailing argument 剔除共同尾参数

![](/static/2022-02-09-00-49-16.png)
![](/static/2022-02-09-00-46-12.png)

# ==============

# Lists

列表实质由 `:` 和空列表创建而来

* `foldr (:) [] xs`

列表不可变

```haskell
lst = [ "A", "list", "of", "strings"]
lst = [1,2] ++ [3,4]
-- 或者用concat,, concat [[1,2],[3,4]]
```

infinity lists

![](/static/2022-01-25-15-45-32.png)

---

# 列表操作

## 列表拼接：++

![](/static/2022-01-20-03-48-50.png)

## 索引：!

![](/static/2022-01-20-03-58-33.png)

## head tail

标准库

![](/static/2022-01-20-04-09-21.png)

## 添加元素 - ：

`:` 底层是 `foldr (:) [] xs`

```haskell
λ 23 : [48, 41, 44]
[23,48,41,44]

λ 42 : []
[42]
:: Num a => [a]
```

## length

```haskell
λ length [23, 29] + length [48, 41, 44] == length ([23, 29] ++ [48, 41, 44])
True
:: Bool
```

```haskell
length ["A","list","of","strings"]
4
```

## elem

判断值是不是列表元素，返回bool

* `elem 1 [1,2,3]` 函数用法
* `3 `elem` [1, 2, 3, 4, 5]` 运算符用法
  * The elem function can be written infix, like an arithmetic operator, by enclosing its name in backquotes ``.

## zip

![](/static/2022-01-20-04-54-21.png)
![](/static/2022-01-20-05-00-04.png)

* 输出长度基于最短输入列表

```haskell

zip [1,2,3] [4,5,6]
[(1,4), (2,5), (3,6)]

-- string is list of char
zip [1,2,3] "abc"
[(1,'a'), (2,'b'), (3,'c')]

zip3 "glasgow" "beijing" "nairobi"
[('g','b','n'), ...]
```

## zipWith

provide function how to combine the elements from the input lists

```haskell
zipWith max [1,2,3] [0,2,4]
[1,2,4]

-- infix op -> prefix func
zipWith (+) [1,2,3] [0,2,4]
[1,4,7]

-- how zip is implemented
zipWith (\x->(\y->(x,y))) [1,2,3] "abc"
[(1,'a'), (2,'b'), (3,'c')]

zipWith (\x y->(x,y)) [1,2,3] "abc"

```

# 列表递归/条件函数：Recursion on List, Conditioanl functions

即conditional functions

![](/static/2022-01-24-23-11-14.png)

* list built from the empty list `[]` and function `cons`
  * base case - `[]`
  * induction case - `(x:xs)`
    * `x` - head
    * `xs` - tail

`():[]` -> `[()]`

`[1,2,3]` -> `1,2,3:[]`

---

length

![](/static/2022-01-25-21-42-41.png)

```haskell
length :: [a] -> Int           -- function type
length [] = 0                  -- base case
length (x:xs) = 1 + length xs  -- recursion case

-- or (in haskell, not web)
length :: [a] -> Int
length [] = 0
length lst = let x:xs = lst in 1 + length xs

-- guard
length :: [a] -> Int
length lst
  | lst == [] = 0
  | otherwise let x:xs in 1 + length xs

  -- one line guard
len lst | lst == [] = 0 | otherwise = 1 + len xs where x:xs
=lst

len lst | lst == [] = 0 | otherwise = let x:xs=lst in 1 + l
en xs

-- not allowed
ghci> len2 (x:xs) | (x:xs) == [] = 0 | otherwise = 1 + len2 xs
ghci> len2 [1..3]
*** Exception: <interactive>:4:1-56: Non-exhaustive patterns in function len2
```

## length: 递归计算列表长

```haskell
length :: [a] -> Int           -- function type
length [] = 0                  -- base case
length (x:xs) = 1 + length xs  -- recursion case

-- []:xs = []?

-- or (in haskell, not web)
length :: [a] -> Int
length [] = 0
length lst = let x:xs = lst in 1 + length xs
```

## filter：Recursive definition

The function filter is given a predicate (a function that gives a Boolean result) and a list, and returns a list of the elements that satisfy the predicate.

Filtering is useful for the “generate and test” programming paradigm.

```haskell
filter::(z->bool)->[a]->[a]
filter f [] = []
filter f (x:xs) = if f x then x:filter f xs 
                  otherwise filter f xs

-- one line guard (注意不分割arg，递归定义的base case包括在里面了)
fil2 pred lst | null lst = [] | otherwise = let x:xs = lst
in if pred x then x:fil2 pred xs else fil2 pred xs

-- base case正常写法
fil pred lst | lst == [] = [] | otherwise = let x:xs=lst in if pred x then x:fil pred xs else fil pred xs

-- one line guard (using where)
fil3 pred lst | null lst = [] | otherwise = if pred x then x:fil3 pred xs else fil3 pred xs where x:xs = lst

filter (<5) [3,9,2,12,6,4]
[3,2,4]
:: (Num a, Ord a) => [a]
```

![](/static/2022-01-24-23-18-57.png)
![](/static/2022-01-24-23-45-14.png)

## sum

sum, fold

# 列表(循环)计算 - for/while Loops

![](/static/2022-01-25-15-34-12.png)

* `map`
  * 列表每个元素计算
  * `map f [x0,x1,x2] -- > [f x0, f x1, f x2]`
* `foldl`
  * left to right
* `foldr`
  * right to left

# 列表折叠：Folding a list (Reduction)

归约后产生标量scalar

accumulator - 初始值

## FoldL

![](/static/2022-01-25-20-06-57.png)

* `foldl f z xs`

```haskell
-- 递归定义，recursive definition of foldl
foldl        :: (b -> a -> b) -> b -> [a] -> b
foldl f z0 xs0 = lgo z0 xs0
             where
                lgo z []     =  z
                lgo z (x:xs) = lgo (f z x) xs

foldl (\acc elt -> elt:acc) "" "Reversing a string"
```
![](/static/2022-01-25-22-56-41.png)

`foldl (\acc elt -> acc++[elt]) "" "A string"`

* 注意 `[]`，因为`++`只能拼接字符串



---

![](/static/2022-01-25-20-09-28.png)

中缀符号例子 Examples of foldl with infix notation

![](/static/2022-01-25-20-23-30.png)

## foldr

![](/static/2022-01-25-20-39-06.png)
![](/static/2022-01-25-20-42-44.png)

```haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr k z = go
          where
            go []     = z
            go (y:ys) = y `k` go ys
```

foldr & cons（`:`）

![](/static/2022-01-25-20-48-47.png)

## 其他应用

![](/static/2022-01-25-20-56-49.png)

```haskell
sum xs = foldr (+) 0 xs
product xs = foldr (*) 1 xs

-- “point free” style
sum      = foldr (+) 0
product  = foldr (*) 1
```

# 列表函数映射map,folds - 命令式循环关联：Functional Maps and Folds versus Imperative Loops

https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103586

```haskell
map :: (a -> b) -> [a] -> [b]
foldl :: (b -> a -> b) -> b -> [a] -> b 
foldr :: (a -> b -> b) -> b -> [a] -> b
```

# 列表懒惰计算

![](/static/2022-01-20-04-11-30.png)
![](/static/2022-01-20-04-20-25.png)

## lazy evaluation

![](/static/2022-01-20-03-47-23.png)

# 列表推导式：List comprehensions

![](/static/2022-01-20-03-55-44.png)

* 列表操作推导为表达式
* 左边|我们有一个表达式，对右边的列表的每个元素都进行了计算。表达式中的参数是用左箭头<-指定的。

```haskell
[3*x | x <- [1..10]]
-- >
[3,6,9,12,15,18,21,24,27,30]

[2*x | x <- [0..10]]
-- >
[0,2,4,6,8,10,12,14,16,18,20]

[2*x + 1 | x <- [0..10]]
-- >  
[1,3,5,7,9,11,13,15,17,19,21]

[[a,b] | a <- [10,11,12] , b <- [20,21]]
-- >
[[10,20],[10,21],[11,20],[11,21],[12,20],[12,21]]

[2*x+1 | x <- [0,2..10]]
-- >
[1,5,9,13,17,21]
```

# ==============

# 双参函数func->infix运算符

In fact, **Haskell permits any two-argument function to be written as an infix operator**  using **backquote** characters. For a further example, try the max function as an infix operator: 42 `max` 13

```haskell
42 `max` 13
42
:: (Num a, Ord a) => a
```

# infix操作符->prefix 操作符/function

Also note that any Haskell infix operator, e.g. +, can be written as a **prefix operator/function by enclosing it in parentheses**, like (+) 1 1

```haskell
(+) 1 1
2
:: Num a => a
```



# 序列：Sequences

![](/static/2022-01-20-03-51-35.png)

* 序列生成列表
  * 序列写入方括号，[start..end]
* 序列值
  * 枚举
    * char
    * int

```haskell
λ [0x0A .. 0x1F]
[10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]
```

# Bool/Relational Operators

* 不能比较两个具有不同类型的值
* `==`
* `/=`
* `<, <=, >, >=`
  * `[1,2,3] < [1,2,3,4]` Note that relational operators also work on lists, in a dictionary-order manner (lexicographic).
  * Since **strings are lists of characters** in Haskell, we can do the same kinds of comparison operations on strings. Check whether Aardvark comes before Aaronic in the dictionary with this code: `"Aardvark" < "Aaronic"`
* `not`
  * `not True`
  * `not (not False)`
* `&&` infix
  * `True && True`
* `||` infix
* `xor` function

```haskell
-- Notice that we specify xor as an infix function with the backquotes here
True `xor` False
```

枚举双输入布尔函数的全部真值表是很直接的。我们可以用一个列表理解表达式来列举输入值。[(x,y) | x<-[False, True], y<-[False, True]] 。然后我们可以在这些输入值上映射布尔函数（从对中提取）。例如，这里是xor函数的列举的输出值：map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]]It's straightforward to enumerate the full truth table for two-input boolean functions. We could use a list comprehension expression to enumerate the input values: [(x,y) | x<-[False, True], y<-[False, True]]. Then we could map the boolean function over these input values (extracted from the pairs). For instance, here are the enumerated output values for the xor function: map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]].

```haskell
[(x,y) | x<-[False, True], y<-[False, True]]
[(False,False),(False,True),(True,False),(True,True)]

map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]]
[False,True,True,False]
:: [Bool]
```

## and, or

有时，像AND和OR这样的布尔逻辑函数有两个以上的输入。Haskell支持这些多输入的布尔运算，有and和or函数，这些函数将布尔值列表作为单一输入。实际上，这是对输入布尔值列表的&&或||运算符的折叠。Sometimes, boolean logic functions like AND and OR have more than two inputs. Haskell supports these multi-input boolean operations with and and or functions that take a list of boolean values as a single input. Effectively, this is a fold of the && or || operator over the input list of boolean values.

```haskell
and [False, True, False, True]
False

or [True, True, False]
True
```

# If Expression

Haskell有if表达式，它根据if值，评估为then值或else值。

* Haskell的if表达式等同于类C语言中的?: 三元运算符。第一个子表达式（在if之后）的类型必须是Bool，然后后面的两个子表达式（分别在then和else之后）的类型必须是相同的 The Haskell if expression is equivalent to the ?: ternary operator in C-like languages. The first subexpression (after the if) must have type Bool, then the subsequent two subexpressions (after then and else respectively) must have the same type as each other.
  * 无效
    * `if 1 then 0 else -1`
    * `if False then 42 else "foo"`

```haskell
if 2*2==4 then "happy" else "sad"
"happy"
:: [Char]

-- 有可能两个值是相似的，也就是说，根据它们的类型类别，它们可以被专门化为同一类型
-- It is possible to have two values that are similar, i.e. they could be specialized to the same type, based on their type classes.
if True then 42 else pi
42.0
```

# I/O

## putStrLn, getLine, do

向终端打印字符串的Haskell函数叫做`putStrLn`（像Java中的println或Python中的print）。

* `putStrLn ("good " ++ "morning" ++ " everyone")`

读入 & do structure

* `do`
  * 排列IO操作
  * <-用于在do块中把名字和值联系起来，而->则用于定义函数。<- is for associating names with values in do blocks whereas -> is used for defining functions.

```haskell
λ getLine
> read
"read"
:: IO String

-- 正如我们所看到的，你可以用do结构来排列IO操作。用左边的箭头将值绑定到变量上。我们可以把它理解为x从getLine中获得一个值。请注意，你不能对getLine使用标准的赋值（等价操作），因为它是一个IO操作 As we have seen, you can sequence IO operations with the do construct. Values are bound to variables using the left arrow. We could read this as x gets a value from getLine. Be aware that you can't use the standard assignment (with the equals operator) for getLine, since it is an IO operation.
do { putStrLn "what is your name?"; x <- getLine; putStrLn ("hello " ++ x) }

-- 一旦我们从getLine得到一个值，并把它绑定到一个变量上，那么我们就可以对这个值进行标准的函数调用，并把它绑定到另一个变量上 Once we have got a value from getLine, and bound it to a variable, then we can do standard function calls on this value, and bind it to another variable
do { putStrLn "what is your name?"; n<-getLine; let nUpper = map toUpper n in putStrLn ("HELLO " ++ nUpper) } 
```

$ 中缀操作

* `($) :: (a -> b) -> a -> b`
* 给一个 a->b函数，和参数a，输出b
  * `putStrLn $ "hello"++name`

## read

可以将数值读成字符串，并将其转换为其他类型。这就像C语言中的atoi函数一样。试试读 "42":: Int。你需要::Int类型注释，否则就不清楚输入的String是代表什么类型的数字 It is possible to read values as strings, and convert them into other types. This is like the atoi function in C. Try read "42" :: Int. You need the ::Int type annotation otherwise it is not clear what type of number the input String is meant to represent.

```haskell
read "42" :: Int
42
:: Int

read "42"::Float
42.0
:: Float
```

## show

![](/static/2022-01-26-14-08-20.png)

* **自动提供引号**。。
  * ![](/static/2022-02-08-17-20-40.png)
* 然后`print "hello world"`输入是show类型，输出成IO()类型，结果其实打印的是 `\"hello world\"`

show函数是read函数的对偶。 show接收一个值并返回该值的一个字符串表示 The show function is the dual of the read function. show takes a value and returns a String representation of that value. 

* 请注意，返回的值具有String类型。只有一些类型（派生出Show的类型）可以转换为字符串 Notice that the returned value has the String type. Only some types (those that derive Show) can be converted to Strings
* show函数(之后的结果)，允许打印出任意的值
  * `putStrLn (show (6*7))`
    * 等价于 `print (6*7)`

```haskell
show 42
"42"
:: String
```

# IO Monads

## Pure Function

https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103578

到目前为止，我们集中讨论了纯函数。这些类型的函数将值作为参数，对这些值进行一些处理，然后返回结果值。一个纯函数不依赖于“世界的状态”。计算是完全自包含和独立的。给定相同的参数，纯函数总是返回相同的结果。So far, we have concentrated on pure functions. These kinds of functions take values as arguments, do some processing of those values, then return a result value. A pure function does not depend on the ‘state of the world’. The computation is entirely self-contained and independent. Given the same arguments, a pure function will always return the same result.

## IO Type

![](/static/2022-01-20-05-42-54.png)

## Sequencing Actions

```haskell
let greet() = do 
    planet <- getLine
    home <- getLine
    putStrLn ("greetings " ++ planet ++ "ling.")
    putStrLn ("I am from " ++ home ++ ".")
    putStrLn "Take me to your leader."

-- 在 do 中，我们使用 <-将 IO 函数的结果与名称关联起来。在 let 中，我们使用 = 将纯函数结果与名称关联起来。
do { planet <- getLine; home <- getLine; putStrLn ("greetings " ++ planet ++ "ling."); putStrLn ("I am from " ++ home ++ "."); putStrLn "Take me to your leader."}
```

Order of function evaluation doesn’t matter in pure code - e.g. **函数求值**的顺序在纯代码中并不重要。

```haskell
-- 我们是否在第二次之前做第一次反转并不重要ーー表达式的结果仍然是相同的。
-- 然而，在 i/o 方面并非如此。排序对 i/o 操作至关重要。
let a = reverse "winston"
    b = reverse "churchill"
in "sir " ++ a ++ " " ++ b

-- 在 do 中，我们使用 <-将 IO 函数的结果与名称关联起来。在 let 中，我们使用 = 将纯函数结果与名称关联起来。
let a= reverse "winston"; b = reverse "churchill"  in "sir " ++a ++" "++ b
```

# Monad

它被用来描述一系列步骤的计算，并处理诸如状态和 i/o 之类的副作用

![](/static/2022-02-09-00-59-37.png)

结构

![](/static/2022-02-09-01-00-48.png)

* type constructor `M`
  * ![](/static/2022-02-09-01-02-44.png)
* function `return::a->M a`
  * ![](/static/2022-02-09-01-03-42.png)
* function `(>>=)::M a->(a->M b)-> M b`
  * ![](/static/2022-02-09-01-07-16.png)

# Monad类型类&接口：Monad and Type classes

![](/static/2022-02-09-01-08-12.png)

![](/static/2022-02-09-01-12-04.png)
![](/static/2022-02-09-01-12-33.png)

# Monad规则：monad laws

* right unit law:
* The left unit law:
* The associativity law:

![](/static/2022-02-09-01-54-32.png)

# Do

![](/static/2022-02-09-01-55-05.png)

Syntax rules for do

```haskell
do { x }  -- >  x

-- 执行x，，执行<xs>
do {x ; <xs> }  -- >  x >> do { <xs> }

-- 执行 x结果传入<xs>继续执行
do { a <- x ; <xs> }  -- >  x >>= \a -> do { <xs> }

do { let <declarations> ; xs }
  -- >
let <declarations> in do { xs }
```

# ==============

# 类型别名 type synonym

　作用和C中的typedef差不多，形式如：

　　type Message = (String, Int)

　　首字母大写。

# 用户自定义类型：User Defined Types/algebraic data types

代数数据类型是结合其他类型作为记录(“乘积”)的类型，Algebraic data types are types that combine other types either as records (‘products’),

(algebraic data types)

user-defined types

* sum type - valued variant type
  * Called “sum” because in algebraic terms, “OR” and sum are related
* product type - record type
  * Called “sum” because in algebraic terms, “AND” and product are related

`data Xxx = ...|...|... deriving Show`

* alternative values relate to algebraic sums
* **variants**

`data Bool = False | True`

* data = 的左端标明类型的名称即 Bool，= 的右端就是值构造子 (Value Constructor)，它们明确了该类型可能的值。| 读作"或" 以上可以理解为：Bool 类型的值可以是 True 或 False。
* **类型名和值构造子的首字母必大写**。
* 项（field）：可以在值构造子后面选择性的加入一些type（s），如下例中Circle 的值构造子有三个项，也可以理解成有三个参数，皆为浮点数
  * `data Shape = Circle Float Float Float`
  * 值构造子本质函数，可以返回一个类型的值
    * `:t Circle`
    * `Circle :: Float -> Float -> Float -> Shape`

![](/static/2022-01-26-12-07-54.png)

* 类型标识符大写
* 如果需要打印type的值，必须包括`deriving Show`

record types (product data types)

* 利用type constructors
  * `Score [Char] Int Int`
    * `Score`是constructor name，可以和type name相同，但是为了避免混淆建议不一样
* record values relate to algebraic products

![](/static/2022-01-26-12-10-51.png)

---

constant

![](/static/2022-01-26-14-55-47.png)
![](/static/2022-01-26-14-55-57.png)

non constant

![](/static/2022-01-26-14-56-42.png)
![](/static/2022-01-26-14-57-24.png)

pattern matching

![](/static/2022-01-26-14-59-45.png)

example product type (record)

![](/static/2022-01-26-20-41-26.png)
![](/static/2022-01-26-20-55-47.png)

## Recursive Data types - Tree 例子

![](/static/2022-01-26-13-08-16.png)

```haskell
let l = Node 3 Leaf Leaf

:t l
l :: Tree

:t Node
Node :: Int -> Tree -> Tree -> Tree
```

![](/static/2022-01-26-13-14-23.png)

* `treeSum :: Tree -> Int`

![](/static/2022-01-26-13-24-39.png)
![](/static/2022-01-26-13-39-40.png)

# Type classes

type class就类似类型的基类/接口

* 类型类是定义了某些操作的一组类型。A type class is a set of types for which some operations are defined.
* 表示后面的type variable is instance of 某个type class
* ![](/static/2022-01-26-13-53-05.png)

```haskell
:t read
-- 注意输入 String,输出a必须显式指明类型
read :: Read a => String -> a
```

利用`deriving`指定某type属于某type class

![](/static/2022-01-26-13-56-00.png)
![](/static/2022-01-26-13-56-30.png)
![](/static/2022-01-26-13-57-17.png)

---

* a type class constrains member types (instances) to conform to an API
* Type classes are like interfaces in C# and Java
* Types in the type class are like concrete implementations of interfaces
* Type classes enable **operator overloading**

# 定义类型类&实例：例子

```haskell
data Bright
  = Blue
  | Red
  deriving (Read, Show)

darkBright :: Bright -> Bool
darkBright Blue = True
darkBright Red  = False

lightenBright :: Bright -> Bright
lightenBright Blue = Red
lightenBright Red = Red

data Pastel
  = Turquoise
  | Tan
  deriving (Read, Show)

darkPastel :: Pastel -> Bool
darkPastel Turquoise = True
darkPastel Tan       = False

lightenPastel :: Pastel -> Pastel
lightenPastel Turquoise = Tan
lightenPastel Tan       = Tan
```

定义类型类 & 类型类实例(声明某类型是类型类成员)

```haskell
-- 定义类型类Color
-- 类型变量a代表特定类型的Color
-- 任何类型Color可以使用dark, lighten

class Color a where
  dark :: a -> Bool
  lighten :: a -> a

-- 声明类型类成员
-- 声明实例时，需要定义类函数
-- 声明Bright实例，dark功能实际是darkBright
instance Color Bright where
    dark = darkBright
    lighten = lightenBright

-- 同理
instance Color Pastel where
      dark = darkPastel
      lighten = lightenPastel
```

# 内置类型类

## Num

![](/static/2022-02-09-00-21-04.png)

## 其他数值类的层次结构 Hierarchy of numeric classes

![](/static/2022-02-09-00-22-14.png)
![](/static/2022-02-09-00-22-47.png)

## 其他

![](/static/2022-02-09-00-28-39.png)

# Show

![](/static/2022-02-08-16-48-58.png)
![](/static/2022-02-09-00-23-51.png)

## 自定义Show类型类实例

![](/static/2022-02-09-00-24-54.png)
![](/static/2022-02-09-00-25-03.png)

## Deriving Show

![](/static/2022-02-09-00-25-39.png)

自动定义一个类型Show的Foo2实例

# 例子 -（+）类型类

![](/static/2022-02-08-22-40-44.png)

# 类型推断：Type Inference

![](/static/2022-02-08-22-48-52.png)

类型推断规则

![](/static/2022-02-08-22-49-27.png)
![](/static/2022-02-08-22-50-12.png)

![](/static/2022-02-08-22-51-31.png)
![](/static/2022-02-08-22-52-11.png)
![](/static/2022-02-08-22-52-55.png)

# 参数化类型例子(类型构造器：泛型)-Type parameter

![](/static/2022-02-03-02-28-43.png)

![](/static/2022-02-03-02-28-54.png)
![](/static/2022-02-03-02-29-28.png)

![](/static/2022-02-10-22-31-23.png)

# Infinite Data Structure

[1..]

repeat 1

![](/static/2022-02-08-20-53-13.png)

# ==============

# 作用域：let,where

## let

```haskell
let x = 2
    y = 3
in x+y
```

在一个 let 中，一个变量可能依赖于另一个变量

```haskell
journeycost :: Float -> Float -> Float
journeycost miles fuelcostperlitre = 
 let milespergallon = 35
     litrespergallon = 4.55
     gallons = miles/milespergallon
 in (gallons*litrespergallon*fuelcostperlitre)

let diameter = 2*radius
    circumference = pi*diameter
in (diameter, circumference)
```

## where

方程式中的 where 关键字提供了**方程式**中使用的变量的定义。The where keyword, inside an equation, provides definitions for variables that are used in the equation.

![](/static/2022-02-03-02-58-36.png)

* 注意位置

```haskell
-- 注意where缩进
squareplusone :: Int -> Int
squareplusone x = xsquared + 1
 where xsquared = x*x

cel2fahr :: Float -> Float
cel2fahr x = (x*scalingfactor) + freezingpoint
 where scalingfactor = 9.0/5.0
       freezingpoint = 32
```

## let,where区别

![](/static/2022-02-03-01-55-00.png)

对于let和where混用，那么是let的优先级高，也就是说优先使用let定义的变量，而不是where定义的变量，比如

```haskell
-- 等于11而不是12
f x =
    let y = x+1
    in y
    where y = x+2
*Main> f 10
11
```

# guard

Haskell 提供了一种基于**谓词值定义函数**的符号。

* `otherwise`
  * 如果前面没有guard评估为True，otherwise一定为True

```
f x
  | predicate1 = expression1
  | predicate2 = expression2
  | predicate3 = expression3
```

---

例子1

`absolute x = if (x<0) then (-x) else x `

```haskell
absolute x
  | x<0 = -x
  | otherwise = x
```

Guards are easier to read than if/then/else if there are more than two conditional outcomes

---

如果有两个以上的条件结果，guard比 if/then/else 更容易理解

例子2

```haskell
holeScore :: Int -> Int -> String
holeScore strokes par
  | strokes < par = show (par-strokes) ++ " under par"
  | strokes == par = "level par"
  | strokes > par = show(strokes-par) ++ " over par"

  -- clean up ,用where重构

holeScore :: Int -> Int -> String
holeScore strokes par
  | score < 0 = show (abs score) ++ " under par"
  | score == 0 = "level par"
  | otherwise = show(score) ++ " over par"
where score = strokes-par
```

# case表达式（模式匹配）：Case expression

模式匹配

![](/static/2022-02-03-02-17-36.png)

```haskell
data Pet = Cat | Dog | Fish

-- 每个模式后面都有一个箭头和一个值
hello :: Pet -> String
hello x = 
  case x of
    Cat -> "meeow"
    Dog -> "woof"
    Fish -> "bubble"
```

---

```haskell
data Pet = Cat | Dog | Fish | Parrot String

hello :: Pet -> String
hello x = 
  case x of
    Cat -> "meeow"
    Dog -> "woof"
    Fish -> "bubble"
    Parrot name -> "pretty " ++ name

-- 注意Parrot这个值构造子
hello (Parrot "polly")
> "pretty polly"
```

## case全匹配（通配符）

guard有otherwise，case有 `_`

```haskell
data Pet = Cat | Dog | Fish | Parrot String

hello :: Pet -> String
hello x =
  case x of
    Parrot name -> "pretty " ++ name
    _ -> "grunt"
```

# 模式匹配&guard区别

![](/static/2022-02-03-02-02-04.png)

# ==============

# Maybe Monad

Example use of Maybe: Safe head and tail
![](/static/2022-02-09-01-58-57.png)

Monad类型的Maybe数据类型实例

![](/static/2022-02-09-02-00-45.png)
![](/static/2022-02-09-02-01-07.png)

---

![](/static/2022-02-09-02-10-41.png)
![](/static/2022-02-09-02-12-07.png)
![](/static/2022-02-09-02-12-52.png)
![](/static/2022-02-09-02-21-54.png)
![](/static/2022-02-09-02-22-40.png)

# Maybe: Optional容器

maybe数据类型data type（Prelude）

* `Nothing`
* `Just a`

![](/static/2022-02-03-02-34-44.png)

---

例子

![](/static/2022-02-03-02-44-14.png)
![](/static/2022-02-03-02-44-42.png)

# fmap & maybe

![](/static/2022-02-03-05-26-38.png)

```haskell
let inc = (+1)
:t inc
Num a -> a -> a

-- 通过fmap使inc能应用于Maybe
fmap inc (Just 1)
> Just 2

fmap inc Nothing
> Nothing
```

# 提取Maybe值

![](/static/2022-02-03-05-18-42.png)

* `fromJust :: Prelude.Maybe a -> a`

# Maybe用于Do块

![](/static/2022-02-03-05-28-26.png)

# ==============

# Monads: QUick Primer

You may have heard the term monad before, and we will discuss the concept in detail in a later session. Haskell uses monads to structure computations. You have already encountered the IO monad, which you need to use to perform IO in a Haskell program. A typical example is 您可能以前听说过单子这个术语，我们将在以后的会议中详细讨论这个概念。Haskell 使用单子来构造计算。您已经遇到了 IO monad，需要使用它在 Haskell 程序中执行 IO。一个典型的例子是

* 这说明了 monad 的关键语法特性: do 关键字、命令序列、使用左箭头 <-和 return 关键字从一元计算中提取信息的方法。事实上，do-notation 的使用与命令式编程非常相似。 This illustrates the key syntactic features of a monad: the do keyword, the sequence of commands, the way to extract information from a monadic computation using the left arrow <- and the return keyword. In fact, using the do-notation is quite similar to imperative programming.
  * return
  * `<-Z`
* 还要注意 hello 函数的返回值: 不只是 String，还有 IO String。在单子中完成的计算返回一个“单子”类型，我们说字符串在单子中返回。Also note the return value of our hello function: **not just String but IO String**. **A computation done in a monad returns a “monadic” type**, we say that the **string is returned inside the monad**.

```haskell
hello :: String -> IO String
hello x =
  do
     putStrLn ("Hello, " ++ x)
     putStrLn "What's your name?"
     name <- getLine
     return name
```

# 解析组合器：Parser combinators

![](/static/2022-02-03-03-33-58.png)

解析组合器是高阶函数，它结合了较小的组合器（解析器）来构建更复杂的组合器。 Parse combinators are high-order functions that combine smaller combinators (parsers) to build more complex ones.

* 所有 Bison、 Yacc 和 Antlr 都不是实际的解析器，而是解析器生成器。它们获取一个语法文件，并为这些语法所描述的语言生成解析器。
* Parsec 是您自己编写的解析器。

# parser combinator结构

解析组合器是高阶函数，它结合了较小的组合器（解析器）来构建更复杂的组合器。 Parse combinators are high-order functions that combine smaller combinators (parsers) to build more complex ones.

* 所有 Bison、 Yacc 和 Antlr 都不是实际的解析器，而是解析器生成器。它们获取一个语法文件，并为这些语法所描述的语言生成解析器。
* Parsec 是您自己编写的解析器。

![](/static/2022-02-03-03-56-39.png)

---

alternative parsers

![](/static/2022-02-03-03-58-04.png)

![](/static/2022-02-03-03-59-02.png)

# 基本组合器

提供了许多基本的解析器。每个参数都接受由 makeTokenParser 使用语言定义生成的 lexer 参数。这里我们使用 Language 模块中的 emptyDef。

```haskell
lexer       = P.makeTokenParser emptyDef

parens          = P.parens lexer    
brackets        = P.brackets lexer    
braces          = P.braces lexer    
commaSep        = P.commaSep lexer
whiteSpace      = P.whiteSpace lexer    
symbol          = P.symbol lexer    
identifier      = P.identifier lexer
integer         = P.integer lexer    
stringLiteral   = P.stringLiteral lexer 
```

![](/static/2022-02-04-00-51-11.png)

## char

![](/static/2022-02-04-00-52-22.png)
![](/static/2022-02-04-00-53-57.png)

## anyChar

![](/static/2022-02-04-00-54-57.png)

## many

![](/static/2022-02-04-00-56-23.png)

## noneOf

![](/static/2022-02-04-00-58-08.png)

## <|>, parenns

要求其他parser作为参数之一

```haskell
parens = \p ->
    \str ->
        -- first match "("
        -- perform the parse of p if "(" was found
        -- then match ")"
        -- return the result
```

---

![](/static/2022-02-04-15-41-09.png)

# try

![](/static/2022-02-04-14-00-16.png)

可以让解析器在匹配失败时不消耗输入:

![](/static/2022-02-04-14-00-30.png)

# 一元解析组合器：Parsec: monadic parsing combinators

Parsec monadic库

![](/static/2022-02-03-03-34-27.png)

导入Parsec

* ` import Text.ParserCombinators.Parsec`

Parsec 提供了方便的 parseTest 函数，该函数接受一个解析器和一个字符串并运行它。让我们尝试在字符串“ cons”上运行解析器 char‘ b’:

* `parseTest (char 'b') "cons"`

---

![](/static/2022-02-03-04-06-03.png)

# varname解析例子:Variable names

![](/static/2022-02-03-04-07-15.png)

# 表达式解析器：Expression Parsers

![](/static/2022-02-03-04-08-01.png)
![](/static/2022-02-03-04-09-39.png)
![](/static/2022-02-03-04-09-55.png)
![](/static/2022-02-03-04-11-11.png)
![](/static/2022-02-03-04-11-22.png)

# makeTokenParser

通过 makeTokenParser 定义语法和关键字的机制

* `makeTokenParser :: Stream s m Char => GenLanguageDef s u m -> GenTokenParser s u m`
* 表达式 makeTokenParser 语言创建一个 GenTokenParser 记录，其中包含使用语言记录中的定义定义的词法解析器。 The expression makeTokenParser language creates a GenTokenParser record that contains lexical parsers that are defined using the definitions in the language record.
* 导入合适的语言定义，并从结果 GenTokenParser 中选择所需的词法解析器。

对于简单的情况，可以使用 emptyDef。

```haskell
import Text.ParserCombinators.Parsec.Expr
import qualified Text.ParserCombinators.Parsec.Token as P
lexer       = P.makeTokenParser emptyDef

parens          = P.parens lexer
commaSep        = P.commaSep lexer
-- and many more
```

# Form of a parser

例如，假设我们要解析表单的字符串(< Tag >) ，其中(Tag)必须是一个单词，并将标记作为类型(Tag)返回。For example, suppose we want to parse a string of the form (< tag>), where (tag) must be a word, and return the tag as a type (Tag).

```haskell
data Tag = MkTag String

parseTag :: Parser Tag
parseTag =
  do  char '<'
      x <- identifier
      char '>'
      return (MkTag x)
```

正如您所看到的，解析器由许多按顺序调用的**函数**(例如 **char** 和 **identifier**)组成。此外，**返回值的类型是 Parser Tag**，而不是简单的 Tag。这是**因为 parse Tag 不返回值，而是返回一个解析器**。我们可以将这个解析器与其他解析器结合起来，然后可以对数据执行最终的解析器。我们将在本教程中更详细地介绍这种方法。As you can see, the parser consists of a number of functions (e.g. char and identifier) that are called sequentially. Also, the return value is of type Parser Tag, not simply Tag. This is because parseTag is not returning a value, instead it returns a parser. We can combine this parser with other parsers, and then we can execute the final parser on our data. We will cover this approach in more detail in the tutorial.

# parser结构

![](/static/2022-02-03-03-54-48.png)

* 解析组合器都返回函数

![](/static/2022-02-03-03-55-39.png)

# 例子：Parsing alternative strings

![](/static/2022-02-03-04-01-31.png)
![](/static/2022-02-03-04-01-51.png)
![](/static/2022-02-03-04-02-59.png)
![](/static/2022-02-03-04-04-48.png)
![](/static/2022-02-03-04-05-02.png)

# 解析xml标签例子

## xml格式

header

```xml
<?xml version="1.0" encoding="utf-8"?>
```

```haskell
xml_header =  "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
```

---

`<Tag>`

* `Tag`为任意文本内容，
* Token作为 `Tag`类型返回
* `<tag> ... </tag>`

```haskell
data Tag = MkTag String

-- 返回Parser Tag为了和其他解析器结合使用
parseTag :: Parser Tag
parseTag =
  do  char '<'
      x <- identifier
      char '>'
      return (MkTag x)

-- 拼接新tag
otag t = "<"++t++">"
ctag t = "</"++t++">"
tag t v = concat [otag t,v,ctag t]
```

---

带属性tag

* `<tag attr1="..." attr2="...">`

```haskell
-- 拼接带属性tag，tag, attr, value
 tagAttrs :: String -> [(String,String)] -> String -> String 
    tagAttrs t attrs v = 
        --  concat :: [[a]] -> [a] -- join lists
        -- concat 接受数组列表，拼接成一个列表
        -- concat [[1,2,3], [1,2,3]]
        -- [1,2,3,1,2,3]
        concat [
          -- 开标签进行拼接
          -- unwords:: [String] -> String
          -- 将String数组转为string，中间插入空格
          -- unwords ["aa","bb","cc","dd","ee"]
          -- > "aa bb cc dd ee"

          -- 完成会拼接成[tag(str)]++[[属性="属性值"]]的列表
          -- 然后unwords展开为一个str，中间每个元素插入空格
          --  unwords $ ["str"] ++ (map (\(k,v)-> concat [k,"=\"",
-- v,"\""]) [("attr1","v1"), ("attr2", "v2")])
          -- "str attr1=\"v1\" attr2=\"v2\""
            otag (unwords $ [t]++(map (\(k,v) -> concat [k,"=\"",v,"\""]) attrs))
            ,v
            ,ctag t
            ]
```

---

## parseList（生成list标签）

list

* `[ ..., ..., ... ]` str输入

```xml
<list>
<list-elt>...</list-elt>
...
</list>
```

```haskell
list_parser = do
    -- 根据str消耗brackets，逗号，Parser String存入ls
    ls <- brackets $ commaSep showParser 
    -- 生成list标签，拼接换行符，拼接内部标签列表list-elt 
    return $ tag "list" $ joinNL $ map (tag "list-elt") ls
```

## parseTuples (生成tuple标签)

`: ( ..., ..., ... )`

```haskell
<tuple>
<tuple-elt>...</tuple-elt>
...
</tuple>
```

```haskell
tuple_parser = do
    -- 消耗括号，后序lexer消耗逗号和其他parser，生成的字符串存入ls
    ls <- parens $ commaSep showParser 
    -- 返回解析str后生成的tuple标签str，拼接
    return $ tag "tuple" $ unwords $ map (tag "tuple-elt") ls
```

## parseRecord (解析record类型string，生成record标签)

`Rec { k=v, ... } `

![](/static/2022-02-08-18-13-50.png)


```xml
<record>
<elt key="k">v</elt>
...
</record>

<!-- key-value pairs: k = v -- v can be anything -->
```

```haskell
record_parser = do
    -- 识别类型标识，大写字母开头 + 任意字母数字组合标识
    ti <- type_identifier
    -- 消耗{，消耗kv，消耗comma，返回解析后str
    ls <- braces $ commaSep kvparser
    -- 做带属性record标签
    return $ tagAttrs "record" [("name",ti)] (joinNL ls)

kvparser = do
-- 消耗id
    k <- identifier
    symbol "="
    -- value可以为任何内容，调showParser，选择alternative parsers
    t <- showParser
    return $ tagAttrs "elt" [("key",k)] t
    
type_identifier = do
    fst <- oneOf ['A' .. 'Z']
    rest <- many alphaNum
    whiteSpace
    return $ fst:rest    
```

## parseDiv（生成div数据类型）

div标签

```haskell
-- Tag类型打印
-- the "deriving Show" is needed to let `ghci` print the result
data Tag = MkTag String deriving Show 

-- 识别div标记，返回Parser Tag类型
parseDiv :: Parser Tag
parseDiv = do 
  string "<div>" 
  return (MkTag "div")

-- 括号，分号代替缩进写法
let parseDiv  = do { string "<div>";return $ MkTag "div" }
```

## parseShow

解析解析器内容，以xml格式返回

```haskell
parseShow :: String -> String
parseShow = \str -> xml_header++(run_parser showParser str)
```

## record type

```haskell
data PersonRecord  = MkPersonRecord {
    name :: String,
    address :: Address,
    id :: Integer,
    labels :: [Label]    
} deriving (Show)

data Address = MkAddress {
    line1 :: String,
    number :: Integer,
    street :: String,
    town :: String,
    postcode :: String
} deriving (Show)

data Label = Green | Red | Blue | Yellow deriving (Show)
```

```haskell
-- 创建PersonRecord实例
rec1 = MkPersonRecord 
    "Wim Vanderbauwhede" 
    (MkAddress "School of Computing Science" 17 "Lilybank Gdns" "Glasgow" "G12 8QQ")
    557188
    [Green, Red]

rec2 = MkPersonRecord 
    "Jeremy Singer" 
    (MkAddress "School of Computing Science" 17 "Lilybank Gdns" "Glasgow" "G12 8QQ")
    42
    [Blue, Yellow]
```

## module - ShowParser

暴露接口 parseShow

