# Week1

* [Week1](#week1)
* [How it works without assignment](#how-it-works-without-assignment)
* [Expressions](#expressions)
* [Equations](#equations)
* [Reduction](#reduction)
  * [Unique reduction path](#unique-reduction-path)
  * [Multiple Reduction](#multiple-reduction)
  * [The result doesn’t depend on reduction path!](#the-result-doesnt-depend-on-reduction-path)
* [Functions](#functions)
  * [Function definitions](#function-definitions)
  * [匿名函数：Anonymous Function](#匿名函数anonymous-function)
  * [高阶函数：Higher-order functions](#高阶函数higher-order-functions)
* [函数返回多个值](#函数返回多个值)
* [lazy evaluation](#lazy-evaluation)
* [Types](#types)
* [Lists](#lists)
* [列表操作](#列表操作)
  * [列表拼接：++](#列表拼接)
  * [索引：!](#索引)
  * [head tail](#head-tail)
  * [添加元素 - ：](#添加元素---)
  * [length](#length)
  * [elem](#elem)
  * [zip](#zip)
  * [zipWith](#zipwith)
* [双参函数func->infix运算符](#双参函数func-infix运算符)
* [infix操作符->prefix 操作符/function](#infix操作符-prefix-操作符function)
* [列表懒惰计算](#列表懒惰计算)
* [序列：Sequences](#序列sequences)
* [列表推导式：List comprehensions](#列表推导式list-comprehensions)
* [Bool/Relational Operators](#boolrelational-operators)
  * [and, or](#and-or)
* [If Expression](#if-expression)
* [I/O](#io)
  * [putStrLn, getLine, do](#putstrln-getline-do)
  * [read](#read)
  * [show](#show)
* [IO Monads](#io-monads)
  * [Pure Function](#pure-function)
  * [IO Type](#io-type)
  * [Sequencing Actions](#sequencing-actions)

# How it works without assignment

never destroy old values, compute new values

* if old value was useless, would be collected by garbage collector

# Expressions

haskell only has expressions， no statements

Pure functional programming languages don’t have any statements — no assignments, no jumps.
纯函数式编程语言没有任何语句ーー没有赋值，没有跳转。

Instead, all computation is performed by evaluating expressions
相反，所有的计算都是通过计算表达式来执行的

---

* **表达式可以包含函数调用**
* id & 形参空格隔开
  * 如果参数是表达式，表达式包括在括号里

```haskell
abs 5 -- > 5
abs (-6) -- > 6
```

# Equations

不是赋值语句，给一个值取名称

* 一个name只能对应一个value
  * “变量”，值不可变

```haskell
n = 1    -- just fine!
x = 3*n  -- fine
n = x    -- Wrong: can have only one definition of n

n = n+1 --可以通过编译，但fail
```

# Reduction

对于命令式程序，我们可以逐条执行语句，跟踪变量(堆栈)的值以及我们在程序中的位置(程序计数器)。

* 归约是将表达式转换为更简单形式的过程。从概念上讲，通过一次简化一个可约表达式(称为“ redex”)来简化表达式。每一步都称为归约，我们将使用 -- > 来显示结果。
* 归约是重要的，因为它是执行函数式程序的唯一手段。没有命令式语言中的语句; 所有的计算都是通过减少表达式来实现的。

## Unique reduction path

![](/static/2022-01-20-03-12-31.png)

## Multiple Reduction

![](/static/2022-01-20-03-13-21.png)

## The result doesn’t depend on reduction path!

A fundamental theorem (the **Church-Rosser theorem**):

一个基本定理(丘奇-罗瑟定理) :

Every terminating reduction path gives the same result

每个终止归约路径给出相同的结果

![](/static/2022-01-20-03-15-01.png)

# Functions

* no need to include parenthesis
* concatenation operator `++`

```python
 def hello(name):
        return "Hello, "+name
```

```haskell
hello name = "Hello, " ++name
```

## Function definitions

![](/static/2022-01-20-03-32-38.png)
![](/static/2022-01-20-03-33-28.png)

## 匿名函数：Anonymous Function

![](/static/2022-01-20-01-31-48.png)

```haskell
f = \x y -> x*y+x+y
f 2 3

(\x -> x+1 ) 4
```

## 高阶函数：Higher-order functions

![](/static/2022-01-20-01-36-42.png)

# 函数返回多个值

![](/static/2022-01-20-03-46-29.png)

```haskell
λ sumprod = \x y -> [x+y,x*y]
[x + y,x * y]
:: [Expr]
λ sumprod 3 8
[11,24]
:: Num t => [t]
```

# lazy evaluation

![](/static/2022-01-20-03-47-23.png)

# Types

```c
 int f (int x, int y) {
        return x*y+x+y;
    }
```

```haskell
f :: Int -> Int -> Int
f x y =  x*y+x+y
```

# Lists

列表不可变

```haskell
lst = [ "A", "list", "of", "strings"]
lst = [1,2] ++ [3,4]
```

# 列表操作

## 列表拼接：++

![](/static/2022-01-20-03-48-50.png)

## 索引：!

![](/static/2022-01-20-03-58-33.png)

## head tail

标准库

![](/static/2022-01-20-04-09-21.png)

## 添加元素 - ：

```haskell
λ 23 : [48, 41, 44]
[23,48,41,44]

λ 42 : []
[42]
:: Num a => [a]
```

## length

```haskell
λ length [23, 29] + length [48, 41, 44] == length ([23, 29] ++ [48, 41, 44])
True
:: Bool
```

```haskell
length ["A","list","of","strings"]
4
```

## elem

判断值是不是列表元素，返回bool

* `elem 1 [1,2,3]` 函数用法
* `3 `elem` [1, 2, 3, 4, 5]` 运算符用法
  * The elem function can be written infix, like an arithmetic operator, by enclosing its name in backquotes ``.

## zip

![](/static/2022-01-20-04-54-21.png)
![](/static/2022-01-20-05-00-04.png)

* 输出长度基于最短输入列表

```haskell

zip [1,2,3] [4,5,6]
[(1,4), (2,5), (3,6)]

-- string is list of char
zip [1,2,3] "abc"
[(1,'a'), (2,'b'), (3,'c')]

zip3 "glasgow" "beijing" "nairobi"
[('g','b','n'), ...]
```

## zipWith

provide function how to combine the elements from the input lists

```haskell
zipWith max [1,2,3] [0,2,4]
[1,2,4]

-- infix op -> prefix func
zipWith (+) [1,2,3] [0,2,4]
[1,4,7]

-- how zip is implemented
zipWith (\x->(\y->(x,y))) [1,2,3] "abc"
[(1,'a'), (2,'b'), (3,'c')]

zipWith (\x y->(x,y)) [1,2,3] "abc"

```

# 双参函数func->infix运算符

In fact, **Haskell permits any two-argument function to be written as an infix operator**  using **backquote** characters. For a further example, try the max function as an infix operator: 42 `max` 13

```haskell
42 `max` 13
42
:: (Num a, Ord a) => a
```

# infix操作符->prefix 操作符/function

Also note that any Haskell infix operator, e.g. +, can be written as a **prefix operator/function by enclosing it in parentheses**, like (+) 1 1

```haskell
(+) 1 1
2
:: Num a => a
```

# 列表懒惰计算

![](/static/2022-01-20-04-11-30.png)
![](/static/2022-01-20-04-20-25.png)

# 序列：Sequences

![](/static/2022-01-20-03-51-35.png)

* 序列生成列表
  * 序列写入方括号，[start..end]
* 序列值
  * 枚举
    * char
    * int

```haskell
λ [0x0A .. 0x1F]
[10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]
```

# 列表推导式：List comprehensions

![](/static/2022-01-20-03-55-44.png)

* 列表操作推导为表达式
* 左边|我们有一个表达式，对右边的列表的每个元素都进行了计算。表达式中的参数是用左箭头<-指定的。

```haskell
[3*x | x <- [1..10]]
-- >
[3,6,9,12,15,18,21,24,27,30]

[2*x | x <- [0..10]]
-- >
[0,2,4,6,8,10,12,14,16,18,20]

[2*x + 1 | x <- [0..10]]
-- >  
[1,3,5,7,9,11,13,15,17,19,21]

[[a,b] | a <- [10,11,12] , b <- [20,21]]
-- >
[[10,20],[10,21],[11,20],[11,21],[12,20],[12,21]]

[2*x+1 | x <- [0,2..10]]
-- >
[1,5,9,13,17,21]
```

# Bool/Relational Operators

* 不能比较两个具有不同类型的值
* `==`
* `/=`
* `<, <=, >, >=`
  * `[1,2,3] < [1,2,3,4]` Note that relational operators also work on lists, in a dictionary-order manner (lexicographic).
  * Since **strings are lists of characters** in Haskell, we can do the same kinds of comparison operations on strings. Check whether Aardvark comes before Aaronic in the dictionary with this code: `"Aardvark" < "Aaronic"`
* `not`
  * `not True`
  * `not (not False)`
* `&&` infix
  * `True && True`
* `||` infix
* `xor` function

```haskell
-- Notice that we specify xor as an infix function with the backquotes here
True `xor` False
```

枚举双输入布尔函数的全部真值表是很直接的。我们可以用一个列表理解表达式来列举输入值。[(x,y) | x<-[False, True], y<-[False, True]] 。然后我们可以在这些输入值上映射布尔函数（从对中提取）。例如，这里是xor函数的列举的输出值：map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]]It's straightforward to enumerate the full truth table for two-input boolean functions. We could use a list comprehension expression to enumerate the input values: [(x,y) | x<-[False, True], y<-[False, True]]. Then we could map the boolean function over these input values (extracted from the pairs). For instance, here are the enumerated output values for the xor function: map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]].

```haskell
[(x,y) | x<-[False, True], y<-[False, True]]
[(False,False),(False,True),(True,False),(True,True)]

map (\inputs -> xor (fst inputs) (snd inputs)) [(x,y) | x<-[False, True], y<-[False, True]]
[False,True,True,False]
:: [Bool]
```

## and, or

有时，像AND和OR这样的布尔逻辑函数有两个以上的输入。Haskell支持这些多输入的布尔运算，有and和or函数，这些函数将布尔值列表作为单一输入。实际上，这是对输入布尔值列表的&&或||运算符的折叠。Sometimes, boolean logic functions like AND and OR have more than two inputs. Haskell supports these multi-input boolean operations with and and or functions that take a list of boolean values as a single input. Effectively, this is a fold of the && or || operator over the input list of boolean values.

```haskell
and [False, True, False, True]
False

or [True, True, False]
True
```

# If Expression

Haskell有if表达式，它根据if值，评估为then值或else值。

* Haskell的if表达式等同于类C语言中的?: 三元运算符。第一个子表达式（在if之后）的类型必须是Bool，然后后面的两个子表达式（分别在then和else之后）的类型必须是相同的 The Haskell if expression is equivalent to the ?: ternary operator in C-like languages. The first subexpression (after the if) must have type Bool, then the subsequent two subexpressions (after then and else respectively) must have the same type as each other.
  * 无效
    * `if 1 then 0 else -1`
    * `if False then 42 else "foo"`

```haskell
if 2*2==4 then "happy" else "sad"
"happy"
:: [Char]

-- 有可能两个值是相似的，也就是说，根据它们的类型类别，它们可以被专门化为同一类型
-- It is possible to have two values that are similar, i.e. they could be specialized to the same type, based on their type classes.
if True then 42 else pi
42.0
```

# I/O

## putStrLn, getLine, do

向终端打印字符串的Haskell函数叫做`putStrLn`（像Java中的println或Python中的print）。

* `putStrLn ("good " ++ "morning" ++ " everyone")`

读入 & do structure

* `do`
  * 排列IO操作
  * <-用于在do块中把名字和值联系起来，而->则用于定义函数。<- is for associating names with values in do blocks whereas -> is used for defining functions.

```haskell
λ getLine
> read
"read"
:: IO String

-- 正如我们所看到的，你可以用do结构来排列IO操作。用左边的箭头将值绑定到变量上。我们可以把它理解为x从getLine中获得一个值。请注意，你不能对getLine使用标准的赋值（等价操作），因为它是一个IO操作 As we have seen, you can sequence IO operations with the do construct. Values are bound to variables using the left arrow. We could read this as x gets a value from getLine. Be aware that you can't use the standard assignment (with the equals operator) for getLine, since it is an IO operation.
do { putStrLn "what is your name?"; x <- getLine; putStrLn ("hello " ++ x) }

-- 一旦我们从getLine得到一个值，并把它绑定到一个变量上，那么我们就可以对这个值进行标准的函数调用，并把它绑定到另一个变量上 Once we have got a value from getLine, and bound it to a variable, then we can do standard function calls on this value, and bind it to another variable
do { putStrLn "what is your name?"; n<-getLine; let nUpper = map toUpper n in putStrLn ("HELLO " ++ nUpper) } 
```

## read

可以将数值读成字符串，并将其转换为其他类型。这就像C语言中的atoi函数一样。试试读 "42":: Int。你需要::Int类型注释，否则就不清楚输入的String是代表什么类型的数字 It is possible to read values as strings, and convert them into other types. This is like the atoi function in C. Try read "42" :: Int. You need the ::Int type annotation otherwise it is not clear what type of number the input String is meant to represent.

```haskell
read "42" :: Int
42
:: Int

read "42"::Float
42.0
:: Float
```

## show

show函数是read函数的对偶。 show接收一个值并返回该值的一个字符串表示 The show function is the dual of the read function. show takes a value and returns a String representation of that value. 

* 请注意，返回的值具有String类型。只有一些类型（派生出Show的类型）可以转换为字符串 Notice that the returned value has the String type. Only some types (those that derive Show) can be converted to Strings
* show函数(之后的结果)，允许打印出任意的值
  * `putStrLn (show (6*7))`
    * 等价于 `print (6*7)`

```haskell
show 42
"42"
:: String
```

# IO Monads

## Pure Function

https://www.futurelearn.com/courses/functional-programming-haskell/10/steps/1103578

到目前为止，我们集中讨论了纯函数。这些类型的函数将值作为参数，对这些值进行一些处理，然后返回结果值。一个纯函数不依赖于“世界的状态”。计算是完全自包含和独立的。给定相同的参数，纯函数总是返回相同的结果。So far, we have concentrated on pure functions. These kinds of functions take values as arguments, do some processing of those values, then return a result value. A pure function does not depend on the ‘state of the world’. The computation is entirely self-contained and independent. Given the same arguments, a pure function will always return the same result.

## IO Type

![](/static/2022-01-20-05-42-54.png)

## Sequencing Actions

```haskell
let greet() = do 
    planet <- getLine
    home <- getLine
    putStrLn ("greetings " ++ planet ++ "ling.")
    putStrLn ("I am from " ++ home ++ ".")
    putStrLn "Take me to your leader."

-- 在 do 中，我们使用 <-将 IO 函数的结果与名称关联起来。在 let 中，我们使用 = 将纯函数结果与名称关联起来。
do { planet <- getLine; home <- getLine; putStrLn ("greetings " ++ planet ++ "ling."); putStrLn ("I am from " ++ home ++ "."); putStrLn "Take me to your leader."}
```

Order of function evaluation doesn’t matter in pure code - e.g. **函数求值**的顺序在纯代码中并不重要。

```haskell
-- 我们是否在第二次之前做第一次反转并不重要ーー表达式的结果仍然是相同的。
-- 然而，在 i/o 方面并非如此。排序对 i/o 操作至关重要。
let a = reverse "winston"
    b = reverse "churchill"
in "sir " ++ a ++ " " ++ b

-- 在 do 中，我们使用 <-将 IO 函数的结果与名称关联起来。在 let 中，我们使用 = 将纯函数结果与名称关联起来。
let a= reverse "winston"; b = reverse "churchill"  in "sir " ++a ++" "++ b
```

