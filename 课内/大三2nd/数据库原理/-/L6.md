# Secondary index Task

![](/static/2021-03-27-19-59-18.png)

* 某文件 `b` 个数据块
* 针对**non-ordering field, non-key attribute** 建立二级索引，索引项个数 `m<b`
  * `DNO`
* `X` - 每个数据块中 `DNO=10`的记录
  * 给定某块，`X`代表在DNO=10中工作的员工数
* `P(X>=1)=0.5` （每两块中，至少一块中能找到一个DNO=10的记录）
  * 某块中至少一条记录属于 `DNO=10`的概率
* `f` 块指针块因子 block factor of block which fit block pointers
  * 每块能存 `f`个块指针，即 `f`个块物理地址

---

:orange: 平均多少数据块有至少一条 `DNO=10`的记录

* 因为 `P(X>=1)=0.5`，所以平均b/2块就有至少一条记录满足，即数据的一半满足

:orange: 检索所有 `DNO=10`的记录 预计成本是什么（使用索引）？

* 考虑baseline solution -  worst case scenario
  * no-index
  * 线性搜索，因为文件乱序，需要 b次块访问
* ideal solution - best case
  * 检索b/2个块，找到所有记录 （实际records not ordered）
* 使用索引
  * 索引块数 `m<b`
  * 因为索引文件有序，二分查找定位特定索引项包括指针指向存储块指针（指向至少包含一条符合要求记录的数据块）的块
    * `log2 (m)`
  * 因为平均文件中 `b/2`个块包含 `DNO=10`的记录
    * 需要 `b/2`个块指针（整个文件中，指向物理块地址）
  * 因为每块（cluster中）能存储`f`个块指针
    * 因此一共需要 `b/2f`个块（存储块指针，每个块链式连接）
  * 并且，需要访问所有这些块(b/2f)，及里面的块指针(一共b/2)完成所有记录的检索
  * **`C=log2(m) + b/2f + b/2 = log2(m) + b/2(1+1/f)`**

:orange: 前假设 `b/2 <=C< b`

* `b/2(1+1/f)` 确定 `b/2 < C` （worse than the optimal case）
* 找到/定义一个`max(m)` upper bound，使得better than the worst case (`b`)

# Book1

![](/static/2021-03-27-23-54-21.png)

![](/static/2021-03-28-00-02-39.png)

* 索引通常建立在文件的单字段上，该字段称为索引字段/属性
  * 索引文件存储索引项（**包含，索引字段值&指向包含该索引字段值的物理块块指针**)
  * 索引文件通常<数据文件，所以同时有序情况下，二分查找索引更优

## 3 Main Index Types

![](/static/2021-03-28-00-08-41.png)

* **主索引 primary index**
  * 建立于有序文件的排序字段（键, ordering key field）上，
* **聚簇索引 cluster index**
  * 建立于有序文件的非排序字段上（非键，ordering non-key field)
* **文件最多一个排序字段，因此主索引 & 聚簇字段最多一个，但不能同时存在**
* **二级索引 secondary index**
  * 可定义于任何文件的非排序字段上（nonordering field on file, non-key or key）

---

### Primary Index

![](/static/2021-03-28-11-15-11.png)
![](/static/2021-03-28-11-37-23.png)

* value存的  index field（ordering key field,unique）的值
* pointer指向含有该索引字段值的块，，并且该索引字段值正好作为anchor record?
* 属于sparse（nondense） index
  * **主索引数=数据块数**
  * 每个数据块的锚点记录对应一个主索引项
