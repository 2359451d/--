# Some note

已提供g4 Calc文法， `ExecVisitor.java`遍历AST，执行Calc程序

* 每个节点定义一个Exec/visit方法，执行计算，返回值or0

`CalcRun.java` 驱动，main方法，

* 输入Calc源程序，创建lexer（初始化），输入source code file，输出token stream
  * **本身没提供，要通过ANTLR自动生成lexer**
* 创建parser（初始化），解析每个token，输出AST短语
  * **本身没提供，要通过ANTLR自动生成parser**
  * parser提供 `prog()`， 解析整个树
    * 底层顺序访问 `com()`, `expr()`
  * **最后生成AST**
* 初始化 Visitor（可执行计算） & 提供 `visit()`方法
  * `exec.visit(tree)`，执行Calc程序

# ANTLR工具生成Calc lexer & parser

`java -jar antlr-4.9.2-complete.jar -no-listener -visitor src/ast/Calc.g4`
`javac -cp "antlr-4.9.2-complete.jar" -d bin/ -sourcepath src/ src/calc/CalcRun.java`

执行Driver，解释特定calc程序

`java -cp "antlr-4.9.2-complete.jar:bin" calc/CalcRun tests/test1.calc`

---

执行 test2.calc，

java -cp "antlr-4.9.2-complete.jar;bin" calc/CalcRun tests/test2.calc

```
line 4:15 token recognition error at: '/'
line 4:16 extraneous input '2' expecting EOL
```

* 无法识别token /
* `4:15` - line:column

# Fun compiler

`FunCheckerVisitor.java`

* 遍历AST，进行contextual analysis,,
  * scope, type checking

`FunENcodedVisitor.java`

* 遍历AST，generate SVM object code

`SVM.java`

* 定义SVM指令，包括指令生成方法（one by one placed into SVM instance code store）
  * `emitXXX()`方法由`FunEncodedVisitor`调用
* `interpret()`方法，解释程序

`FunRun.java`

* Driver, 包含3个完整编译步骤
* 输入Fun源程序，输出SVM对象码
* 打印AST & SVM对象码，帮助调试

`FunParse.java`

* 语法分析，解析方法，生成个节点AST短语
  * 涉及 lexer & parser，需要ANTLR生成

`FunCheck.java`

* 语法分析&上下文分析
  * type checking, report any errors

## 生成parser，lexer & 解释程序

java -jar antlr-4.9.2-complete.jar -no-listener -visitor src/ast/Fun.g4

* update

javac -cp "antlr-4.9.2-complete.jar" -d bin/ -sourcepath src src/fun/FunRun.java

* copy Driver

---

运行 特定Fun程序

* java -cp "antlr-4.9.2-complete.jar:bin" fun/FunRun tests/assign.fun

# 扩展for loop & switch

3阶段

* 语法分析
  * 定义文法，指明结构特性
* 上下文分析
  * 类型，作用域检测规则
  * 扩展Visitor （checker）
* 代码生成
  * 定义代码模板
  * 扩展visitor (encoded)

## For-command

```
func int fac (int n): # returns n!
    int i = 0
    int f = 1
    for i = 2 to n: # i from 2 to n
        f = f*i .   # 注意com_seq, dot?
    return f        # jumpf if i<2
```

```g4
com = ident ‘=’ expression – assignment command
| ident ‘(’ actual ‘)’ – procedure call
| ‘if’ expr ‘:’ seq-com
( ‘.’ | ‘else’ ‘:’ seq-com ‘.’ ) – if-command
| ‘while’ expr ‘:’ seq-com ‘.’ – while-command
| ‘for’ ident ‘=’ expr ‘to’ expr ‘:’
 seq-com ‘.’ – for-command
```

作用域/类型规则

* control variable(condition遍历)
  * 必须已定义为 `int`类型的local variable
* `expr1` & `expr2` 类型结果-> `int`

语义semantics,,(code generation actions)

* **注意如果，expr2<expr1，for loop不执行**
* `for ident=expr1 to expr2: seq-com .`
* `ident`local var 赋值`expr1`
* if `ident>expr2` 【JUMPT】
  * terminate for loop
* 执行 `seq-com`
* `ident++`
* continue looping, JUMP(backwards)

## Switch-command

```
func int test (int n):
    int r = 0
    int s = 0
    switch n: # int类型
        case 1:  # gurad
            r = 1 #seq-com?
            s = 2
        case 2..4: # guard
            s = 3
        default: # default case
            r = 4
    .
    write(s)
    return r
    .

```

```
func bool invert (bool b):
    bool x = false
    switch b:   # bool
        case true:
            x = false   #seq-com
        default:    #default case
            x = true
    .
    return x
.
```

syntax,typing rules, semantics

* switch expr: (case guard:seq-com )* default: seq-com DOT(?)
* `expr` - BOOL|INT expr
* `guard` 3 forms (只允许字面量 literals)
  * INT
  * BOOL
  * INT...INT (INT RANGE)
    * `2..4` -> case `2,3,4`
* `guard` & `expr`类型一致，
  * 进行 TYPECHECK
* `guard`中数字不允许重复
  * range也不允许重叠
* 必须有一个default case
* 不需要 `break`
  * **每个`case`结束，`JUMP`至switch end**

