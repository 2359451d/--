# Static Analysis, Readability and Design Quality

* [Static Analysis, Readability and Design Quality](#static-analysis-readability-and-design-quality)
* [é™æ€vsåŠ¨æ€åˆ†æï¼šStatic vs Dynamic Analysis](#é™æ€vsåŠ¨æ€åˆ†æstatic-vs-dynamic-analysis)
* [é™æ€åˆ†æç”¨ä¾‹ï¼šUse Cases](#é™æ€åˆ†æç”¨ä¾‹use-cases)
* [ä»£ç è‡ªæ–‡æ¡£åŒ–ï¼šSelf Documenting Code](#ä»£ç è‡ªæ–‡æ¡£åŒ–self-documenting-code)
* [è‡ªåŠ¨ä»£ç åˆ†æçš„æ„è§è°±ï¼šThe Spectrum of Opinionation for Automated Code Analysis](#è‡ªåŠ¨ä»£ç åˆ†æçš„æ„è§è°±the-spectrum-of-opinionation-for-automated-code-analysis)
* [ä»£ç é£æ ¼æ ‡å‡†ï¼šCode Style Standards](#ä»£ç é£æ ¼æ ‡å‡†code-style-standards)
* [é™æ€åˆ†æ-ä»£ç é£æ ¼æ£€æŸ¥å·¥å…·ï¼šLinting Tools](#é™æ€åˆ†æ-ä»£ç é£æ ¼æ£€æŸ¥å·¥å…·linting-tools)
  * [æ•´åˆgitlabï¼šIntegration with Gitlab](#æ•´åˆgitlabintegration-with-gitlab)
* [é™æ€åˆ†æ-ç¼ºé™·æ£€æµ‹ï¼šBug Detection](#é™æ€åˆ†æ-ç¼ºé™·æ£€æµ‹bug-detection)
* [æ¼æ´åˆ†æ--Javaä¸­çš„SQLæ³¨å…¥ç¤ºä¾‹ï¼šVulnerablity Analysis - Example SQL Injection in Java](#æ¼æ´åˆ†æ--javaä¸­çš„sqlæ³¨å…¥ç¤ºä¾‹vulnerablity-analysis---example-sql-injection-in-java)
* [IO & Memory Managementä¾‹å­](#io--memory-managementä¾‹å­)
* [Measuring Designs](#measuring-designs)
* [åœˆå¤æ‚åº¦ï¼šCyclomatic Complexity](#åœˆå¤æ‚åº¦cyclomatic-complexity)
* [åµŒå¥—æ·±åº¦:Nested Scope Depth](#åµŒå¥—æ·±åº¦nested-scope-depth)
* [è€¦åˆåº¦ï¼šMeasuring Coupling](#è€¦åˆåº¦measuring-coupling)
* [æ‰‡å…¥æ‰‡å‡ºå¤æ‚åº¦ï¼šFan in versus fan out complexity](#æ‰‡å…¥æ‰‡å‡ºå¤æ‚åº¦fan-in-versus-fan-out-complexity)
* [ç»§æ‰¿æ·±åº¦&å®½åº¦ï¼šInheritance Hierarchy Depth & Width](#ç»§æ‰¿æ·±åº¦å®½åº¦inheritance-hierarchy-depth--width)
* [Other Topics](#other-topics)
* [Summary](#summary)

# é™æ€vsåŠ¨æ€åˆ†æï¼šStatic vs Dynamic Analysis

![](/static/2020-11-24-21-56-43.png)

**é™æ€åˆ†æ**

* é™æ€åˆ†æé€‚ç”¨äºé™æ€çš„ç¨‹åºå·¥ä»¶ Static analysis is applied on program artifacts at rest.
* é™æ€æµ‹é‡/åˆ†æï¼Œ**æ˜¯åœ¨ã€æ‰§è¡Œä¹‹å‰ã€‘åº”ç”¨äºæºä»£ç æˆ–ç¼–è¯‘åçš„åº”ç”¨ç¨‹åºä»£ç **ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªç±»æ–‡ä»¶ä¸­å¯¼å…¥è¯­å¥çš„æ•°é‡å¯ä»¥è¡¡é‡è¯¥ç±»æ–‡ä»¶ä¸åº”ç”¨ç¨‹åºä¸­å…¶ä»–ç±»çš„è€¦åˆç¨‹åº¦ Static measurement is applied to the source code or compiled application code before execution occurs. For example, the number of import statements in a class file gives a measure of how coupled that class file is to other classes in the application.

**åŠ¨æ€åˆ†æ**

* åŠ¨æ€åˆ†ææ˜¯åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­åº”ç”¨çš„ Dynamic analysis is applied during execution.
* åŠ¨æ€æµ‹é‡/åˆ†ææ˜¯åœ¨æ‰§è¡ŒæœŸé—´åº”ç”¨çš„ã€‚ä¾‹å¦‚ï¼Œåº”ç”¨ç¨‹åº**çº¿ç¨‹åœ¨ä¸€ä¸ªç±»ã€æ–¹æ³•æˆ–å¯¹è±¡ä¸­èŠ±è´¹çš„æ—¶é—´**å¯ä»¥æä¾›å…³äºåº”ç”¨ç¨‹åºä¸åŒéƒ¨åˆ†æ‰€æä¾›çš„åŠŸèƒ½æ•°é‡çš„ä¿¡æ¯ã€‚åŠ¨æ€åˆ†æä¾èµ–äºé€‚å½“çš„æµ‹è¯•åœºæ™¯çš„è§„èŒƒï¼Œåœ¨è¿™äº›æµ‹è¯•åœºæ™¯ä¸­è¯„ä¼°è®¾è®¡ Dynamic measurement is applied during execution. For example, the amount of time an application thread spends inside a class, method or object can provide information about the amount of functionality provided by different parts of an application. Dynamic measurement is dependent on the specification of appropriate test scenarios in which to evaluate a design.

**ç¨‹åºåˆ†ææ„ä»¶/å…ƒä»¶**å¯ä»¥æ˜¯ program artifacts may be

* æºä»£ç  source code
* ç¼–è¯‘åçš„å¯¹è±¡ä»£ç  compiled object object

:orange: ä»¤äººå›°æƒ‘çš„æ˜¯ï¼Œä¸€äº›å…·æœ‰ç›¸åŒåç§°çš„æµ‹é‡å¯ä»¥åŒæ—¶è¿›è¡Œé™æ€å’ŒåŠ¨æ€çš„æµ‹é‡ Confusingly, some measurements with the same name can be taken both statically and dynamically

* ä¾‹å¦‚ï¼Œä»**ä¸€ä¸ªç±»åˆ°å¦ä¸€ä¸ªç±»çš„æ–¹æ³•è°ƒç”¨çš„æ•°é‡**å¯ä»¥é€šè¿‡é™æ€ï¼ˆè®¡ç®—æ–¹æ³•è¢«å¼•ç”¨çš„å”¯ä¸€ä¸Šä¸‹æ–‡çš„æ•°é‡ï¼‰æˆ–åŠ¨æ€ï¼ˆè®¡ç®—ç¨‹åºæ‰§è¡ŒæœŸé—´å‘ç”Ÿçš„æ–¹æ³•çš„æ‰€æœ‰è°ƒç”¨ï¼‰æ¥æµ‹é‡ã€‚ For example, the number of method calls from one class to another can be measured statically (by counting the number of unique contexts in which a method is referenced) or dynamically by counting all invocations of a method that occur during program execution.
* ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œè¿™ä¸¤ç§æµ‹é‡æ–¹æ³•å‘Šè¯‰æˆ‘ä»¬çš„æ˜¯ä¸åŒçš„äº‹æƒ…ã€‚åœ¨åŠ¨æ€æƒ…å†µä¸‹ï¼Œè¿™å¯ä»¥æ˜¾ç¤ºå‡ºæ€§èƒ½ä¼˜åŒ–å¯èƒ½å¸¦æ¥çš„æœ€å¤§å¥½å¤„ã€‚ä»é™æ€ä¸Šçœ‹ï¼Œè¿™å‘Šè¯‰æˆ‘ä»¬å¯¹ä»£ç çš„æ”¹å˜æ˜¯å¦å¯èƒ½æ˜¯è„†å¼±çš„ Note, however, that these two measures are telling us different things. Dynamically, this can indicate where performance optimisations might have the greatest benefit. Statically, this tells us whether a change to the code might be brittle

# é™æ€åˆ†æç”¨ä¾‹ï¼šUse Cases

![](/static/2020-11-24-22-08-12.png)

:orange: é™æ€åˆ†ææ˜¯è½¯ä»¶å·¥ç¨‹å·¥ä½œæµç¨‹ä¸­çš„ä¸€ä¸ªé‡è¦å·¥å…·ã€‚<font color="red">é™æ€åˆ†æå¯ä»¥æ£€æµ‹å‡ºå„ç§å„æ ·çš„ç¼ºé™·</font>ã€‚å·¥å…·é€šå¸¸åœ¨**æ„å»ºç®¡é“**ä¸­ä½¿ç”¨ Static analysis is an important tool in a software engineering workflow. Static analysis can detect a wide variety of defects. Tools are typically used within a build pipeline.

* **å¼€å‘äººå‘˜åœ¨æäº¤å®¡é˜…å‰æ£€æŸ¥æ›´æ”¹** Developers check changes before submission to review.
* CIç®¡é“å¯ä»¥**é˜»æ­¢æœªèƒ½é€šè¿‡é™æ€åˆ†ææ£€æŸ¥çš„åˆå¹¶è¯·æ±‚** CI pipeline can block merge requests that fail static analysis checks
  * é˜²æ­¢ç¼ºé™·è¿›å…¥ä¸»çº¿ Prevents defects entering the mainline
  * ä¼˜åŒ–ä»£ç å®¡æŸ¥è¿‡ç¨‹ Optimises code review process
* **ååŠ©å®¡æŸ¥å‘˜è¯„ä¼°æ‹Ÿè®®çš„å˜æ›´** Assists reviewers in assessing proposed changes.
  * by providing the measurements of the code

# ä»£ç è‡ªæ–‡æ¡£åŒ–ï¼šSelf Documenting Code

![](/static/2020-11-24-22-09-44.png)

é™æ€åˆ†æå¦‚ä½•ç”¨æ¥æé«˜ä»£ç å¯è¯»æ€§

self-documenting code

* ä»¥è¿™æ ·é£æ ¼å†™çš„codeï¼Œä¸éœ€è¦é¢å¤–çš„è§£é‡Šï¼ˆsource code commentsè§£é‡Šï¼‰
  * æ— éœ€å‚è€ƒè¡¥å……æ–‡ä»¶å°±èƒ½è½»æ˜“ç†è§£çš„ä»£ç ã€‚ Code that can be readily understood without reference to supplementary documentation.
* variable name
* control structure

ç»´æŠ¤å†—ä½™æ€§&è§£é‡Šä»£ç ä½œç”¨ï¼Œself-documentingä¸å†å¿…è¦

# è‡ªåŠ¨ä»£ç åˆ†æçš„æ„è§è°±ï¼šThe Spectrum of Opinionation for Automated Code Analysis

è¯¥å›¾æ˜¾ç¤ºäº†**å¯å¯¹ç¨‹åºè¿›è¡Œçš„è‡ªåŠ¨æ£€æŸ¥**çš„é¢‘è°± The diagram shows the spectrum of automated checks that can be performed on a program.

![](/static/2020-11-24-22-10-46.png)

* æœ€å·¦è¾¹çš„è€ƒè™‘ï¼Œéœ€è¦è¢«ä¿®å¤
* èˆ†è®ºå¯¼å‘åœ¨å…‰è°±çš„å·¦è¾¹å¢åŠ ã€‚**è¿™æ„å‘³ç€è¯¥å·¥å…·å°†è¶Šæ¥è¶Šç¡®å®šæœ‰ä¸€ç§æ­£ç¡®çš„æ–¹æ³•æ¥åšäº‹æƒ…ï¼Œå¹¶ä¸”åœ¨æŸäº›æƒ…å†µä¸‹å¼ºè¿«ä½ éµå¾ªè¿™ç§æ–¹æ³•**ã€‚Opinionation increases to the left of the spectrum. This means that the tool is going to be increasingly certain that there is a right way to do things and in some cases force you to follow this approach.
  * æœ€æ˜æ˜¾çš„æƒ…å†µæ˜¯ç¼–è¯‘å™¨æˆ–è§£é‡Šå™¨çš„è¯­æ³•é”™è¯¯ã€‚å¦‚æœç¨‹åºä¸èƒ½è¢«ç¼–è¯‘å™¨ç†è§£ï¼Œé‚£ä¹ˆå°±ä¸ä¼šäº§ç”ŸäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä¹Ÿæ— æ³•æ‰§è¡Œ The most obvious case is compiler or interpreter syntax errors. If the program cannot be understood by the compiler then no binary will be produced and it canâ€™t be executed.

:orange: ç›¸åï¼Œ**è®¾è®¡æŒ‡æ ‡**éœ€è¦ä»”ç»†è§£é‡Šï¼Œè€Œä¸”é€šå¸¸å¯¹ä»£ç å®¡æŸ¥æœ€æœ‰ç”¨ï¼Œè€Œä¸æ˜¯ç”¨äºè§„å®šæ€§ Conversely, design metrics need careful interpretation and are often most useful for informing code reviews, rather than being used for prescriptive.

:orange: é™æ€åˆ†æå¤„äºå®Œå…¨è§„å®šæ€§å’Œå®Œå…¨ä¸»è§‚æ€§çš„ä¸­é—´ä½ç½®ã€‚**é™æ€åˆ†æå·¥å…·å‘å‡ºçš„è­¦å‘Šï¼Œä»ç¼–è¯‘å™¨è­¦å‘Šåˆ°æç«¯çš„è®¾è®¡æŒ‡æ ‡æµ‹é‡ï¼Œä¸ä¸€å®šéè¦ä¿®å¤æ‰èƒ½ä½¿ç¨‹åºè‡³å°‘æ‰§è¡Œï¼Œä½†è¿™æ ·åšå¯èƒ½ä¼šæé«˜ä»£ç çš„è´¨é‡å¹¶å¢å¼ºé•¿æœŸçš„å¯ç»´æŠ¤æ€§** Static analysis sits somewhere in the middle between completely prescriptive and completely subjective. Warnings from static analysis tools, from compiler warnings through to extreme design metric measurements donâ€™t have to be fixed in order for the program to at least execute, but doing so is likely to improve the quality of the code and enhance long term maintainability.

:orange: åœ¨æŸäº›æ–¹é¢ï¼Œä½ å¯ä»¥æŠŠ**ä»£ç å®¡æŸ¥çœ‹ä½œæ˜¯åœ¨å…‰è°±çš„æœ€å³è¾¹**ã€‚ In some ways, you can think of code review as being on the far right of the spectrum.

* å¦‚æœåšå¾—å¥½ï¼Œå®ƒåº”è¯¥ä¸“æ³¨äºé«˜æ°´å¹³çš„è€ƒè™‘ï¼Œå¹¶ä»¥è®¾è®¡æŒ‡æ ‡ä¸ºä¾æ®ï¼Œè€Œè¿™äº›è€ƒè™‘æ›´å…·æœ‰ä¸»è§‚æ€§ Done well, it should focus on high level considerations, informed by design metrics, that are more subjective.

# ä»£ç é£æ ¼æ ‡å‡†ï¼šCode Style Standards

![](/static/2020-11-24-22-11-47.png)

:orange: **å¤§å¤šæ•°è¯­è¨€éƒ½æœ‰é£æ ¼æŒ‡å—** Style guides exist for most languages

* **'å®˜æ–¹'æˆ–ç¤¾åŒºè¯­è¨€æŒ‡å—**ï¼Œ â€˜Officialâ€™ or community language guides, e.g. PEP8 for Python
  * å¦‚PEP8 for Pythonã€‚
* **ä¾›åº”å•†é©±åŠ¨**ï¼Œ Vendor driven, e.g. many guides for Ruby, Oracle, Eclipse, Atlassian for Java
  * ä¾‹å¦‚è®¸å¤šRubyã€Oracleã€Eclipseã€Atlassiançš„JavaæŒ‡å—ã€‚

ğŸŠ **å¤§å¤šæ•°è¯­è¨€éƒ½æœ‰lintingæ£€æŸ¥å·¥å…·** Linting tools available for most languages

* **è‡ªåŠ¨æ£€æŸ¥ä»£ç æ˜¯å¦æŒ‰ç…§ä»£ç æ ‡å‡†è¿›è¡Œç¼–è¯‘** check automatically whether the code is compiled with code standards

---

![](/static/2020-11-24-22-13-33.png)
![](/static/2020-11-24-22-15-30.png)

Code style standards åŒ…å«å¤šä¸ªissues

:orange: **ä»£ç é£æ ¼æ ‡å‡†è§„åˆ™åŒ…æ‹¬** Rules cover

* **è¡Œé•¿åº¦** Line length (e.g. max 80 or 120)
  * 80ï¼Œ120
* **æ ‡è¯†ç¬¦å‘½åè§„èŒƒ** Identifier naming conventions
  * `f/F/f_hand` ä¸ `last_commit_file_handle`ï¼ˆfull literalsæ¨èï¼‰
* **ç©ºæ ¼ä½¿ç”¨è§„èŒƒï¼Œæ°´å¹³ï¼Œå‚ç›´** Use of white space (horizontal and vertical)
  * `y = x  + z **    2/3`ï¼ˆé”™ï¼‰
  * `y = x + z ** 2 / 3`ï¼ˆå¯è¯»ï¼‰
* **æ§åˆ¶ç»“æ„çš„ä½¿ç”¨** Control structure usage
  * æ§åˆ¶ç»“æ„åŒ…æ‹¬ifã€forã€whenã€returnã€continue
* **æ‹¬å·çš„ä½¿ç”¨** Control structure usage
* **å†—ä½™ä»£ç ** Control structure usage
  * å†—ä½™ä»£ç çš„ä¾‹å­åŒ…æ‹¬ä¸å¯è¾¾çš„è¯­å¥ï¼Œä½†ä¹ŸåŒ…æ‹¬æœªä½¿ç”¨çš„å˜é‡å’Œå¯¼å…¥å£°æ˜ Examples of redundant code include unreachable statements, but also unused variable and import declarations.
* **éšå¼ä½¿ç”¨æ¨¡å¼** Implicit usage patterns
  * éšå¼ä½¿ç”¨æ¨¡å¼åœ¨åŠŸèƒ½ä¸Šæ˜¯æ­£ç¡®çš„ï¼Œä½†æœ‰æ›´æ˜ç¡®çš„é€‰æ‹©ã€‚ä¾‹å¦‚ï¼Œæœ€å¥½æ˜¯ Implicit usage patterns are functionally correct, but have more explicit alternatives. For example, it is better to
  * `type(x) == int` versus `isinstance(x, int)`
* **æ£€æŸ¥æ‹¼å†™çš„å·¥å…·** Some tools also check for spelling

:orange: æœ€é‡è¦çš„æ ‡å‡†æ˜¯ï¼Œä»£ç åº“åœ¨é£æ ¼ä¸Šæ˜¯æ™®éä¸€è‡´çš„ Most important criteria is that code base is universally consistent in style.

# é™æ€åˆ†æ-ä»£ç é£æ ¼æ£€æŸ¥å·¥å…·ï¼šLinting Tools

![](/static/2020-11-24-22-17-09.png)

* é™æ€ä»£ç æ£€æŸ¥å·¥å…·ï¼Ÿ

## æ•´åˆgitlabï¼šIntegration with Gitlab

![](/static/2020-11-24-22-18-41.png)

# é™æ€åˆ†æ-ç¼ºé™·æ£€æµ‹ï¼šBug Detection

![](/static/2020-11-24-22-19-08.png)

ğŸŠ é™¤äº†**å¯è¯»æ€§å’Œä¸è‰¯é£æ ¼**ä¹‹å¤–ï¼Œ**é™æ€åˆ†æè¿˜å¯ä»¥ä»ä¸è‰¯çš„ä½¿ç”¨æ¨¡å¼ä¸­æ‰¾å‡ºå¯èƒ½çš„æ½œåœ¨é”™è¯¯** Beyond readability and poor style, static analysis can also identify likely potential bugs from poor usage patterns.

ä¾‹å­

* å¯ä»¥è¿”å›nullçš„'å±æ€§'æ–¹æ³• â€˜Propertyâ€™ methods that can return null
* è®¿é—®ç©ºå¯¹è±¡å±æ€§ Access of null object properties
* æ–¹æ³•æˆ–å‡½æ•°ä¸­ä¸ä¸€è‡´çš„è¿”å›è¯­å¥ Inconsistent return statements in a method or function
* è¿‡è½½çš„æ–¹æ³•åç§° Overloaded method names
* é‡æ–°å®šä¹‰æˆ–é‡æ–°åˆ†é…å˜é‡æˆ–å‚æ•° Redefined or re-assigned variables or parameters

# æ¼æ´åˆ†æ--Javaä¸­çš„SQLæ³¨å…¥ç¤ºä¾‹ï¼šVulnerablity Analysis - Example SQL Injection in Java

![](/static/2020-11-24-22-20-46.png)

JDBC Statementçš„SQLæ³¨å…¥ä¾‹å­

# IO & Memory Managementä¾‹å­

è¿™å¹¶ä¸èƒ½ä¿è¯è¾“å…¥æµï¼ˆå’Œåº•å±‚æ–‡ä»¶å¥æŸ„ï¼‰å°†è¢«å…³é—­å¹¶æ­£ç¡®æ¸…ç†èµ„æº This doesnâ€™t guarantee that the input stream (and underlying file handle) will be closed and clean up the resources properly

![](/static/2020-11-24-22-22-40.png)
![](/static/2020-11-24-22-23-05.png)
![](/static/2020-11-24-22-23-24.png)

# Measuring Designs

è®¾è®¡çš„æµ‹é‡åœ¨é¢å‘å¯¹è±¡çš„è½¯ä»¶å·¥ç¨‹2ä¸­è¢«å¹¿æ³›åœ°æ¶‰åŠ Measurement of designs is covered extensively in object oriented software engineering 2.

æœ¬è®²åº§çš„éƒ¨åˆ†å†…å®¹æ˜¯åˆ·æ–°ï¼Œä¹Ÿæ˜¯ä¸ºäº†ç¡®å®šå¯ä»¥**ä½¿ç”¨è‡ªåŠ¨åŒ–è½¯ä»¶å·¥å…·è¿›è¡Œçš„æµ‹é‡ï¼Œä»¥æ”¯æŒä»£ç å®¡æŸ¥** This part of the lecture is part refresh, but also to identify measurements that can be taken using automated software tools to support code reviews.

# åœˆå¤æ‚åº¦ï¼šCyclomatic Complexity

é™æ€åˆ†ææŒ‡æ ‡

* å¾ªç¯å¤æ‚åº¦æ˜¯é’ˆå¯¹ç¨‹åºä¸­ç‹¬ç«‹è·¯å¾„çš„æ•°é‡è€Œå®šä¹‰çš„ä¸€ä¸ªæŒ‡æ ‡[24]ã€‚è¿™ä¸ªæŒ‡æ ‡è¶Šé«˜ï¼Œä¸€ä¸ªç¨‹åºå•å…ƒå°±è¶Šæœ‰å¯èƒ½éš¾ä»¥æµ‹è¯•å’Œç»´æŠ¤è€Œä¸å‡ºé”™
* ç¨‹åºçš„å¤§å°å’Œå®ƒçš„å¾ªç¯å¤æ‚æ€§ä¹‹é—´ä¸ä¸€å®šæœ‰ç›´æ¥çš„è”ç³»ï¼Œä½†ä»æŠ½æ ·çš„ä»£ç ç‰¹å¾å¯ä»¥çœ‹å‡ºï¼Œéšç€ç¨‹åºå¤§å°çš„å¢åŠ ï¼Œå¯èƒ½ä¼šå‡ºç°æ›´å¤šçš„å†³ç­–ç‚¹ï¼Œå› æ­¤å¾ªç¯å¤æ‚æ€§ä¹Ÿä¼šå¢åŠ ï¼ˆå›¾8ï¼‰ã€‚è¯·æ³¨æ„ï¼Œè¿™ç§å…³ç³»å–å†³äºä»£ç çš„åŠŸèƒ½

![](/static/2020-11-24-22-23-52.png)

`å¤æ‚åº¦= è¾¹- ç»“ç‚¹æ•° + è¿æ¥ç»„ä»¶æ•°ç›®ï¼ˆç›¸è¿èŠ‚ç‚¹çš„çš„æœ€å¤§é›†åˆï¼‰ï¼‰*2` <10

![](/static/2020-11-24-22-37-52.png)

---

# åµŒå¥—æ·±åº¦:Nested Scope Depth

![](/static/2020-11-24-22-38-22.png)

* 6 - **calculate the total number of block in each control structure**

# è€¦åˆåº¦ï¼šMeasuring Coupling

**è¿™äº›åŸå§‹æŒ‡æ ‡å¯ä»¥è·¨è¶Šä¸åŒçš„èŒƒå›´è¾¹ç•Œï¼Œä¹Ÿå¯ä»¥åœ¨è¿™äº›èŒƒå›´å†…æ”¶é›†ï¼Œä»¥ä¾¿æä¾›é¢å¤–çš„è§è§£**ã€‚

* ä¾‹å¦‚ï¼Œ**ä¸åŒåŒ…ä¸­çš„ç±»ä¹‹é—´çš„æ–¹æ³•è°ƒç”¨**é€šå¸¸æ˜¯**æ¯”åŒä¸€åŒ…ä¸­çš„ç±»ä¹‹é—´çš„æ–¹æ³•è°ƒç”¨**æ›´é‡è¦çš„è€¦åˆå½¢å¼ These raw metrics can be gathered across different scope boundaries, as well as within them in order to provide additional insights. For example, method calls between classes in different packages are usually a more significant form of coupling than method calls between classes in the same package.

![](/static/2020-11-24-22-38-46.png)

* **åŸå§‹æµ‹é‡** Raw Measures
  * æ–¹æ³•è°ƒç”¨ & å˜é‡è®¿é—® Method calls and variable accesses
  * importè¯­å¥ Import statements
  * ç±»å‹ä½¿ç”¨ Type usages
  * ç»§æ‰¿å…³ç³»(class) Inheritance relations
* **æµ‹é‡åŸŸ** Scope
  * æ–¹æ³• Method
  * ç±» Class
  * æ¨¡å— Module
  * åŒ… Package
  * app

# æ‰‡å…¥æ‰‡å‡ºå¤æ‚åº¦ï¼šFan in versus fan out complexity

![](/static/2020-11-24-22-40-50.png)

:orange: **æ‰‡å…¥** fan-in

* æ‰‡å…¥æè¿°äº†å…¶ä»–ç±»å¯¹ä¸€ä¸ªç±»çš„å…¥ç«™å¼•ç”¨çš„æ•°é‡ Fan in describes the number of inbound references to a class from other classes
* <font color="red"> æ‰‡å…¥æœ‰æ—¶è¢«ç§°ä¸ºä¼ å…¥è€¦åˆï¼Œå› ä¸ºå®ƒæè¿°äº†çŸ¥é“è¿™ä¸ªç±»çš„ç±»çš„æ•°é‡</font> Fan in is sometimes referred to as afferent coupling because it describes the number of classes that know about this class. Fan in is useful for more precisely identifying the number of classes that may have to change if the subject class is changed.
* **è°ä¾èµ–ä½ ** who depends on you
  * ä¾èµ–ä½ çš„å·¥ä»¶çš„æ•°é‡ï¼Œæ¯”å¦‚å…¶ä»–åŒ…ç”¨äº†ä½ è¿™ä¸ªåŒ…ï¼Œå…¶ä»–åŒ…çš„æ•°é‡å°±æ˜¯ä½ çš„æ‰‡å…¥/ä¼ å…¥è€¦åˆ
* ä¸€ä¸ªç±»æ”¹å˜ï¼Œå…¶ä»–å…³è”çš„ç±»éƒ½å¾—æ”¹
  * Changing a class with high afferent coupling will result in changes to many other classes.

:orange: **æ‰‡å‡º** Fan-out

* æ‰‡å‡ºè¡¨ç¤ºä»ä¸€ä¸ªç±»åˆ°å…¶ä»–ç±»çš„å¤–å‘å¼•ç”¨çš„æ•°é‡ Fan out denotes the number of outbound references from a class to other classes.
* <font color="red">æ‰‡å‡ºæœ‰æ—¶è¢«ç§°ä¸ºä¼ å‡ºè€¦åˆï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªç±»æ‰€å¼•ç”¨çš„æ‰€æœ‰å…¶å®ƒç±»çš„è®¡ç®—</font> Fan out is sometimes referred to as efferent coupling, since it is a calculation of all the other classes that a class refers to
* ä½ ä¾èµ–è° who do you depend on
* <font color="deeppink">æ‰‡å‡ºå¯¹äºç¡®å®šä¸€ä¸ªç±»å¯èƒ½éœ€è¦æ”¹å˜çš„é¢‘ç‡æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œå› ä¸ºå®ƒä¾èµ–äºå¤§é‡çš„å…¶å®ƒç±»ï¼ˆè¿™äº›ç±»ä¼šè¢«æ”¹å˜</font> Fan out is useful for determining how often a class may need to change because of the large number of other classes that it depends on (that are subject to change).

# ç»§æ‰¿æ·±åº¦&å®½åº¦ï¼šInheritance Hierarchy Depth & Width

![](/static/2020-11-24-22-41-35.png)

æ·±å±‚æ¬¡çš„ç»§æ‰¿å±‚æ¬¡å¯èƒ½è¡¨æ˜è¿‡åº¦æŠ½è±¡ã€‚è¿™æ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸ºå±‚æ¬¡è¶Šæ·±ï¼Œäº§ç”Ÿå­©å­çš„å¯èƒ½æ€§å°±è¶Šå¤§ï¼Œè€Œä¸”è¶Šéš¾ä¿®æ”¹ Deep inheritance hierarchies may indicate an over-abstraction. This is problematic because the deeper the hierarchy the greater the potential for children and the harder it is to modify

æ·±åº¦ç»§æ‰¿å±‚æ¬¡ç»“æ„æ„å‘³ç€å±‚æ¬¡ç»“æ„é¡¶ç«¯çš„ç±»å¾ˆéš¾è¢«ä¿®æ”¹ Deep inheritance hierarchies mean that classes at the top of the hierarchy are difficult to modify.

# Other Topics

![](/static/2020-11-24-22-42-04.png)

# Summary

![](/static/2020-11-24-22-42-22.png)

é™æ€åˆ†æå·¥å…·æ˜¯**è‡ªåŠ¨æ£€æµ‹é”™è¯¯å’Œä¸è‰¯é£æ ¼çš„æœ‰æ•ˆæ‰‹æ®µ**ï¼Œä½œä¸ºæŒç»­é›†æˆæµæ°´çº¿çš„ä¸€éƒ¨åˆ†ï¼Œè¿™äº›é”™è¯¯å’Œä¸è‰¯é£æ ¼å¯ä»¥åœ¨**ä»£ç å®¡æŸ¥**ä¹‹å‰è¢«æ¶ˆé™¤ã€‚ Static analysis tools are an effective means of automatically detecting bugs and poor style that can be eliminated prior to code review as part of a continuous integration pipeline.

ä¸ºäº†ç¡®å®šå¯ä»¥ä½¿ç”¨è‡ªåŠ¨åŒ–è½¯ä»¶å·¥å…·è¿›è¡Œçš„æµ‹é‡ï¼Œä»¥æ”¯æŒä»£ç å®¡æŸ¥