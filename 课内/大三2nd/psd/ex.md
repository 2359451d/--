# 1

一位项目经理对她的团队在项目生命周期的后期整合他们的开发工作的趋势感到担忧。这导致了以前的开发阶段出现延误，因为团队努力将他们的工作与彼此的努力结合起来。**一些关键的缺陷也是在发布后才被发现的，因为在整合后没有太多时间来测试新版本的系统**。 A project manager is concerned about the tendency of her team to integrate their development efforts late on in the project life cycle. This has caused previous development phases to experience delays as the team struggle to integrate their work with one another’s efforts. A number of critical defects were also only discovered post release as there was too little time for testing the new version of the system following integration

为了解决这些问题，项目经理提议为项目实施**持续集成**。**团队使用Git进行版本控制，所以她在自己的台式电脑上建立了一个仓库。各个开发人员需要从他们自己的开发环境中向这个仓库的分支推送更改。项目经理在Slack上为团队设置了一个每日提醒，提醒他们这样做** To address these problems, the project manager proposes to implement continuous integration for the project. The team is using Git for version control, so she sets up a repository on her own desktop PC. Individual developers are required to push changes to branches in this repository from their own development environments. The project manager sets up a daily reminder on Slack to the team to nag them to do this

在每个工作日结束时，项目经理将项目管理环境中的修改合并到一个主分支。该软件是用Python编写的，所以一旦所有的代码被合并，**她就可以使用Python解释器直接运行它。然后她在应用程序上运行一些标准的手动验收测试。有时会发现项目的依赖性发生了变化，所以她会找到丢失的库并将其安装在她的桌面上。在每次整合过程中，经理都会将任何失败的测试记录在word文档中。一旦她做出判断，谁应该对每个失败的测试负责，然后把细节发邮件给他们** At the end of each working day the project manager merges the changes from the project management environment to a master branch. The software is written in Python, so once all the code is merged she can run it straight away using the Python interpreter. She then runs a number of standard manual acceptance tests on the application. Sometimes this reveals that the project’s dependencies have changed, so she finds the missing library and installs it on her desktop. During each integration, the manager maintains a word document of any failed tests. Once she makes a judgement about who is responsible for each broken test and then emails them the details

当经理**第一次采用持续集成时，她发现她经常在傍晚时分才完成测试过程。随着时间的推移，项目越来越大，她发现她每天都要工作到深夜才能完成这个过程**。这部分是由于每天必须找到的新的**依赖**关系的数量，**但也是由于代码库和相应的验收测试集的规模越来越大**。她估计，**即使验收测试是完全自动化的，也可能需要一个多小时来执行它们** When the manager first adopts continuous integration, she finds she often doesn’t finish the testing process until the early evening. As time goes on and the project gets larger, she finds that she is working late into the night each day to finish the process. This is partly due to the number of new dependencies that must be found each day, but also due to the growing size of the code base and corresponding set of acceptance tests. She estimates that even if the acceptance tests were fully automated, it might take over an hour to execute them

* 提出项目经理错误应用持续集成的五种方式。在每个案例中，你应该参考Fowler(2006)所倡导的做法，以及该场景的具体细节。在每个案例中，解释你将如何改变她所采用的工作流程。 Suggest five ways the project manager has mis-applied continuous integration. In each case, you should reference a practice advocated by Fowler (2006) as well as the specifics of the scenario. In each case, explain how you would change the workflow that she has adopted.

# 2

后来，项目经理决定实施代码审查，试图提高项目的整体质量。在每个星期五结束的时候，**她把在持续集成过程中引起最多问题的包分配给一个开发人员进行审查。开发人员被要求在持续集成过程中完成审查工作**。她为审查者提供了一份需要检查的问题清单，如违反风格、拼写错误、错过重用的机会等等。**这种方法可能有问题的一个原因是，审查是在已经合并的代码上进行的，而不是在拟议的修改上。这意味着审查员没有审查包括有用文档的修改请求，例如修改的目的**。请提出其他三个原因，说明这种代码审查方法可能有问题。 Later on, the project manager decides to implement code reviews to try to improve the overall quality of the project. At the end of every Friday, she allocates the package that has caused the most problems during her continuous integration process to a developer for review. The developer is required to complete the review whilst the continuous integration process is underway. She provides the reviewer with a checklist of problems to check for, such as style violations, spelling mistakes, missed opportunities for reuse and so on. One reason this approach could be problematic is that the reviews are undertaken on already merged code, rather than on proposed changes. This means that the reviewer isn’t reviewing a change request that includes useful documentation, such as the purpose of the change. Suggest three other reasons why this approach to code review may be problematic.

1. 项目经理只分配了导致最多问题的软件包，而不是关注软件包的整体、源代码和文档。也许，这些工件也需要更新，以提高代码的准确性和质量。 The project manager only allocates the package that cause the most problems instead of focusing on the packages overall, source code and documentations. Probably, those artifacts also need to be updated in order to improve codes accuracy and quality. 
2. 在代码审查期间，我们应该分享对项目的理解。只有项目经理将代码审查分配给个人，才违反了从协作改进代码库中分享知识的原则。 During the code review, we should share the understanding of the project. Only project manager assigning code review to individuals violate the purpose from collaborative improvement of code base sharing knowledge principle. 
3. 这个过程没有分享代码中已经实施的良好做法，这也是一个重要的步骤。它只试图找到代码中的错误，在审查过程中缺乏提问的过程 This process does not share the good practices that have been implemented in the code is also an important step. It only tries to find errors in the code and lacks question asking process during a review

# 3

这个用户故事显然不小。参照该方案的具体内容。
给出其他四个原因，说明你的同事提出的用户故事违反了其他的
INVEST标准。每条标准及其描述得1分

该用户故事不是独立的。"区分不同的账户类型，如签署的用户故事中所述"，这指的是多个用户故事。我们必须把它们分成不同的子故事 The user story is not independent. “discriminate between different account types, as described in the sign on user story” which refers to multiple user stories. We must separate them into different sub-stories. 

用户故事是不可协商的。"系统应该使用联合单点登录服务.... "提供了关于服务实现细节的具体信息。它是一个固定的需求。 The user story is not negotiable. “the system should use a federated single-sign-on service….” provides specific information about service implementation details. It is a fixed requirement.

用户故事是不可估计的。"这一切都很重要，我可以管理我的事件"，故事的每一部分都很重要，所以我们不能控制用户故事的规模。 The user story is not estimable. “This is all important so that I can manage my events “, every part of the story is important, so we cannot control the scale of user story

该用户故事是不可测试的。在文章中，"变化应该导致对用户的通知"。它没有提到具体的应用程序，所以我不知道我应该使用哪个平台来产生通知。 The user story is not testable. In the article, “Changes should result in notification to users”. It does not refer to specific application, so I do not know which platform I should use to generate notification. 

我不同意我的同事的观点。根据需求与设计的关系，需求应该是基于预先存在的框架或库的具体内容，这已经被固定为移动平台应用程序。因此，在移动框架之上开发是开发这个软件的基本要求。基于这一事实，当用户故事再次强调平台时，它不是一种强加的。 I do not agree with my colleague. According to the requirement versus design, the requirement should be based on preexisting framework or library specifics which has already been fixed as mobile platform app. Thus, developing on top of a mobile framework is a basic requirement of develop this software. Base on this fact, when the user story emphasize platform again, it is not a kind of imposing. 

# 4

一个软件开发团队正在进行一个名为 "我们如何通勤 "的公民科学项目。该团队已经开发了一个移动应用程序，允许用户注册一个或多个通勤旅程。例如，一个**学生**可能总是从他们的公寓步行到大学。或者，一个**讲师**可能有时骑自行车上班，有时开车，在这种情况下，他们会登记两种不同的通勤方式。**该应用程序允许用户登记不同的交通方式、路线和旅行时间，并将每次变化记录为通勤**。每天早上和晚上，该应用程序都会邀请用户选择他们将在该旅程中使用的通勤方式。该团队现在正在研究从**用户那里收集信息的基础设施，并将其分发给消费者**，他们可能是研究人员或其他感兴趣的人。该架构应能适应随着时间推移而增加的这些消费者。一些消费者只对特定地理区域的数据感兴趣，比如一个特定的城市。其他消费者对来自通用地理区域类别的数据感兴趣，如 "农村 "或 "城市"。一些消费者只对特定类型的旅行感兴趣，如乘坐公共交通，或步行。所有的消费者都希望能够实时收到关于通勤的数据。一些消费者对此特别感兴趣，他们希望能够使用这些信息来实时预测潜在的旅行问题。例如，交通管理服务可能希望提前知道，如果大量的用户计划在有交通工程的道路上开车通勤，那么他们就可以发出关于潜在拥堵的警告。最后，移动应用程序可以通过同一架构接收来自其他客户的汇总信息（例如，鼓励参与）。

A software development team is working on a citizen science project called How we Commute. The team have developed a mobile application that allows users to register one or more commuter journeys. For example, a student may always walk to university from their flat. Alternatively, a lecturer might sometimes cycle to work and sometimes drive, in which case they register two different commutes. The app allows users to register the different modes of transport, route taken and times travelled, with each variation recorded as a commute. Each morning and evening the app invites the user to select which of their commutes they will be using for that journey. The team are now working on the infrastructure for collecting information from the users and distributing it to consumers, who might be researchers or other interested parties. The architecture should accommodate the addition of these consumers over time. Some consumers are only interested in data from a specific geographic area, such as a particular city. Other consumers are interested in data from a generic class of geographic area, such as ‘rural’ or ‘city’. Some consumers are only interested in specific types of travel, such as by public transport, or walking. All the consumers want to be able to receive the data about commutes in real time. This is of particular interest to some consumers, who want to be able to use the information to predict potential journey problems in real time. For example, a traffic management service may want to know in advance if a large number of users are planning to commute by car down a road where traffic works are present, so they can issue warnings about potential congestion. Finally, the mobile apps may receive aggregated information from other clients via the same architecture (to encourage participation for, example).

客户端A和B是消息生产者，代表从用户那里收集的数据，向消费者客户端C、D发送消息，以代表研究人员或其他有关方面。每个主题代表不同的信息，如特殊区域（城市、农村）和交通（步行、公交和驾车）。同一主题向其消费者发送重复的信息。 Clients A and B are message producers which represents the data collected from users, sending messages to consumer clients C, D in order to represent researchers or other interested parties. Each topic represents different information, such as the special area (city, rural) and transportation(walk, bus and drive). The same topic sends the duplicated message to its consumers. 

因为它要求是实时的，所以任何一个领域的消息消费者都会同步地获得消息。同步消费者进行显式调用以检索消息。消费者也可以通过指定传入消息的选择标准来过滤掉消息。IBroker负责消息的路由 Since it requires to be the real time, message consumers in either domain will get messages synchronously. Synchronous consumers make an explicit call to retrieve a message. Consumers can also filter out messages by specifying selection criteria for incoming messages. IBroker takes charge of route the messages

# 5

后来，你在一次代码审查中与一位同事讨论了这个代码片段。你的同事认为Context类是一个单子，它的使用是一种代码气味，因为所有使用它的东西都被耦合到了实现，而不是一个接口。请说明你是否同意你的同事的观点并给出理由。 Later, you are discussing the code fragment with a colleague during a code review. Your colleague argues that the Context class is a singleton and that its use is a code smell, because everything which uses it is coupled to the implementation, rather than an interface.Your colleague recommends making the Singleton an interface that is passed as an argument to every method that requires it. State whether you agree with your colleague and give a justification

我同意我同事的观点。因为单子类意味着该类中只有一个对象，它是由该对象自己设计的，并保持所有的属性和功能。这可能会导致高耦合性，从而降低代码的灵活性和可读性。然而，接口是一个框架。我们可以在不同的情况下调整接口并扩展这些功能。它为进一步的开发重用了代码，实现了软件开发的多态性。因此，它是松散的耦合，增加了逻辑上的理解。 I agree with my colleague. Because singleton class means there is exactly one object in the class which is designed by the object itself and maintains all the attributes and functionalities. It may lead high coupling, which reduce the flexibility and readability of the code. However, interface is a framework. We can adapt interface in different circumstances and extend those functionalities. It reuses the code for further development and achieves polymorphism in software development. Thus, it is loose coupling and increase the logical understanding.