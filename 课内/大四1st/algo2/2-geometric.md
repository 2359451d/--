# Content

* [Content](#content)
* [求最近点对问题：Finding a closest pair of points](#求最近点对问题finding-a-closest-pair-of-points)
* [分治法案例 - 归并排序mergesort](#分治法案例---归并排序mergesort)
  * [时间复杂度](#时间复杂度)
* [最近点对算法 - closet pair algorithm](#最近点对算法---closet-pair-algorithm)
  * [情况3：最坏情况 - y坐标排序](#情况3最坏情况---y坐标排序)
  * [总结](#总结)
  * [伪码](#伪码)
  * [分析](#分析)
* [求水平垂直线段交点问题](#求水平垂直线段交点问题)
  * [暴力解](#暴力解)
  * [扫描线算法：line-sweep](#扫描线算法line-sweep)
  * [线扫描算法-可视化](#线扫描算法-可视化)
  * [线段端点排序](#线段端点排序)
  * [如何改进垂直线段对于candidate集合的比较](#如何改进垂直线段对于candidate集合的比较)
  * [candidate集合选用什么数据结构？](#candidate集合选用什么数据结构)
  * [选用AVL树](#选用avl树)
  * [AVL树例子](#avl树例子)
  * [candidate range searching](#candidate-range-searching)
  * [范围检索Pseudocode](#范围检索pseudocode)
  * [线扫描算法- 总结](#线扫描算法--总结)
  * [线扫描算法 - 分析](#线扫描算法---分析)

# 求最近点对问题：Finding a closest pair of points

![](/static/2021-10-07-04-51-29.png)

* naive - 每个点进行与其他点的距离判断
* 分治法 O(nlogn) - 基于Sort

# 分治法案例 - 归并排序mergesort

![](/static/2021-10-07-04-55-17.png)
![](/static/2021-10-07-05-00-10.png)

左闭右闭

* 重点是辅助数组 & 游标划分
* 每次选值最小的存入辅助数组
* 左边或右边数组有一个游标到底了就直接存入另一半数组的所有值
* 划分步骤开始就得到有序数组了（以midpoint为基准，左右有序）。。

## 时间复杂度

![](/static/2021-10-07-05-10-28.png)
![](/static/2021-10-07-05-14-25.png)
![](/static/2021-10-07-05-12-56.png)
![](/static/2021-10-07-05-15-54.png)

* 每次对半分2个，递归call
* 最后2^k=n，带入，解得

# 最近点对算法 - closet pair algorithm

![](/static/2021-10-07-23-33-41.png)
![](/static/2021-10-07-23-42-34.png)

* 集合P中所有点根据x坐标排序 - nlogn
* 根据x坐标&划分线，P集合划分为两个相等子集，Q，R
  * Q - 左边点
  * R - 右边点
* 分 - 每个子集进行递归
  * **递归结束时，能获得两个子集Q，R的最近点对**
* 合
  * 最近点对有3种情况
  * Q子集内
  * R子集内
  * Q，R中各一点。此时搜vertical strip范围内点对（该点对要满足<=d）

---

**最坏情况下**需要根据y坐标排序，进一步缩减，加速寻找点对（只用检查常量个点）

![](/static/2021-10-08-00-37-03.png)
![](/static/2021-10-08-00-19-38.png)

* 针对某点x（Q）只用看d*d的这个矩形范围内的点（常量个）
* 2d*2d矩形由两个矩形组成
  * Q子集，这个矩形里面所有点对距离肯定>=d1，因为d1是Q中的最近点对距离，，肯定不在这个矩形内
    * 然后因为d<=d1，替换。Q矩形内所有的点距离应满足>=d
  * R子集同理

![](/static/2021-10-08-00-23-11.png)
![](/static/2021-10-08-00-24-30.png)

* 最坏情况（点在四个角） - 4个

![](/static/2021-10-08-00-25-40.png)

* 合并后，最坏情况下，如果某点正好在6个角其中一个位置。只需要再检查剩下5个（upper bound）

## 情况3：最坏情况 - y坐标排序

情况3（点分别来自两个集合），最坏情况下需要strip内点对，根据y坐标排序。再利用特性，完成针对某点，找剩余点（常量个）的过程

![](/static/2021-10-08-00-48-00.png)

* mergesort递归会来的时候，希望得到某集合，其中某集合点根据y坐标升序排列（y越小越前面）

## 总结

先分成两个集合，然后在各个集合中找最近点对（距离），最后将他们根据y坐标排序。。然后合成一个集合（主要为了确认第三种情况，点对（p∈Q, q∈R）），此时已经y坐标有序（应对最坏情况下），，**进行进一步在vertical strip中的点对搜寻**（过滤掉在strip外的点），看看能不能更新此时的最近点对

关键：分割线位置是以左右两个集合中点数量决定的

## 伪码

![](/static/2021-10-08-00-53-39.png)

* 返回最近点对的距离

![](/static/2021-10-08-00-54-17.png)

* **左闭右闭**范围内，所有点对的距离
* 递归返回时 -假设所有的点也根据y坐标升序排列
* 递归返回值 - 集合范围内最近点对的距离

---

![](/static/2021-10-08-01-28-27.png)

* 如果集合中只有一个点要处理，，直接返回最大DOUBLE值。，因为此时不存在最近点对概念

---

辅助方法

![](/static/2021-10-08-01-30-37.png)
![](/static/2021-10-08-01-30-27.png)

![](/static/2021-10-08-01-31-17.png)

## 分析

类似mergesort

![](/static/2021-10-08-01-59-16.png)

# 求水平垂直线段交点问题

![](/static/2021-10-08-03-08-00.png)

* 应用：如电路设计中，想减少crossing的个数

## 暴力解

因为是水平&垂直线段，O(1)时间能判断&找到其中一对的交点

![](/static/2021-10-08-03-12-58.png)

暴力解 - 一对对判断（最坏情况下不能更快了，，因为就算针对每个交点每次O(1)操作，还是要O(hv)的时间）

![](/static/2021-10-08-03-15-49.png)

---

当p（交点数）更小的时候，（非最坏情况），利用line-sweep算法来改进

![](/static/2021-10-08-03-17-53.png)

## 扫描线算法：line-sweep

额，一种判断两个水平线段相交的方法（基于x坐标sorted，，进行LR两个端点进行标记，如果相交那么列表中标记是LLRR，不相交就是LRLR）

![](/static/2021-10-08-03-27-03.png)
![](/static/2021-10-08-03-28-14.png)

* 判断两个垂直线段也是同理，根据y坐标排序

---

![](/static/2021-10-08-03-29-23.png)

![](/static/2021-10-08-03-34-33.png)
![](/static/2021-10-08-03-33-46.png)

* 当扫描线扫到某个垂直线段时，利用candidate sets判断交点
  * 只有candidate中，在垂直线段y坐标范围内的水平线段有机会跟垂直线段相交。
* 最坏情况下还是O(hv)，及时0个交点
  * **因为存在，可能所有水平线段都为candidate，且交点=0的情况**【怎么解决的看后面】
  * ![](/static/2021-10-08-03-36-07.png)

## 线扫描算法-可视化

![](/static/2021-10-08-03-38-08.png)
![](/static/2021-10-08-03-38-40.png)

![](/static/2021-10-08-03-40-15.png)

![](/static/2021-10-08-03-41-00.png)

![](/static/2021-10-08-03-41-32.png)

![](/static/2021-10-08-03-42-05.png)

![](/static/2021-10-08-03-42-19.png)

![](/static/2021-10-08-03-42-33.png)

![](/static/2021-10-08-03-42-45.png)

![](/static/2021-10-08-03-42-55.png)

![](/static/2021-10-08-03-43-09.png)

![](/static/2021-10-08-03-43-21.png)

![](/static/2021-10-08-03-43-33.png)

![](/static/2021-10-08-03-43-42.png)

![](/static/2021-10-08-03-43-51.png)

![](/static/2021-10-08-03-44-03.png)

![](/static/2021-10-08-03-44-09.png)

## 线段端点排序

x坐标排序的时候得特别注意

![](/static/2021-10-08-03-57-10.png)

* 排序的时候，如果多个端点x坐标相同时，
  * **确保水平直线段的左端点，先在垂直线段的端点之前被处理**
    * 先把垂直线段的端点加进candidate集合
    * ![](/static/2021-10-08-03-52-02.png)
      * 比如，先把p6加进来，不然就少算一个与p7垂直线段的交点
  * **确保水平线段的右端点，在垂直线段的端点处理之后再被处理**
    * ![](/static/2021-10-08-03-55-23.png)
      * 这里应该最后把p15移出去，不然就少算与p23相交的交点

## 如何改进垂直线段对于candidate集合的比较

最坏情况，O(hv)（就算交点为0），如果单纯只是把每个垂直线段跟candidate集合中水平线段进行判断，如何改进？

![](/static/2021-10-08-04-05-47.png)
![](/static/2021-10-08-04-04-57.png)

* candidate集合的值 - 存candidate的y坐标
  * 从而根据垂直线段的y坐标范围，过滤candidate集合

---

## candidate集合选用什么数据结构？

**数组**

![](/static/2021-10-08-04-10-27.png)

* 过滤 - 二分查找，先sortcandidate数组，然后基于有序数组，定位y1范围，再定位y2范围（上下界）
* 但增删效率很低

## 选用AVL树

range searching步骤高效增删查

![](/static/2021-10-08-04-24-32.png)

* AVL树 的增删查 - O(logh)
* candidate range searching - O(k+logh)
  * k - 范围内，candidate大小

## AVL树例子

![](/static/2021-10-08-04-26-45.png)

两个辅助线辅助可视化，，（因为此时还不知道最后结果范围)

![](/static/2021-10-08-04-29-04.png)

* 标蓝的为添加到结果的节点
* 标黄的 - 等会过去处理的
* 橙色 - 要么还没处理的，要么根据BST特性不用处理的

![](/static/2021-10-08-04-29-36.png)
![](/static/2021-10-08-04-30-38.png)
![](/static/2021-10-08-04-30-51.png)

![](/static/2021-10-08-04-31-38.png)

![](/static/2021-10-08-04-32-13.png)
![](/static/2021-10-08-04-32-23.png)

## candidate range searching

如何结合AVL树的使用，加快范围检索

![](/static/2021-10-08-04-34-02.png)

算法分析

![](/static/2021-10-08-04-44-07.png)

* S（candidate集合）
  * s - candidate元素数量
* k - **范围内**，集合S中元素数量
* **本身虽然会对非范围内candidate进行判断，顶多做O(log s)次wasted判断**

## 范围检索Pseudocode

![](/static/2021-10-08-04-35-44.png)
![](/static/2021-10-08-04-39-42.png)

* 利用AVL树，进行candidate的范围过滤

## 线扫描算法- 总结

利用AVL树改进candidate range searching后，线扫描算法如何？

![](/static/2021-10-08-04-47-58.png)

## 线扫描算法 - 分析

![](/static/2021-10-08-04-56-08.png)

