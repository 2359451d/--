# Content

* [Content](#content)
* [最长公共子序列：Longest Common Subsequence](#最长公共子序列longest-common-subsequence)
* [迭代DP：Iterative DP](#迭代dpiterative-dp)
* [Algorithm for Iterative DP](#algorithm-for-iterative-dp)
* [迭代-DP数组例子](#迭代-dp数组例子)
* [迭代-复杂度分析](#迭代-复杂度分析)
* [递归DP-LCS](#递归dp-lcs)
  * [例子](#例子)
* [记忆化搜索-避免重复计算：Avoiding repeated computation](#记忆化搜索-避免重复计算avoiding-repeated-computation)
  * [初始化-1例子：Example of lazy evaluation (an entry -1 indicates non-evaluation)](#初始化-1例子example-of-lazy-evaluation-an-entry--1-indicates-non-evaluation)
* [避免初始化-使用“虚拟初始化” - Avoiding initialisation using “virtual initialisation”](#避免初始化-使用虚拟初始化---avoiding-initialisation-using-virtual-initialisation)
* [===============](#)
* [串局部相似度(最长公共子串?)-Local similarities in strings / texts](#串局部相似度最长公共子串-local-similarities-in-strings--texts)
  * [应用场景：Applications](#应用场景applications)
  * [例子-strong local similarity](#例子-strong-local-similarity)
* [问题具体描述：Towards a problem specification](#问题具体描述towards-a-problem-specification)

# 最长公共子序列：Longest Common Subsequence

![](/static/2021-11-11-20-29-52.png)

* 子序列的字符不需要连续

# 迭代DP：Iterative DP

![](/static/2021-11-12-02-01-06.png)

* 先找到前几个前缀的公共子序列长度
  * Xi, X的前i个字符
  * Yj，Y的前j个字符
  * 注意都从1开始
* 然后通过找到子前缀的公共子序列长度fi,j，延伸到整个X,Y的公共子序列长度fm,n

# Algorithm for Iterative DP

(simple version – just to find LCS length)

* 最简单迭代版本，只求LCS长度

![](/static/2021-11-12-13-56-41.png)

# 迭代-DP数组例子

![](/static/2021-11-12-14-08-34.png)

# 迭代-复杂度分析

![](/static/2021-11-12-14-28-44.png)

* 递归可以优化

# 递归DP-LCS

![](/static/2021-11-12-14-31-52.png)

## 例子

![](/static/2021-11-12-14-43-31.png)

# 记忆化搜索-避免重复计算：Avoiding repeated computation

![](/static/2021-11-12-14-48-18.png)
![](/static/2021-11-12-14-51-45.png)

* 全局数组如果entry=-1，则还没有递归调用计算过。需要计算

## 初始化-1例子：Example of lazy evaluation (an entry -1 indicates non-evaluation)

![](/static/2021-11-12-14-55-29.png)

# 避免初始化-使用“虚拟初始化” - Avoiding initialisation using “virtual initialisation”

![](/static/2021-11-12-15-04-41.png)

怎么区分存储的值是计算后的还是new, malloc分配堆空间时产生的值？

TODO

# ===============

# 串局部相似度(最长公共子串?)-Local similarities in strings / texts

![](/static/2021-11-12-15-33-02.png)

* LCS长度`<min(X.len, Y.len)`所以全局来讲X，Y不相似
* DP求最大局部相似度？

## 应用场景：Applications

![](/static/2021-11-12-15-36-30.png)

## 例子-strong local similarity

![](/static/2021-11-12-15-37-59.png)

# 问题具体描述：Towards a problem specification

![](/static/2021-11-12-15-46-29.png)

