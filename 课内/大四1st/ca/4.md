# Content

* [Content](#content)
* [State Machines](#state-machines)
* [模块：Building blocks](#模块building-blocks)
* [多路选择器 & 多路输出选择器：Multiplexers and demultiplexers](#多路选择器--多路输出选择器multiplexers-and-demultiplexers)
* [字多路复用器 mux1w:Word multiplexer mux1w](#字多路复用器-mux1wword-multiplexer-mux1w)
  * [Word multiplexer mux2w](#word-multiplexer-mux2w)
* [解复用器:Demultiplexer](#解复用器demultiplexer)
  * [2bit demux](#2bit-demux)
* [锁存器和寄存器:Latches and registers](#锁存器和寄存器latches-and-registers)
  * [Latches](#latches)
  * [Registers](#registers)
* [Wiring patterns模块生成](#wiring-patterns模块生成)
* [位相加：Adding bits](#位相加adding-bits)
* [纹波进位加法器:Ripple carry adder](#纹波进位加法器ripple-carry-adder)
* [大小参数：Size parameters](#大小参数size-parameters)
  * [Why are size parameters needed?](#why-are-size-parameters-needed)
* [Summary of Building Block Circuits](#summary-of-building-block-circuits)
* [库导入：Importing libraries](#库导入importing-libraries)
* [==========](#)
* [State Machines](#state-machines-1)
  * [状态机的意义:Significance of state machines](#状态机的意义significance-of-state-machines)
* [例子：Simple example of state machine](#例子simple-example-of-state-machine)
* [状态 & 控制信号：States and control signals](#状态--控制信号states-and-control-signals)
* [控制算法：Control algorithm](#控制算法control-algorithm)
  * [例子](#例子)
* [状态-电路表示：Representing states in a circuit](#状态-电路表示representing-states-in-a-circuit)
* [控制电路设计方法：Delay element method](#控制电路设计方法delay-element-method)
* [状态触发器和转换：State flip flops and transitions](#状态触发器和转换state-flip-flops-and-transitions)
* [Generating the control signals](#generating-the-control-signals)
* [控制算法中结构表示：Control structures in control algorithm](#控制算法中结构表示control-structures-in-control-algorithm)
* [Straight-line control as sequence of dff](#straight-line-control-as-sequence-of-dff)
* [状态机-寄存器：State Machines with registers](#状态机-寄存器state-machines-with-registers)

# State Machines

# 模块：Building blocks

# 多路选择器 & 多路输出选择器：Multiplexers and demultiplexers

![](/static/2021-10-20-02-10-31.png)

* demux
  * c - address input (control)
  * x - data input

# 字多路复用器 mux1w:Word multiplexer mux1w

![](/static/2021-10-20-02-15-16.png)

* 注意输出`[]`字，因为原本输入也是个字，，

## Word multiplexer mux2w

![](/static/2021-10-20-02-17-10.png)

# 解复用器:Demultiplexer

![](/static/2021-10-20-02-42-54.png)

* 注意输出`(,)`，，多输出，且原本输出信号无关

## 2bit demux

![](/static/2021-10-20-02-46-17.png)

# 锁存器和寄存器:Latches and registers

![](/static/2021-10-20-02-52-43.png)

## Latches

![](/static/2021-10-20-02-57-46.png)

## Registers

![](/static/2021-10-20-02-59-46.png)

# Wiring patterns模块生成

![](/static/2021-10-20-03-05-57.png)

* 【bit slice】拼接成一对，，而不是拼接成一个字（区分`++`word拼接操作）

# 位相加：Adding bits

![](/static/2021-10-20-03-13-44.png)

* half adder
* full adder

# 纹波进位加法器:Ripple carry adder

![](/static/2021-10-20-03-19-44.png)

# 大小参数：Size parameters

![](/static/2021-10-20-04-03-38.png)

* size parameter
* circuit parameter
  * signal parameters
  * building block parameters

## Why are size parameters needed?

Circuit generators for combinational circuits measure the size of the input and then generate the right amount of components and wires **[组合电路]的电路生成器测量[输入的大小，然后生成适量的元件和电线]**

What if the generator for a latch or register did this? 如果锁存器或寄存器的生成器这样做了怎么办？

* – There are feedback loops 有反馈回路
* – The compiler would go into an infinite loop, working backwards through the circuit forever, trying to find a component that fixes the word size 编译器将进入一个无限循环，永远在电路中向后工作，试图找到一个固定字长的组件

The rule is 规则是

* – Generators for registers need to be told explicitly the size of their state **寄存器生成器**需要被明确告知其状态的**大小**
* – Generators for combinational circuits can adjust the size automatically **组合电路**发生器可**自动调节**大小

# Summary of Building Block Circuits

![](/static/2021-10-20-04-11-36.png)

Combinational circuits and wiring patterns

* – Feedback loops are not allowed **不允许反馈回路**
* – Circuit generators don't need a size parameter → they measure the size of the input words and generate a circuit of the right size **电路生成器不需要大小参数→它们测量输入字的大小并生成合适大小的电路**

Synchronous circuits (circuits with registers) 同步电路（带寄存器的电路）

* – Feedback loops allowed (through a dff) **允许反馈循环（通过 dff）**
* – Circuit generators take one or more size parameters that determine how many bits the registers will contain **电路生成器采用一个或多个大小参数来确定寄存器将包含多少位**

Circuits at specific sizes: designed directly, where every component is stated explicitly (e.g. dff, reg4, rippleAdd4) **特定大小**的电路：**直接设计**，明确说明每个组件（例如 dff、reg4、rippleAdd4）

Circuits for n-bit words: defined with circuit generators (e.g. reg, rippleAdd) **n 位字**的电路：用**电路生成器**定义（例如 reg、rippleAdd）

# 库导入：Importing libraries

![](/static/2021-10-20-04-16-11.png)

# ==========

# State Machines

![](/static/2021-10-20-04-19-09.png)

## 状态机的意义:Significance of state machines

![](/static/2021-10-20-04-21-35.png)

* Nearly every complex circuit has a state that determines what it will do next 几乎每一个复杂的电路都有一个状态来决定它接下来要做什么

# 例子：Simple example of state machine

![](/static/2021-10-20-04-23-36.png)

# 状态 & 控制信号：States and control signals

In digital circuits, we call the outputs of the state machine control signals 在数字电路中，我们**称状态机输出为控制信号**

* – Each state sets to 1 (asserts) a subset of them **每个状态设置为 1（被断言**）它们的一个子集

![](/static/2021-10-20-04-31-01.png)

# 控制算法：Control algorithm

We can describe the state machine as a control algorithm **我们可以将状态机描述为一种控制算法**

We need a language to define the control algorithm **我们需要一种语言来定义控制算法**

* – At each clock cycle: we are in a state 在每个时钟周期：我们处于一种状态
* – In a state: some of the output control signals are asserted (set to 1) **处于状态：某些输出控制信号被断言（设置为 1**）
* – At clock tick: we move to next state 在时钟时刻时：**我们移动到下一个状态**

![](/static/2021-10-20-04-34-38.png)

## 例子

![](/static/2021-10-20-04-39-12.png)

# 状态-电路表示：Representing states in a circuit

![](/static/2021-10-20-04-40-30.png)

* dff表示每个状态
* 为`1`的dff为当前状态

# 控制电路设计方法：Delay element method

用这个方法设计控制电路，，再由这个控制电路中实现控制算法（即表示状态机）

![](/static/2021-10-20-04-48-07.png)

Connect each flip flop input to the flip flop of the preceding statement (this gives straight-line control) 将每个触发器输入连接到前面语句的触发器（这给出了直线控制） -- 为什么状态机的output也就是control signal?

For a case statement with a k-bit condition, use a demultiplexer to generate `2^k` signals to initiate each of the alternatives 对于具有 k 位条件的 case 语句，使用解复用器生成“2^k”信号以启动每个备选方案（状态）

* 控制算法中，case语句的表示？

A control signal is generated by or-ing together the outputs of the flip flops for the states where that signal is asserted **控制信号是通过将【触发器的输出】进行【或运算】来生成该信号被置位的状态（设为1**）

# 状态触发器和转换：State flip flops and transitions

![](/static/2021-10-20-04-57-56.png)

# Generating the control signals

![](/static/2021-10-20-05-00-36.png)

* week3

Each control signal is generated by calculating the logical or of the states where it is asserted **每个控制信号是通过计算其被断言的状态的【逻辑或】来生成的**

![](/static/2021-10-20-05-03-09.png)

# 控制算法中结构表示：Control structures in control algorithm

![](/static/2021-10-20-05-12-31.png)

# Straight-line control as sequence of dff

![](/static/2021-10-20-05-36-17.png)

# 状态机-寄存器：State Machines with registers

![](/static/2021-10-20-05-38-05.png)

* Sometimes part of the state is best represented as a register, e.g. a counter **有时状态的一部分最好表示为寄存器，例如计数器**
