# Content

* [Content](#content)
* [门延时&组合电路时间行为：Gate Delay & Time Behaviour of Combinational Circuits](#门延时组合电路时间行为gate-delay--time-behaviour-of-combinational-circuits)
* [无效/有效信号：Validity of Signals](#无效有效信号validity-of-signals)
* [路径深度：Path Depth](#路径深度path-depth)
* [关键路径：Critical path](#关键路径critical-path)
* [冒险/险象：Hazards](#冒险险象hazards)
* [Question](#question)
* [=========](#)
* [时序电路：Sequential Circuits](#时序电路sequential-circuits)
* [延时触发器：The delay flip flop (dff)](#延时触发器the-delay-flip-flop-dff)
  * [初始状态：Initialisation](#初始状态initialisation)
* [时钟：Clock](#时钟clock)
  * [物理 & 抽象时钟：Physical and abstract clock](#物理--抽象时钟physical-and-abstract-clock)
* [=========](#-1)
* [同步电路：Synchronous Circuits](#同步电路synchronous-circuits)
* [同步模型的好处：Benefits of the synchronous model](#同步模型的好处benefits-of-the-synchronous-model)
* [时钟-非显式输入：Clock is an implicit input](#时钟-非显式输入clock-is-an-implicit-input)
* [时钟偏移：Clock Skew](#时钟偏移clock-skew)
* [1-bit寄存器 register](#1-bit寄存器-register)
* [如何设计1-bit reg？Designing the 1-bit register](#如何设计1-bit-regdesigning-the-1-bit-register)
  * [Implementation of the 1-bit register](#implementation-of-the-1-bit-register)
* [如何模拟同步电路：Simulating a synchronous circuit](#如何模拟同步电路simulating-a-synchronous-circuit)
* [模拟例子](#模拟例子)
* [Summary: Combinational vs Synchronous](#summary-combinational-vs-synchronous)
* [如何选择组合\时序电路：When to use combinational or sequential](#如何选择组合时序电路when-to-use-combinational-or-sequential)
* [Synchronous circuits: high level view](#synchronous-circuits-high-level-view)
* [时钟相关Term：More terminology about the clock](#时钟相关termmore-terminology-about-the-clock)
* [每个时钟周期-dff：What each flip flop does during a cycle?](#每个时钟周期-dffwhat-each-flip-flop-does-during-a-cycle)
* [逻辑门连续运行：Logic gates operate continuously](#逻辑门连续运行logic-gates-operate-continuously)
* [Safety Factor](#safety-factor)
* [What you'll see in watching a running circuit](#what-youll-see-in-watching-a-running-circuit)
* [同步电路时钟总结：Timing in synchronous circuits: summary](#同步电路时钟总结timing-in-synchronous-circuits-summary)
* [同步电路设计原则：Design principles for synchronous circuits](#同步电路设计原则design-principles-for-synchronous-circuits)
* [利用模块：Reuse building block circuits](#利用模块reuse-building-block-circuits)
* [=========](#-2)
* [1-bit register](#1-bit-register)
* [4-bit word register](#4-bit-word-register)
* [双向移位寄存器：A bidirectional shift register](#双向移位寄存器a-bidirectional-shift-register)
  * [输入输出：Inputs and outputs of the circuit](#输入输出inputs-and-outputs-of-the-circuit)
  * [Hydra表示：Hydra interface to the bidirectional shift register](#hydra表示hydra-interface-to-the-bidirectional-shift-register)
  * [设计策略：Design strategy](#设计策略design-strategy)
  * [srb模块设计：A building block for the shift register (srb)](#srb模块设计a-building-block-for-the-shift-register-srb)

# 门延时&组合电路时间行为：Gate Delay & Time Behaviour of Combinational Circuits

逻辑门组件存在时间行为（门延迟）

![](/static/2021-10-08-22-02-52.png)

---

![](/static/2021-10-08-22-04-24.png)

* t0 + d (where d is a given gate delay)

# 无效/有效信号：Validity of Signals

![](/static/2021-10-08-22-07-13.png)

* 无效 - 不可靠，但不一定是错的

# 路径深度：Path Depth

![](/static/2021-10-08-22-10-07.png)

* path depth决定了电路的速度
  * 限制电路速度的基本元素 - fundamental limitation

# 关键路径：Critical path 

> 关键路径通常是**指同步逻辑电路中，组合逻辑时延最大的路径**（这里我认为还需要加上布线的延迟），也就是说关键路径是对设计性能起决定性影响的时序路径。
>
> 对关键路径进行时序优化，可以直接提高设计性能。对同步逻辑来说，常用的时序优化方法包括Pipeline、**Retiming**、逻辑复制、加法/乘法树、关键信号后移、消除优先级等解决。

![](/static/2021-10-08-22-13-27.png)

* 最长路径？（最大深度）
* **决定电路(时钟)速度**。必须等待所有输出有效。
* **在组合电路中，门延迟最长的路径是关键路径；这条路径需要比其他所有路径更多的时间，以便稳定到一个有效的信号值**。The path with the longest gate delay in a combinational circuit is the critical path; this path requires more time than all others in order to settle down to a valid signal value. 
* 时序电路中的时钟需要运行得足够慢，以便关键路径有时间安顿下来。The clock in a sequential circuit needs to run slowly enough so that the critical path has time to settle down. 
* 时钟速度不受关键路径以外的任何路径的影响；**因此，加快时钟速度的方法是减少关键路径的延迟**。The clock speed is unaffected by any path other than the critical path; thus the way to speed up the clock is to reduce the delay on the critical path.
  * = =。。后面流水线好像讲了重定时减少关键路径，然后增加流水线深度都可以提高频率，但是不是越深越好，有点偏

# 冒险/险象：Hazards

![](/static/2021-10-08-22-19-57.png)
![](/static/2021-10-08-22-21-40.png)

* 输入在不同时刻stable时，出现临时错误输出（毛刺glitch)

# Question

![](/static/2021-10-08-22-23-56.png)

In Boolean algebra, this is equivalent to 0 = 1 which is a well formed statement that is untrue. In the real circuit, there are two metastable modes the output can take: (1) it can oscillate between 0 and 1; and (2) it can remain stuck at a voltage midway between 0 and 1. Both of those modes are unstable, and eventually the circuit will flip to the other one. Thus it drifts at 0.5, then oscillates, then drifts, then oscillates, . . .. The time when it flips from one mode to the other is unpredictable, but the probability of flipping after an interval of time is known. Thus the circuit has a half life. It is important to note that this is not a digital circuit at all; it is analogue 在布尔代数中，这等价于 0 = 1，这是一个不正确的格式正确的陈述。在实际电路中，输出可以采取两种亚稳态模式：（1）它可以在 0 和 1 之间振荡； (2) 它可以保持在 0 和 1 之间的中间电压。这两种模式都不稳定，最终电路将翻转到另一种模式。因此它在 0.5 处漂移，然后振荡，然后漂移，然后振荡，。 . ..**它从一种模式翻转到另一种模式的时间是不可预测的，但一段时间后翻转的概率是已知的**。因此电路有半衰期。需要注意的是，**这根本不是数字电路；它是模拟的**

# =========

# 时序电路：Sequential Circuits

![](/static/2021-10-08-22-26-37.png)

# 延时触发器：The delay flip flop (dff)

![](/static/2021-10-08-22-30-09.png)

## 初始状态：Initialisation

![](/static/2021-10-08-22-31-36.png)

* When power is applied to the system, it needs to be ensured that every flip flop is in some valid state, either 0 or 1 当系统上电时，需要确保每个触发器都处于某种有效状态，0 或 1
  * It's convenient to assume that the value of the initial state is 0 假设初始状态的值为 0 很方便
* Real systems: a reset signal forces all flip flops into a valid initial state 真实系统：复位信号强制所有触发器进入有效的初始状态

# 时钟：Clock

![](/static/2021-10-08-23-05-31.png)

The dff component saves its input value into its state at specific points in time, determined by a clock signal dff 组件将其输入值保存到特定时间点的状态中，由时钟信号确定这个时间点

只要有时钟信号，就更新状态为input。连续输出output

The clock signal is generated externally by a circuit that produces a fast and steady sequence of clock ticks 时钟信号由电路在外部产生，该电路产生快速而稳定的时钟序列

A clock tick is a point in time **时钟信号是一个时间点**

A clock cycle is the time interval between two consecutive clock ticks **一个时钟周期是两个连续时钟信号之间的时间间隔**

## 物理 & 抽象时钟：Physical and abstract clock

![](/static/2021-10-08-23-11-45.png)

This clock cannot be built electronically, but the same effect can be obtained with a square wave clock 这个时钟不能用电子方式建造，但用方波时钟可以获得相同的效果

# =========

# 同步电路：Synchronous Circuits

![](/static/2021-10-08-23-14-24.png)

---

定义 & 特性

Contains: logic gates and flip flops (later extended to VLSI components) **包含：逻辑门和触发器（后来扩展到 VLSI 组件**）

Unique global clock: every flip flop is connected directly to it **唯一全局时钟：每个触发器都直接与其相连**

* No logic functions may be performed on the clock signal **不能对时钟信号执行逻辑功能**
  * 如果一个电路在时钟信号上进行**逻辑运算**，那么该触发器将比其他触发器晚收到它的滴答声，而且有可能在下一个周期中来自另一个触发器的信号会在时钟门控触发器收到滴答声之前影响它。这将使整个系统无法作为一个状态机运行 If a circuit performs logic on the clock signal then the flip flop will receive its tick later than other flip flops, and it is possible that a signal from another flip flop in the next cycle will affect the clock-gated flip flop before it receives its tick.  This will prevent the entire system from acting as a state machine.

Every clock tick: reaches each flip flop simultaneously **每个时钟时刻：同时到达每个触发器**

* A little bit of variation is ok, but not much 有一点变化是可以的，但不会太大

Feedback loops: pass through a flip flop **反馈回路应该：通过触发器**

* No feedback in pure combinational logic 纯组合逻辑(组合电路）中没有反馈
* 同步电路在组合逻辑中没有反馈回路；每个触发器都由相同的时钟控制，它们都在（几乎）同一时间接收滴答声，而且时钟运行得足够慢，以便所有组合逻辑信号在下一个时钟滴答声之前有时间沉淀。这些限制确保了整个系统表现为一个状态机，其状态包括一组触发器的状态。A synchronous circuit has no feedback loop in combinational logic; every flip flop is controlled by the same clock, and they all receive ticks at (almost) the same time, and the clock runs slowly enough so that all combinational logic signals have time to settle before the next clock tick. These restrictions ensure that the entire system behaves as one state machine, whose state comprises the set of flip flop states.

Inputs to the circuit: assumed to remain stable during an entire clock cycle **电路输入：假设在整个时钟周期内保持稳定**

* The circuit may malfunction if any of its inputs does not remain stable 如果任何输入不稳定，电路可能会发生故障
* **如果时钟运行速度过快，一些触发器在时钟跳动时出现无效输入的概率就会增加，这将导致系统发生故障**。 If the clock is running too fast, there is an increased probability that some flip flops will have invalid inputs when the clock ticks, which would cause the system to malfunction.

# 同步模型的好处：Benefits of the synchronous model

Single global state: comprising the states of all flip flops in the circuit **单一全局状态：包括电路中所有触发器的状态**

* – The entire circuit behaves as a single finite state machine 整个电路表现为一个单一的有限状态机

You can understand the behaviour of the circuit with a simulation table that shows, for each clock cycle, the state value of each flip flop **您可以通过模拟表了解电路的行为，该表显示每个时钟周期的每个触发器的状态值**

Not necessary to consider intermediate signal values in combinational logic **无需考虑组合电路逻辑中的中间信号值**

* – Only the final signal values (input to a dff, outputs of circuit) are relevant 只有**最终的信号值**（dff 的输入，电路的输出）是相关的

The temporary changing signal values (due to gate delays) can be ignored **可以忽略临时变化的信号值（由于门延迟）**

* Hazards can be ignored 可以忽略险象

# 时钟-非显式输入：Clock is an implicit input

![](/static/2021-10-08-23-25-36.png)

* dff只有一个data Input
  * 而时钟信号不是data input
* Every flip flop and logic gate is also connected to two power supply lines 每个触发器和逻辑门也连接到两条电源线

In Hydra, we will specify the logic signals explicitly, but the clock and power are not written explicitly **在Hydra中，我们会明确指定逻辑信号，但没有明确写出时钟和电源**

# 时钟偏移：Clock Skew

![](/static/2021-10-08-23-27-27.png)

* **时钟信号可能不会同时到达所有dff**
  * 比如由时钟电线长度差异造成的
* 如何解决？
  * each clock tick is buffered, the same number of buffers appear on the path to each flip flop, and each path is approximately the same length 每个时钟信号都被缓冲，每个触发器的路径上出现相同数量的缓冲区，并且每个路径的长度大致相同
  * One way to achieve this is by an H-tree layout 实现此目的的一种方法是通过 H 树布局

# 1-bit寄存器 register

![](/static/2021-10-08-23-36-34.png)

# 如何设计1-bit reg？Designing the 1-bit register

![](/static/2021-10-08-23-39-25.png)

## Implementation of the 1-bit register

![](/static/2021-10-08-23-43-35.png)

# 如何模拟同步电路：Simulating a synchronous circuit

![](/static/2021-10-08-23-47-50.png)

Simulate the current clock cycle: write in the input value, then calculate the internal signals until every cell in the current row if filled in (this is the combinational logic settling down) 模拟当前时钟周期：写入输入值，然后计算内部信号，直到当前行中的每个单元格都被填满（这是组合逻辑稳定下来）

Simulate the clock tick: fill in the flip flop states for the next row down 模拟时钟信号：为下一行填充触发器状态

仿真是通过构建一个表格来完成的，每一个时钟周期有一行，每一个触发器状态和信号值有一列。在每个时钟周期，最后一行的触发器的输入信号被复制到新一行的触发器状态，然后通过组合仿真计算信号。**如果电路不是同步的，全局状态就不能由触发器状态和信号状态来概括，所以所有的信号都必须作为连续的函数来计算**。 Simulation is done by constructing a table, with a row for each clock cycle, and a column for each flip flop state and signal value. At each clock tick, the input signal to a flip flop in the last row is copied to the flip flop state for the new row, and the signals are then calculated by combinational simulation. If the circuit is not synchronous, the global state cannot be summarised by the flip flop states and signal states, so all the signals have to be worked out as continuous functions over time.

# 模拟例子

![](/static/2021-10-08-23-52-24.png)
![](/static/2021-10-08-23-56-09.png)

# Summary: Combinational vs Synchronous

Combinational circuit 组合电路

* – Structure: contains only logic gates, no flip flops or feedback 结构：仅包含逻辑门，没有触发器或反馈
* – Behaviour: has no state, after the inputs settle down the outputs also settle down after a delay 行为：没有状态，在输入稳定后，输出也在延迟后稳定

Sequential circuit 时序电路

* – Structure: may contain flip flops and/or feedback结构：可能包含触发器和/或反馈 
* – Behaviour: has a state, which may change continuously 行为：有一个状态，可能会不断变化

Synchronous circuit 同步电路

* Structure: (1) Every feedback loop goes through a flip flop; (2) all flip flops controlled by the same clock signal 结构： (1) 每个反馈回路都经过一个触发器； (2) 所有触发器都由同一个时钟信号控制
* Behaviour: a sequence of global states (consisting of the states of all the flip flops) may change at each clock tick 行为：一系列全局状态（由所有触发器的状态组成）可能会在每个时钟滴答处发生变化

# 如何选择组合\时序电路：When to use combinational or sequential

Use a combinational circuit

* – Mathematical functions (as long as they aren't too complicated) algebra 数学函数（只要不是太复杂）代数
* – Computations that can be performed within one clock cycle 可以在一个时钟周期内执行的计算

Use a sequential circuit

* – For algorithms that require iteration – 对于需要迭代的算法
* – For functions that would require too much time for one clock cycle 对于一个时钟周期需要太多时间的功能

# Synchronous circuits: high level view

![](/static/2021-10-09-00-41-30.png)

# 时钟相关Term：More terminology about the clock

![](/static/2021-10-09-00-42-57.png)

# 每个时钟周期-dff：What each flip flop does during a cycle?

![](/static/2021-10-09-00-44-56.png)

# 逻辑门连续运行：Logic gates operate continuously

![](/static/2021-10-09-00-51-05.png)

* 无时钟控制，
* 输入改变时，延时后输出有效

# Safety Factor

![](/static/2021-10-09-00-54-27.png)
![](/static/2021-10-09-00-54-34.png)

以下适用于任意path depth

![](/static/2021-10-09-00-56-28.png)

# What you'll see in watching a running circuit

![](/static/2021-10-09-01-06-25.png)

# 同步电路时钟总结：Timing in synchronous circuits: summary

![](/static/2021-10-09-01-09-09.png)

* 时钟周期内input constant - 这种电路为synchronisers

# 同步电路设计原则：Design principles for synchronous circuits

![](/static/2021-10-09-01-13-35.png)

# 利用模块：Reuse building block circuits

![](/static/2021-10-09-01-16-22.png)

# =========

# 1-bit register

![](/static/2021-10-09-01-18-17.png)

The lecture slides show the beginning of such a simulation. You really need to work this out for yourself. What counts is the process of doing it, not the result!

# 4-bit word register

![](/static/2021-10-09-01-19-31.png)

# 双向移位寄存器：A bidirectional shift register

![](/static/2021-10-09-01-22-48.png)
![](/static/2021-10-09-01-24-42.png)

* 考虑如何结合组合电路 & dff

## 输入输出：Inputs and outputs of the circuit

![](/static/2021-10-09-01-35-14.png)

## Hydra表示：Hydra interface to the bidirectional shift register

![](/static/2021-10-09-01-40-59.png)

## 设计策略：Design strategy

由小模块建起

![](/static/2021-10-09-01-44-01.png)

## srb模块设计：A building block for the shift register (srb)

![](/static/2021-10-09-01-48-49.png)
![](/static/2021-10-09-01-56-30.png)
![](/static/2021-10-09-02-59-15.png)

* 注意每个srb模块，
  * 右移时输出left input
  * 左移时输出right input
  * 整体应该li和ri得想办法连着最后一个srb和第一个srb?

