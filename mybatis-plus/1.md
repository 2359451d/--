# Content

* [Content](#content)
* [特性](#特性)
* [架构](#架构)
* [创建数据库 & 表](#创建数据库--表)
* [依赖](#依赖)
* [Mybatis + MP](#mybatis--mp)
  * [Mybatis实现查询User](#mybatis实现查询user)
  * [Mybatis+MP实现查询User](#mybatismp实现查询user)
* [Spring + Mybatis + MP](#spring--mybatis--mp)
* [SpringBoot + Mybatis + MP](#springboot--mybatis--mp)
* [BaseMapper通用CRUD](#basemapper通用crud)
* [Insert](#insert)
  * [insert](#insert-1)
  * [@TableId - 如何设置id的生成策略呢？](#tableid---如何设置id的生成策略呢)
  * [@TableField](#tablefield)
* [Update](#update)
  * [updateById](#updatebyid)
  * [update](#update-1)
* [Delete](#delete)
  * [deleteById](#deletebyid)
  * [deleteByMap](#deletebymap)
  * [delete](#delete-1)
  * [deleteBatchIds](#deletebatchids)
* [Select](#select)
  * [selectById](#selectbyid)
  * [selectBatchIds](#selectbatchids)
  * [selectOne](#selectone)
  * [selectCount](#selectcount)
  * [selectList](#selectlist)
  * [selectPage](#selectpage)
* [SQL注入的原理](#sql注入的原理)
* [MB基本配置](#mb基本配置)
  * [configLocation](#configlocation)
  * [mapperLocations](#mapperlocations)
  * [typeAliasesPackage](#typealiasespackage)
* [进阶配置](#进阶配置)
  * [mapUnderscoreToCamelCase](#mapunderscoretocamelcase)
  * [cacheEnabled](#cacheenabled)
* [DB 策略配置](#db-策略配置)
  * [idType](#idtype)
  * [tablePrefix](#tableprefix)
* [Wrapper：条件构造器](#wrapper条件构造器)
  * [allEq](#alleq)
  * [基本比较操作](#基本比较操作)
  * [模糊查询](#模糊查询)
  * [排序](#排序)
  * [逻辑查询](#逻辑查询)
  * [select](#select-1)
* [ActiveRecord](#activerecord)
  * [开启AR](#开启ar)
  * [ID查询](#id查询)
  * [新增数据](#新增数据)
  * [更新操作](#更新操作)
  * [删除操作](#删除操作)
  * [根据条件查询](#根据条件查询)
* [Oracle 主键Sequence](#oracle-主键sequence)
* [插件](#插件)
  * [mybatis的插件机制](#mybatis的插件机制)
  * [拦截器示例：](#拦截器示例)
  * [执行分析插件](#执行分析插件)
  * [性能分析插件](#性能分析插件)
  * [乐观锁插件](#乐观锁插件)
    * [特别说明](#特别说明)
* [Sql 注入器](#sql-注入器)

# 特性

![](/static/2021-09-06-12-27-39.png)

# 架构

![](/static/2021-09-06-12-29-14.png)

对于Mybatis整合MP有常常有三种用法，分别是Mybatis+MP、Spring+Mybatis+MP、Spring Boot+Mybatis+MP。

# 创建数据库 & 表

![](/static/2021-09-06-12-39-23.png)
![](/static/2021-09-06-12-39-34.png)

# 依赖

导入依赖

```xml
<dependencies>
<!-- mybatis-plus插件依赖 -->
<dependency>
<groupId>com.baomidou</groupId>
<artifactId>mybatis-plus</artifactId>
<version>3.1.1</version>
</dependency>
<!-- MySql -->
<dependency>
<groupId>mysql</groupId>
<artifactId>mysql-connector-java</artifactId>
<version>5.1.47</version>
</dependency>
<!-- 连接池 -->
<dependency>
<groupId>com.alibaba</groupId>
<artifactId>druid</artifactId>
<version>1.0.11</version>
</dependency>
<!--简化bean代码的工具包-->
<dependency>
<groupId>org.projectlombok</groupId>
<artifactId>lombok</artifactId>
<optional>true</optional>
<version>1.18.4</version>
</dependency>
<dependency>
<groupId>junit</groupId>
<artifactId>junit</artifactId>
<version>4.12</version>
</dependency>
<dependency>
<groupId>org.slf4j</groupId>
<artifactId>slf4j-log4j12</artifactId>
<version>1.6.4</version>
</dependency>
</dependencies>
```

# Mybatis + MP

创建子模块

![](/static/2021-09-06-12-44-34.png)
![](/static/2021-09-06-13-00-14.png)

## Mybatis实现查询User

全局配置

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
<environments default="development">
<environment id="development">
<transactionManager type="JDBC"/>
<dataSource type="POOLED">
<property name="driver" value="com.mysql.jdbc.Driver"/>
<property name="url" value="jdbc:mysql://127.0.0.1:3306/mp?
useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQuerie
s=true&amp;useSSL=false"/>
<property name="username" value="root"/>
<property name="password" value="root"/>
</dataSource>
</environment>
</environments>
<!-- 映射文件 -->
<mappers>
<mapper resource="UserMapper.xml"/>
</mappers>
</configuration>
```

第二步，编写User实体对象：（这里使用lombok进行了进化bean操作）

* ![](/static/2021-09-06-13-03-01.png)
* 帮忙生成一系列getter & setter方法

```java
package cn.itcast.mp.simple.pojo;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Long id;
    private String userName;
    private String password;
    private String name;
    private Integer age;
    private String email;
}

```

第三步，编写UserMapper接口（DAO）：

```java
package cn.itcast.mp.simple.mapper;
import cn.itcast.mp.simple.pojo.User;
import java.util.List;
public interface UserMapper {
    List<User> findAll();
}
```

第四步，编写UserMapper.xml文件：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.itcast.mp.simple.mapper.UserMapper">
    <select id="findAll" resultType="cn.itcast.mp.simple.pojo.User">
    select * from tb_user
    </select>
</mapper>
```

第五步，编写TestMybatis测试用例：

```java
package cn.itcast.mp.simple;
import cn.itcast.mp.simple.mapper.UserMapper;
import cn.itcast.mp.simple.pojo.User;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;
import java.io.InputStream;
import java.util.List;
public class TestMybatis {
    @Test
    public void testUserList() throws Exception{
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new
        SqlSessionFactoryBuilder().build(inputStream);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        List<User> list = userMapper.findAll();
        for (User user : list) {
            System.out.println(user);
            }
        }
}
```

![](/static/2021-09-06-13-06-56.png)

## Mybatis+MP实现查询User

第一步，将UserMapper**继承BaseMapper**，将拥有了BaseMapper中的所有方法

* ![](/static/2021-09-06-13-10-01.png)
* ![](/static/2021-09-06-13-10-25.png)

```java
package cn.itcast.mp.simple.mapper;
import cn.itcast.mp.simple.pojo.User;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import java.util.List;
public interface UserMapper extends BaseMapper<User> {
    List<User> findAll();
}
```

第二步，**使用MP中的MybatisSqlSessionFactoryBuilder**进程构建：

* 由于使用了MybatisSqlSessionFactoryBuilder进行了构建，继承的BaseMapper中的方法就载入到了 SqlSession中，所以就可以直接使用相关的方法；

```java
public class TestMybatisPlus {
    @Test
    public void testUserList() throws Exception{
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        //这里使用的是MP中的MybatisSqlSessionFactoryBuilder
        SqlSessionFactory sqlSessionFactory = new
        MybatisSqlSessionFactoryBuilder().build(inputStream);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        // 可以调用BaseMapper中定义的方法
        List<User> list = userMapper.selectList(null);
        for (User user : list) {
            System.out.println(user);
        }
}
```

运行报错：

![](/static/2021-09-06-13-12-26.png)

* 解决：在User对象中添加`@TableName`，指定数据库表名
* ![](/static/2021-09-06-13-12-38.png)
* ![](/static/2021-09-06-13-12-50.png)

# Spring + Mybatis + MP

引入了Spring框架，数据源、构建等工作就交给了Spring管理。

---

创建子模块

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd">
<parent>
<artifactId>itcast-mybatis-plus</artifactId>
<groupId>cn.itcast.mp</groupId>
<version>1.0-SNAPSHOT</version>
</parent>
<modelVersion>4.0.0</modelVersion>
<artifactId>itcast-mybatis-plus-spring</artifactId>
<properties>
<spring.version>5.1.6.RELEASE</spring.version>
</properties>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd">
<parent>
<artifactId>itcast-mybatis-plus</artifactId>
<groupId>cn.itcast.mp</groupId>
<version>1.0-SNAPSHOT</version>
</parent>
<modelVersion>4.0.0</modelVersion>
<artifactId>itcast-mybatis-plus-spring</artifactId>
<properties>
<spring.version>5.1.6.RELEASE</spring.version>
</properties>
```

实现查询User

第一步，编写jdbc.properties

```properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/mp?
useUnicode=true&characterEncoding=utf8&autoReconnect=true&allowMultiQueries=true&useSSL
=false
jdbc.username=root
jdbc.password=root
```

第二步，编写applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd">

<context:property-placeholder location="classpath:*.properties"/>
<!-- 定义数据源 -->
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
destroy-method="close">
<property name="url" value="${jdbc.url}"/>
<property name="username" value="${jdbc.username}"/>
<property name="password" value="${jdbc.password}"/>
<property name="driverClassName" value="${jdbc.driver}"/>
<property name="maxActive" value="10"/>
<property name="minIdle" value="5"/>
</bean>

<!--这里使用MP提供的sqlSessionFactory，完成了Spring与MP的整合-->
<bean id="sqlSessionFactory"
class="com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean">
<property name="dataSource" ref="dataSource"/>
</bean>

<!--扫描mapper接口，使用的依然是Mybatis原生的扫描器-->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
<property name="basePackage" value="cn.itcast.mp.simple.mapper"/>
</bean>
</beans>
```

第三步，编写User对象以及UserMapper接口（DAO）：

```java
package cn.itcast.mp.simple.pojo;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@NoArgsConstructor
@AllArgsConstructor
@TableName("tb_user")
public class User {
    private Long id;
    private String userName;
    private String password;
    private String name;
    private Integer age;
    private String email;
}
```

```java
package cn.itcast.mp.simple.mapper;
import cn.itcast.mp.simple.pojo.User;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
public interface UserMapper extends BaseMapper<User> {

}
```

测试

* ![](/static/2021-09-06-16-06-25.png)

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext.xml")
public class TestSpringMP {
@Autowired
private UserMapper userMapper;
@Test
public void testSelectList(){
    List<User> users = this.userMapper.selectList(null);
    for (User user : users) {
        System.out.println(user);
    }
}
}
```

# SpringBoot + Mybatis + MP

使用SpringBoot将进一步的简化MP的整合，需要注意的是，**由于使用SpringBoot需要继承parent，所以需要重新创建工程，并不是创建子Module**

![](/static/2021-09-06-16-08-34.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<parent>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-parent</artifactId>
<version>2.1.4.RELEASE</version>
</parent>
<groupId>cn.itcast.mp</groupId>
<artifactId>itcast-mp-springboot</artifactId>
<version>1.0-SNAPSHOT</version>
<dependencies>
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter</artifactId>
<exclusions>
<exclusion>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-logging</artifactId>
</exclusion>
</exclusions>
</dependency>
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-test</artifactId>
<scope>test</scope>
</dependency>
<!--简化代码的工具包-->
<dependency>
<groupId>org.projectlombok</groupId>
<artifactId>lombok</artifactId>
<optional>true</optional>
</dependency>
<!--mybatis-plus的springboot支持-->
<dependency>
<groupId>com.baomidou</groupId>
<artifactId>mybatis-plus-boot-starter</artifactId>
<version>3.1.1</version>
</dependency>
<!--mysql驱动-->
<dependency>
<groupId>mysql</groupId>
<artifactId>mysql-connector-java</artifactId>
<version>5.1.47</version>
</dependency>
<dependency>
<groupId>org.slf4j</groupId>
<artifactId>slf4j-log4j12</artifactId>
</dependency>
</dependencies>
<build>
<plugins>
<plugin>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
</plugins>
</build>
</project>
```

log4j.properties：

```properties
log4j.rootLogger=DEBUG,A1
log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n
```

编写application.properties

```properties
spring.application.name = itcast-mp-springboot
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/mp?
useUnicode=true&characterEncoding=utf8&autoReconnect=true&allowMultiQueries=true&useSSL
=false
spring.datasource.username=root
spring.datasource.password=root
```

编写pojo

```java
package cn.itcast.mp.pojo;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@NoArgsConstructor
@AllArgsConstructor
@TableName("tb_user")
public class User {
    private Long id;
    private String userName;
    private String password;
    private String name;
    private Integer age;
    private String email;
}
```

编写mapper

```java
package cn.itcast.mp.mapper;
import cn.itcast.mp.pojo.User;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
public interface UserMapper extends BaseMapper<User> {
}
```

编写启动类

```java
package cn.itcast.mp;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.WebApplicationType;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.builder.SpringApplicationBuilder;
@MapperScan("cn.itcast.mp.mapper") //设置mapper接口的扫描包
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

编写测试用例

* ![](/static/2021-09-06-16-11-53.png)

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
@Autowired
private UserMapper userMapper;
@Test
public void testSelect() {
    List<User> userList = userMapper.selectList(null);
    for (User user : userList) {
        System.out.println(user);
    }
}
}
```

# BaseMapper通用CRUD

通过前面的学习，我们了解到通过继承BaseMapper就可以获取到各种各样的单表操作，接下来我们将详细讲解这些
操作

![](/static/2021-09-06-16-13-45.png)

# Insert

## insert

```java
/**
* 插入一条记录
*
* @param entity 实体对象
*/
int insert(T entity);
```

![](/static/2021-09-06-16-14-56.png)
![](/static/2021-09-06-16-15-04.png)
![](/static/2021-09-06-16-15-39.png)

![](/static/2021-09-06-18-07-04.png)

* 指定id为自增长

## @TableId - 如何设置id的生成策略呢？

MP支持的id策略：

* `@TableId()`
  * 传入id策略 `IdType`枚举
  * 默认`IdType.None`
* ![](/static/2021-09-06-16-20-03.png)
* ![](/static/2021-09-06-16-20-11.png)

## @TableField

在MP中通过@TableField注解可以指定字段的一些属性，常常解决的问题有2个：

1、对象中的属性名和字段名不一致的问题（非驼峰）

* `A_COLUMN` & `aColumn`

![](/static/2021-09-06-18-09-21.png)
![](/static/2021-09-06-18-09-36.png)

* 此时无法映射，需要使用`@TableField`
* ![](/static/2021-09-06-18-10-08.png)

2、对象中的属性字段在表中不存在的问题

![](/static/2021-09-06-18-09-21.png)
![](/static/2021-09-06-18-11-30.png)

3. 不希望某字段被查询

![](/static/2021-09-06-18-12-24.png)
![](/static/2021-09-06-18-13-01.png)

# Update

## updateById

根据id更新

```java
/**
* 根据 ID 修改
*
* @param entity 实体对象
*/
int updateById(@Param(Constants.ENTITY) T entity);
```

![](/static/2021-09-06-18-14-29.png)
![](/static/2021-09-06-18-14-40.png)
![](/static/2021-09-06-18-14-47.png)

## update

根据条件更新

```java
/**
* 根据 whereEntity 条件，更新记录
*
* @param entity 实体对象 (set 条件值,可以为 null)
* @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）
*/
int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper<T>
updateWrapper);
```

`QueryWrapper`

![](/static/2021-09-06-18-15-26.png)
![](/static/2021-09-06-18-15-38.png)

或者，通过`UpdateWrapper`进行更新：

![](/static/2021-09-06-18-16-04.png)

# Delete

## deleteById

根据 ID 删除

```java
/**
* 根据 ID 删除
*
* @param id 主键ID
*/
int deleteById(Serializable id);
```

![](/static/2021-09-06-18-20-58.png)

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
    @Autowired
    private UserMapper userMapper;
    @Test
    public void testDeleteById() {
        //执行删除操作
        int result = this.userMapper.deleteById(6L);
        System.out.println("result = " + result);
    }
}
```

## deleteByMap

//将columnMap中的元素设置为删除的条件，多个之间为and关系

```java
/**
* 根据 columnMap 条件，删除记录
*
* @param columnMap 表字段 map 对象
*/
int deleteByMap(@Param(Constants.COLUMN_MAP) Map<String, Object> columnMap);
```

![](/static/2021-09-06-18-22-29.png)

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
    @Autowired
    private UserMapper userMapper;
    @Test
    public void testDeleteByMap() {
        Map<String, Object> columnMap = new HashMap<>();
        columnMap.put("age",20);
        columnMap.put("name","张三");
        //将columnMap中的元素设置为删除的条件，多个之间为and关系
        int result = this.userMapper.deleteByMap(columnMap);
        System.out.println("result = " + result);
    }
}
```

## delete

```java
/**
* 根据 entity 条件，删除记录
*
* @param wrapper 实体对象封装操作类（可以为 null）
*/
int delete(@Param(Constants.WRAPPER) Wrapper<T> wrapper);
```

`QueryWrapper`

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
    @Autowired
    private UserMapper userMapper;
    @Test
    public void testDeleteByMap() {
        User user = new User();
        user.setAge(20);
        user.setName("张三");
        // 用法一：
        // QueryWrapper<User> wrapper = new QueryWrapper<>();
        // wrapper.eq("user_name","caocao1")
        //.eq("password","123456");

        //用法二【推荐】：将实体对象进行包装，包装为操作条件
        QueryWrapper<User> wrapper = new QueryWrapper<>(user);
        int result = this.userMapper.delete(wrapper);
        System.out.println("result = " + result);
    }
}
```

## deleteBatchIds

```java
/**
* 删除（根据ID 批量删除）
*
* @param idList 主键ID列表(不能为 null 以及 empty)
*/
int deleteBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable>
idList);
```

![](/static/2021-09-06-18-30-42.png)

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
    @Autowired
    private UserMapper userMapper;
    @Test
    public void testDeleteByMap() {
        //根据id集合批量删除
        int result = this.userMapper.deleteBatchIds(Arrays.asList(1L,10L,20L));
        System.out.println("result = " + result);
    }
}
```

# Select

## selectById

```java
/**
* 根据 ID 查询
*
* @param id 主键ID
*/
T selectById(Serializable id);
```

![](/static/2021-09-06-18-33-05.png)

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
    @Autowired
    private UserMapper userMapper;
    @Test
    public void testSelectById() {
        //根据id查询数据
        User user = this.userMapper.selectById(2L);
        System.out.println("result = " + user);
    }
}
```

## selectBatchIds

```java
/**
* 查询（根据ID 批量查询）
*
* @param idList 主键ID列表(不能为 null 以及 empty)
*/
List<T> selectBatchIds(@Param(Constants.COLLECTION) Collection<? extends Serializable>
idList);

```

![](/static/2021-09-06-18-34-25.png)

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
@Autowired
private UserMapper userMapper;
@Test
public void testSelectBatchIds() {
//根据id集合批量查询
List<User> users = this.userMapper.selectBatchIds(Arrays.asList(2L, 3L, 10L));
for (User user : users) {
System.out.println(user);
}
}
}
```

## selectOne

根据条件查询一条数据，如果结果超过一条会报错

```java
/**
* 根据 entity 条件，查询一条记录
*
* @param queryWrapper 实体对象封装操作类（可以为 null）
*/
T selectOne(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
```

![](/static/2021-09-06-18-36-05.png)

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
@Autowired
private UserMapper userMapper;
@Test
public void testSelectOne() {
    QueryWrapper<User> wrapper = new QueryWrapper<User>();
    wrapper.eq("name", "李四");
    //根据条件查询一条数据，如果结果超过一条会报错
    User user = this.userMapper.selectOne(wrapper);
    System.out.println(user);
}
}
```

## selectCount

根据 Wrapper 条件，查询总记录数

```java
/**
* 根据 Wrapper 条件，查询总记录数
*
* @param queryWrapper 实体对象封装操作类（可以为 null）
*/
Integer selectCount(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
```

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
@Autowired
private UserMapper userMapper;
@Test
public void testSelectCount() {
    QueryWrapper<User> wrapper = new QueryWrapper<User>();
    wrapper.gt("age", 23); //年龄大于23岁
    //根据条件查询数据条数
    Integer count = this.userMapper.selectCount(wrapper);
    System.out.println("count = " + count);
}
}
```

## selectList

```java
/**
* 根据 entity 条件，查询全部记录
*
* @param queryWrapper 实体对象封装操作类（可以为 null）
*/
List<T> selectList(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
```

![](/static/2021-09-06-18-40-59.png)

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
@Autowired
private UserMapper userMapper;
@Test
public void testSelectList() {
    QueryWrapper<User> wrapper = new QueryWrapper<User>();
    wrapper.gt("age", 23); //年龄大于23岁
    //根据条件查询数据
    List<User> users = this.userMapper.selectList(wrapper);
    for (User user : users) {
        System.out.println("user = " + user);
    }
    }
}
```

like

![](/static/2021-09-06-18-41-13.png)
![](/static/2021-09-06-18-41-28.png)

## selectPage

```java
/**
* 根据 entity 条件，查询全部记录（并翻页）
*
* @param page 分页查询条件（可以为 RowBounds.DEFAULT）
* @param queryWrapper 实体对象封装操作类（可以为 null）
*/
IPage<T> selectPage(IPage<T> page, @Param(Constants.WRAPPER) Wrapper<T> queryWrapper);
```

---

需配置分页插件

```java
package cn.itcast.mp;
import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@MapperScan("cn.itcast.mp.mapper") //设置mapper接口的扫描包，之前是放在入口程序类上，放这里也可以
public class MybatisPlusConfig {
/**
* 分页插件
*/
@Bean
public PaginationInterceptor paginationInterceptor() {
    return new PaginationInterceptor();
    }
}
```

![](/static/2021-09-06-18-54-00.png)


```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
    @Autowired
    private UserMapper userMapper;
    @Test
    public void testSelectPage() {
        QueryWrapper<User> wrapper = new QueryWrapper<User>();
        wrapper.gt("age", 20); //年龄大于20岁
        
        Page<User> page = new Page<>(1,1);
        //根据条件查询数据
        IPage<User> iPage = this.userMapper.selectPage(page, wrapper);
        
        System.out.println("数据总条数：" + iPage.getTotal());
        System.out.println("总页数：" + iPage.getPages());
        
        List<User> users = iPage.getRecords();
        for (User user : users) {
            System.out.println("user = " + user);
        }
        }
}
```

# SQL注入的原理

前面我们已经知道，**MP在启动后会将BaseMapper中的一系列的方法注册到`meppedStatements`（容器）中**，那么究竟是如何注入的呢？流程又是怎么样的？下面我们将一起来分析下。

在MP中，**`ISqlInjector`负责SQL的注入工作**，它是一个接口，`AbstractSqlInjector`是它的实现类，实现关系如下

![](/static/2021-09-06-20-47-18.png)

![](/static/2021-09-06-21-12-45.png)
![](/static/2021-09-06-21-12-52.png)

* AbstractMethod类型的对象循环注入
* ![](/static/2021-09-06-21-30-54.png)

最终调用抽象方法`injectMappedStatement`进行真正的注入

![](/static/2021-09-06-21-27-43.png)
![](/static/2021-09-06-21-31-57.png)
![](/static/2021-09-06-21-32-44.png)

# MB基本配置

MP中有大量的配置，其中有一部分是Mybatis原生的配置，另一部分是MP的配置，详情：https://mybatis.plus/c
onfig/
下面我们对常用的配置做讲解

## configLocation

MyBatis 配置文件位置，**如果您有单独的 MyBatis 配置，请将其路径配置到 configLocation 中**。 MyBatis
Configuration 的具体内容请参考MyBatis 官方文档

![](/static/2021-09-06-21-36-43.png)

---

可以把分页插件移到mb的配置文件中

![](/static/2021-09-06-21-42-07.png)

## mapperLocations

MyBatis Mapper 所对应的 XML 文件位置，**如果您在 Mapper 中有自定义方法**（XML 中有自定义实现），需要进行该配置，告诉 Mapper 所对应的 XML 文件位置

![](/static/2021-09-06-21-45-47.png)

* classpath*:的出现是为了从多个jar文件中加载相同的文件.
  * **Maven 多模块项目的扫描路径需以 classpath*: 开头 （即加载多个 jar 包下的 XML 文件**）
* classpath:只能加载找到的第一个文件.

---

自定义mapper方法

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.itcast.mp.mapper.UserMapper">
<select id="findById" resultType="cn.itcast.mp.pojo.User">
select * from tb_user where id = #{id}
</select>
</mapper>
```

![](/static/2021-09-06-21-53-24.png)

```java
package cn.itcast.mp.mapper;
import cn.itcast.mp.pojo.User;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
public interface UserMapper extends BaseMapper<User> {
    User findById(Long id);
}

@RunWith(SpringRunner.class)
@SpringBootTest
public class UserMapperTest {
@Autowired
private UserMapper userMapper;
    @Test
    public void testSelectPage() {
        User user = this.userMapper.findById(2L);
        System.out.println(user);
    }
}
```

## typeAliasesPackage

MyBaits 别名包扫描路径，通过该属性可以给包中的类注册别名，**注册后在 Mapper 对应的 XML 文件中可以直接使用类名，而不用使用全限定的类名**（即 XML 中调用的时候不用包含包名）

![](/static/2021-09-06-21-54-02.png)
![](/static/2021-09-06-21-55-41.png)

# 进阶配置

本部分（Configuration）的配置大都为 MyBatis 原生支持的配置，这意味着您可以通过 MyBatis XML 配置文件的形 式进行配置

## mapUnderscoreToCamelCase

是否开启自动驼峰命名规则（camel case）映射，**即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属 性名 aColumn（驼峰命名） 的类似映射**

* 类型： boolean
* **默认值： true**
* 此属性在 MyBatis 中原默认值为 false，**在 MyBatis-Plus 中，此属性也将用于生成最终的 SQL 的 select body 如果您的数据库命名符合规则，无需使用 @TableField 注解指定数据库字段名**

在springboot或mybatis中配置，注意冲突

![](/static/2021-09-06-21-58-48.png)

## cacheEnabled

全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存，默认为 true。

* 类型： boolean
* 默认值： true
* `mybatis-plus.configuration.cache-enabled=false`

# DB 策略配置

## idType

全局默认主键类型，设置后，即可省略实体对象中的@TableId(type = IdType.AUTO)配置【**配置全局主键生成策略**】

* 类型： com.baomidou.mybatisplus.annotation.IdType
* 默认值： ID_WORKER
* ![](/static/2021-09-06-22-01-43.png)

## tablePrefix

表名前缀，全局配置后可省略`@TableName()`配置

* 类型： String
* 默认值： null
* MB默认把POJO类名转为小写去找表，找不到就报错
  * ![](/static/2021-09-06-22-04-27.png)
  * 不存在user这张表，，加上前缀tb_就可以

![](/static/2021-09-06-22-05-02.png)

# Wrapper：条件构造器

在MP中，Wrapper接口的实现类关系如下：

![](/static/2021-09-06-22-06-53.png)

可以看到，**AbstractWrapper和AbstractChainWrapper是重点实现**，接下来我们重点学习AbstractWrapper以及其子类。

说明:

QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类 用于生成 sql 的 where 条件, entity 属性也用于生成 sql 的 where 条件

注意: entity 生成的 where 条件与 使用各个 api 生成 的 where 条件没有任何关联行为

官网文档地址：https://mybatis.plus/guide/wrapper.html

## allEq

```java
allEq(Map<R, V> params)
allEq(Map<R, V> params, boolean null2IsNull)
allEq(boolean condition, Map<R, V> params, boolean null2IsNull)
```

全部eq(或个别isNull)

![](/static/2021-09-07-17-55-21.png)
![](/static/2021-09-07-18-00-17.png)

## 基本比较操作

![](/static/2021-09-07-18-02-30.png)
![](/static/2021-09-07-18-02-38.png)

```java
@Test
public void testEq() {
    QueryWrapper<User> wrapper = new QueryWrapper<>();
    //SELECT id,user_name,password,name,age,email FROM tb_user WHERE password = ?
    AND age >= ? AND name IN (?,?,?)
    wrapper.eq("password", "123456")
        .ge("age", 20)
        .in("name", "李四", "王五", "赵六");
    List<User> users = this.userMapper.selectList(wrapper);
    for (User user : users) {
        System.out.println(user);
    }
    }
}
```

## 模糊查询

![](/static/2021-09-07-18-03-41.png)
![](/static/2021-09-07-18-04-57.png)

## 排序

![](/static/2021-09-07-18-05-12.png)

![](/static/2021-09-07-18-07-34.png)

## 逻辑查询

![](/static/2021-09-07-18-08-03.png)
![](/static/2021-09-07-18-08-10.png)

![](/static/2021-09-07-18-09-11.png)

## select

默认全字段查询

![](/static/2021-09-07-18-11-13.png)

# ActiveRecord

![](/static/2021-09-07-20-35-02.png)

## 开启AR

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User extends Model<User> {
    private Long id;
private String userName;
private String password;
private String name;
private Integer age;
private String email;
}
```

## ID查询

![](/static/2021-09-07-20-37-51.png)

* 开启AR后，省去注入mapper（但底层还是要用到

## 新增数据

![](/static/2021-09-07-20-41-13.png)

![](/static/2021-09-07-20-42-13.png)

## 更新操作

![](/static/2021-09-07-20-42-32.png)
![](/static/2021-09-07-20-42-42.png)

## 删除操作

![](/static/2021-09-07-20-43-16.png)
![](/static/2021-09-07-20-43-25.png)

## 根据条件查询

![](/static/2021-09-07-20-44-52.png)
![](/static/2021-09-07-20-45-00.png)

# Oracle 主键Sequence

略

# 插件

## mybatis的插件机制

MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用（**所以插件又称拦截器**）。默认情况下，MyBatis 允许使用插件来拦截的方法
调用包括：

1. Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
2. ParameterHandler (getParameterObject, setParameters)
3. ResultSetHandler (handleResultSets, handleOutputParameters)
4. StatementHandler (prepare, parameterize, batch, update, query)

我们看到了可以拦截Executor接口的部分方法，比如update，query，commit，rollback等方法，还有其他接口的 一些方法等。

总体概括为：
1. 拦截执行器的方法
2. 拦截参数的处理
3. 拦截结果集的处理
4. 拦截Sql语法构建的处理

## 拦截器示例：

![](/static/2021-09-07-20-57-09.png)
![](/static/2021-09-07-20-57-18.png)

---

注入方式
![](/static/2021-09-07-20-58-54.png)

## 执行分析插件

在MP中提供了对SQL执行的分析的插件，可用作阻断全表更新、删除的操作，注意：该插件仅适用于开发环境，不适用于生产环境

![](/static/2021-09-07-21-05-51.png)
![](/static/2021-09-07-21-06-15.png)
![](/static/2021-09-07-21-06-53.png)

## 性能分析插件

性能分析拦截器，用于输出每条 SQL 语句及其执行时间，可以设置最大执行时间，超过时间会抛出异常

> 该插件只用于开发环境，不建议生产环境使用

![](/static/2021-09-07-21-08-26.png)
![](/static/2021-09-07-21-08-43.png)

## 乐观锁插件

主要适用场景

意图：
当要更新一条记录的时候，希望这条记录没有被别人更新

乐观锁实现方式：

* 取出记录时，获取当前version
* 更新时，带上这个version
* 执行更新时， set version = newVersion where version = oldVersion
* 如果version不对，就更新失败

---

peizhi

![](/static/2021-09-07-21-10-07.png)
![](/static/2021-09-07-21-10-19.png)

注解实体字段

![](/static/2021-09-07-21-14-29.png)

测试

![](/static/2021-09-07-21-14-57.png)
![](/static/2021-09-07-21-16-05.png)
![](/static/2021-09-07-21-15-28.png)

![](/static/2021-09-07-21-17-38.png)

### 特别说明

![](/static/2021-09-07-21-19-22.png)

# Sql 注入器

我们已经知道，在MP中，**通过AbstractSqlInjector将BaseMapper中的方法注入到了Mybatis容器**，这样这些方法才
可以正常执行。

那么，**如果我们需要扩充BaseMapper中的方法，又该如何实现呢**？

下面我们以扩展findAll方法为例进行学习

## 编写MyBaseMapper

![](/static/2021-09-07-21-21-33.png)
![](/static/2021-09-07-21-21-47.png)

## 编写MySqlInjector

如果直接继承AbstractSqlInjector的话，原有的BaseMapper中的方法将失效，所以我们**选择继承DefaultSqlInjector 进行扩展**

* 注入findall

![](/static/2021-09-07-21-52-42.png)

## 编写FindAll

![](/static/2021-09-07-21-44-48.png)

## 注册到Spring容器

![](/static/2021-09-07-21-48-01.png)
![](/static/2021-09-07-21-48-08.png)
![](/static/2021-09-07-21-48-16.png)

# 自动填充功能

有些时候我们可能会有这样的需求，插入或者更新数据时，**希望有些字段可以自动填充数据，比如密码、version 等**。在MP中提供了这样的功能，可以实现自动填充

## 添加@TableField注解

为password添加自动填充功能，**在新增数据时有效**
![](/static/2021-09-07-21-53-57.png)

FieldFill提供了多种模式选择

![](/static/2021-09-07-21-54-48.png)

## 编写MyMetaObjectHandler

插入时填充，更新时填充

```java
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
    @Override
public void insertFill(MetaObject metaObject) {
    Object password = getFieldValByName("password", metaObject);
    if(null == password){
        //pass字段为空，可以进行填充
        setFieldValByName("password", "123456", metaObject);
    }
}
    @Override
    public void updateFill(MetaObject metaObject) {
    }
}
```

# 逻辑删除

开发系统时，有时候在实现功能时，删除操作需要实现逻辑删除，**所谓逻辑删除就是将数【标记为删除】，而并非真正 的物理删除（非DELETE操作），查询时需要携带状态条件，确保被标记的数据不被查询到**。

* 这样做的目的就是避免 数据被真正的删除

## 修改表结构

![](/static/2021-09-07-22-01-26.png)

## 配置

![](/static/2021-09-07-22-01-45.png)

## 测试

![](/static/2021-09-07-22-02-05.png)
![](/static/2021-09-07-22-03-19.png)

![](/static/2021-09-07-22-03-05.png)

# 通用枚举

固定/特有类型

## 修改表结构

![](/static/2021-09-07-22-05-25.png)

## 定义枚举

![](/static/2021-09-07-22-05-52.png)

![](/static/2021-09-07-22-06-13.png)

## 配置

![](/static/2021-09-07-22-06-36.png)

## 修改实体

![](/static/2021-09-07-22-07-07.png)

## 测试

![](/static/2021-09-07-22-07-29.png)
![](/static/2021-09-07-22-07-45.png)

![](/static/2021-09-07-22-08-52.png)
![](/static/2021-09-07-22-09-44.png)
![](/static/2021-09-07-22-10-52.png)

# 代码生成器

AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率

![](/static/2021-09-07-22-11-16.png)

# MybatisX

![](/static/2021-09-07-22-15-04.png)