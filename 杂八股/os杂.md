# Content

抓threading和内存管理，调度 部分, 其他问的不是很深

> 内存管理多刷几遍= =老忘
> 

* [Content](#content)
* [冯诺依曼模型](#冯诺依曼模型)
* [线路位宽,CPU位宽 (数据传输)](#线路位宽cpu位宽-数据传输)
* [程序执行步骤：取指，解码，执行](#程序执行步骤取指解码执行)
* [指令类型 & 执行速度](#指令类型--执行速度)
* [=====================](#)
* [存储器速度, 层次结构](#存储器速度-层次结构)
* [=====================](#-1)
* [cache](#cache)
  * [cache结构](#cache结构)
  * [内存地址->缓存地址](#内存地址-缓存地址)
* [=====================](#-2)
* [缓存一致性(内存,cache)](#缓存一致性内存cache)
* [多核缓存一致性问题](#多核缓存一致性问题)
* [写传播 & 事务串行化: 总线嗅探 & MESI协议](#写传播--事务串行化-总线嗅探--mesi协议)
* [=====================](#-3)
* [CPU读写数据-伪共享问题（缓存失效）](#cpu读写数据-伪共享问题缓存失效)
* [伪共享问题（缓存失效）解决](#伪共享问题缓存失效解决)
* [=====================](#-4)
* [CPU调度线程（linux, task_struct](#cpu调度线程linux-task_struct)
* [CPU运行队列](#cpu运行队列)
* [nice值调整普通任务优先级](#nice值调整普通任务优先级)
* [=====================](#-5)
* [中断, 软中断，硬中断](#中断-软中断硬中断)
* [=====================](#-6)
* [数值存储](#数值存储)
* [=====================](#-7)
* [内核态，用户态](#内核态用户态)
* [Linux内核](#linux内核)
* [win内核](#win内核)
* [=====================](#-8)
* [虚存，虚拟地址，物理地址](#虚存虚拟地址物理地址)
* [地址映射：内存分段](#地址映射内存分段)
* [地址映射：内存分页](#地址映射内存分页)
* [多级页表：解决页表占用空间过大问题](#多级页表解决页表占用空间过大问题)
* [TLB：页表缓存](#tlb页表缓存)
* [段页式内存管理](#段页式内存管理)
* [linux内存管理](#linux内存管理)
* [=====================](#-9)
* [进程](#进程)
* [进程状态](#进程状态)
* [PCB进程控制结构](#pcb进程控制结构)
* [进程控制：创建、销毁、阻塞、唤醒](#进程控制创建销毁阻塞唤醒)
* [进程上下文切换](#进程上下文切换)
* [=====================](#-10)
* [线程](#线程)
* [线程vs进程](#线程vs进程)
* [线程上下文切换](#线程上下文切换)
* [线程实现方式：用户、内核、轻量级线程](#线程实现方式用户内核轻量级线程)
* [=====================](#-11)
* [调度](#调度)
* [调度时机：抢占式调度vs非抢占式调度](#调度时机抢占式调度vs非抢占式调度)
* [调度原则（调度器需要考虑的factor)](#调度原则调度器需要考虑的factor)
* [调度算法](#调度算法)
* [=====================](#-12)
* [进程通信模型](#进程通信模型)
* [管道](#管道)
* [消息队列](#消息队列)
* [共享内存](#共享内存)
* [=====================](#-13)

# 冯诺依曼模型

![](/static/2022-09-23-21-55-56.png)

![](/static/2022-09-23-22-00-38.png)

![](/static/2022-09-23-22-01-47.png)

# 线路位宽,CPU位宽 (数据传输)

![](/static/2022-09-23-22-12-47.png)

![](/static/2022-09-23-22-15-19.png)

# 程序执行步骤：取指，解码，执行

![](/static/2022-09-23-22-21-52.png)
![](/static/2022-09-23-22-27-28.png)

![](/static/2022-09-23-22-30-21.png)
![](/static/2022-09-23-22-35-50.png)

![](/static/2022-09-23-22-37-46.png)
![](/static/2022-09-23-22-39-51.png)

# 指令类型 & 执行速度

![](/static/2022-09-23-22-41-11.png)
![](/static/2022-09-23-22-45-46.png)

* 流水线，指令重排，等
  * 目的，让某指令需要的CPU时钟周期数尽可能少

# =====================

# 存储器速度, 层次结构

![](/static/2022-09-23-22-58-38.png)

![](/static/2022-09-23-22-59-26.png)
![](/static/2022-09-23-23-00-02.png)
![](/static/2022-09-23-23-00-18.png)

![](/static/2022-09-23-23-01-58.png)

![](/static/2022-09-25-20-52-11.png)

# =====================

# cache

![](/static/2022-09-25-21-18-57.png)

![](/static/2022-09-25-21-19-41.png)

## cache结构

![](/static/2022-09-25-21-20-58.png)
![](/static/2022-09-25-21-47-15.png)
![](/static/2022-09-25-21-22-14.png)

由cache line大小决定一次装多少数据

## 内存地址->缓存地址

![](/static/2022-09-25-21-23-26.png)
![](/static/2022-09-25-21-26-57.png)
![](/static/2022-09-25-21-38-41.png)
![](/static/2022-09-25-21-44-30.png)

# =====================

# 缓存一致性(内存,cache)

![](/static/2022-09-26-22-04-48.png)

![](/static/2022-09-26-22-08-04.png)
![](/static/2022-09-26-22-08-51.png)

![](/static/2022-09-26-22-09-05.png)
![](/static/2022-09-26-22-14-06.png)

# 多核缓存一致性问题

![](/static/2022-09-26-22-17-01.png)
![](/static/2022-09-26-22-18-15.png)
![](/static/2022-09-26-22-19-11.png)
![](/static/2022-09-26-22-20-08.png)
![](/static/2022-09-26-22-21-25.png)

# 写传播 & 事务串行化: 总线嗅探 & MESI协议

bus snooping

* MESI协议基于总线嗅探，解决缓存一致性问题，，且不会不管其他核心是否缓存了相同数据，就广播任意事件

![](/static/2022-09-26-22-24-04.png)

---

![](/static/2022-09-26-22-26-44.png)
![](/static/2022-09-26-22-31-18.png)

![](/static/2022-09-26-22-54-32.png)

# =====================

# CPU读写数据-伪共享问题（缓存失效）

![](/static/2022-09-26-22-58-02.png)

![](/static/2022-09-26-22-58-39.png)
![](/static/2022-09-26-23-00-03.png)

---

![](/static/2022-09-26-23-19-07.png)

![](/static/2022-09-26-23-19-38.png)
![](/static/2022-09-26-23-20-10.png)
![](/static/2022-09-26-23-20-31.png)
![](/static/2022-09-26-23-21-13.png)
![](/static/2022-09-26-23-22-53.png)

# 伪共享问题（缓存失效）解决

![](/static/2022-09-26-23-41-40.png)
![](/static/2022-09-26-23-42-07.png)
![](/static/2022-09-26-23-43-14.png)

* 空间换时间，避免缓存失效

---

Java Disruptor - 避免伪共享场景

![](/static/2022-09-26-23-46-39.png)

# =====================

# CPU调度线程（linux, task_struct

> 系统中需要运行的多线程数一般都会大于 CPU 核心，这样就会导致线程排队等待 CPU，这可能会产生一定的延时，如果我们的任务对延时容忍度很低，则可以通过一些人为手段干预 Linux 的默认调度策略和优先级。

![](/static/2022-09-26-23-55-11.png)
![](/static/2022-09-26-23-57-11.png)
![](/static/2022-09-27-00-00-00.png)

* 实时任务
  * Realtime调度器，deadline调度器
  * 3种策略
* 普通任务 - 完全公平调度
  * 高权重任务vruntime少，优先被CFS调度器选择，，vruntime变大后有机会调度其他任务

# CPU运行队列

![](/static/2022-09-27-00-03-57.png)

# nice值调整普通任务优先级

![](/static/2022-09-27-00-05-35.png)
![](/static/2022-09-27-00-06-38.png)

* nice值不管怎么调都是普通任务
  * 除非改变任务调度策略 为实时任务，，&优先级

# =====================

# 中断, 软中断，硬中断

![](/static/2022-09-27-00-14-50.png)

![](/static/2022-09-27-00-19-27.png)

* 延迟执行，软中断（CPU内核线程执行
* 硬中断，直接被中断处理程序处理

---

linux中的软中断

![](/static/2022-09-27-00-26-25.png)
![](/static/2022-09-27-00-26-41.png)

解决软中断CPU占用率过高问题

![](/static/2022-09-27-00-29-45.png)
![](/static/2022-09-27-00-28-29.png)
![](/static/2022-09-27-00-28-55.png)

# =====================

# 数值存储

> 这个直接画pdf了，，
> 
> 重点就是为什么用补码 （省去判断当前二进制到底是正数还是负数，需要额外操作，然后考虑是否需要将op转换，
> 
> 然后就是浮点数精度会掉

# =====================

# 内核态，用户态

![](/static/2022-09-30-18-16-23.png)

![](/static/2022-09-30-17-40-51.png)
![](/static/2022-09-30-17-46-10.png)

# Linux内核

![](/static/2022-09-30-17-50-55.png)
![](/static/2022-09-30-17-51-24.png)
![](/static/2022-09-30-18-03-02.png)
![](/static/2022-09-30-18-14-08.png)

# win内核

![](/static/2022-09-30-18-15-08.png)
![](/static/2022-09-30-18-15-39.png)

# =====================

![](/static/2022-09-30-22-18-19.png)

# 虚存，虚拟地址，物理地址

![](/static/2022-09-30-18-28-29.png)

![](/static/2022-09-30-18-32-57.png)

# 地址映射：内存分段

![](/static/2022-09-30-18-37-30.png)
![](/static/2022-09-30-18-50-42.png)
![](/static/2022-09-30-18-58-13.png)

问题

![](/static/2022-09-30-18-59-30.png)
![](/static/2022-09-30-19-03-50.png)

* **内存碎片**
  * 分配不是连续的。。映射到非连续位置，释放后产生碎片
  * 通过**内存交换**解决。把内存数据先写进硬盘，再写入内存（空闲内存最开头），，后面的程序装载就能放进后序连续内存，。因为硬盘访问速度有瓶颈。。所以效率很低

# 地址映射：内存分页

![](/static/2022-09-30-19-16-43.png)
![](/static/2022-09-30-19-37-13.png)

* 还在运行但是最近未使用的进程，交换物理内存至硬盘，该**进程挂起**
  * 一开始调度进程时，除非真的调度该进程，否则不用装入物理内存
* 会有内部内存碎片，因为最小分配单位是page
* 内存交换效率高
* 程序运行时才需要加载虚存中指令&数据至物理内存
  * 分段。。因为强制划分4个段，需要什么都要装进映射的物理内存特定位置

---

内存分页如何映射 虚拟地址->物理地址

![](/static/2022-09-30-19-48-14.png)
![](/static/2022-09-30-19-50-59.png)

# 多级页表：解决页表占用空间过大问题

![](/static/2022-09-30-19-59-57.png)
![](/static/2022-09-30-20-07-38.png)

---

64bit 系统，4级目录

![](/static/2022-09-30-20-10-42.png)

# TLB：页表缓存

![](/static/2022-09-30-20-24-14.png)

* CPU寻址：通过MMU先查TLB，找不到页表项，就查页表，映射

# 段页式内存管理

内存分段 & 分页结合

![](/static/2022-09-30-20-37-55.png)

# linux内存管理

![](/static/2022-09-30-20-41-19.png)

* 逻辑地址：程序所用地址，没被段式内存管理映射的地址

![](/static/2022-09-30-20-44-43.png)
![](/static/2022-09-30-20-45-26.png)
![](/static/2022-09-30-20-51-07.png)

![](/static/2022-09-30-20-55-09.png)

# =====================

# 进程

![](/static/2022-10-08-13-17-39.png)
![](/static/2022-10-08-13-18-52.png)

# 进程状态

![](/static/2022-10-08-13-20-08.png)
![](/static/2022-10-08-13-21-21.png)
![](/static/2022-10-08-13-25-36.png)

* 写错了是LRU

挂起

* 用户主动挂起
* sleep间歇性定时挂起
* 进程内存空间未装入物理空间（或者被交换出去

![](/static/2022-10-08-13-33-36.png)

# PCB进程控制结构

![](/static/2022-10-08-13-36-29.png)
![](/static/2022-10-08-13-37-11.png)

* 链式方式移动，添加进程状态更灵活（比维护索引，索引项

# 进程控制：创建、销毁、阻塞、唤醒

![](/static/2022-10-08-13-41-02.png)
![](/static/2022-10-08-13-49-26.png)

* PCB内包含CPU寄存器相关信息，辅助恢复断点

# 进程上下文切换

![](/static/2022-10-08-13-53-38.png)

CPU上下文切换，根据任务类型不同（进程、线程、中断） ，分为

* 进程上下文切换
* 线程上下文切换
* 中断上下文切换

---

![](/static/2022-10-08-14-01-14.png)

* 软中断交给内核线程处理，一般是中断后半部分任务。硬中断能直接交给中断处理程序处理前半段简单任务

# =====================

# 线程

![](/static/2022-10-08-14-10-50.png)
![](/static/2022-10-08-14-12-54.png)

* 独占寄存器，栈

# 线程vs进程

![](/static/2022-10-08-14-15-04.png)

* 线程切换，因为同一进程内线程共享地址空间（同一页），所以不需要走页表内存交换，切换速度快。
* 线程间数据传递也更快，进程间数据传递要走内核

# 线程上下文切换

![](/static/2022-10-08-14-18-38.png)

* 进程提供线程需要的基本环境，资源

# 线程实现方式：用户、内核、轻量级线程

![](/static/2022-10-08-14-23-17.png)
![](/static/2022-10-08-14-23-49.png)

---

用户线程
![](/static/2022-10-08-14-29-03.png)

* OS不参与线程调度，只是分配时间片给进程。线程主要由用户级线程库函数管理，除非释放锁，交出CPU使用权，否则同一进程中其他线程都无法运行。。因为用户态线程无权打断运行中的线程（os才有，但是os不管
* **被系统调用阻塞**的话，同一进程内所有线程都无法继续执行

---

内核线程

![](/static/2022-10-08-14-36-05.png)

---

轻量级线程 ？

![](/static/2022-10-08-14-39-11.png)
![](/static/2022-10-08-14-47-25.png)

# =====================

# 调度

![](/static/2022-10-08-15-01-24.png)

# 调度时机：抢占式调度vs非抢占式调度

![](/static/2022-10-08-15-23-05.png)

# 调度原则（调度器需要考虑的factor)

![](/static/2022-10-08-15-31-48.png)

# 调度算法

FCFS

![](/static/2022-10-08-15-33-03.png)

SJF

![](/static/2022-10-08-15-33-33.png)

高响应比优先 （Highest Response Ratio Next, HRRN）调度算法

![](/static/2022-10-08-15-34-14.png)

RR算法

![](/static/2022-10-08-15-35-24.png)

最高优先级调度算法，Highest Priority First，HPF
![](/static/2022-10-08-15-36-29.png)

多级反馈队列（Multilevel Feedback Queue）
![](/static/2022-10-08-15-41-46.png)

# =====================

# 进程通信模型

> 每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，**但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核**

# 管道

![](/static/2022-10-08-23-59-53.png)
![](/static/2022-10-09-00-01-15.png)

* 写入管道的数据，缓存在内核中。读端需要在内核中读取。
* 走的系统调用创建匿名管道

![](/static/2022-10-09-00-07-17.png)
![](/static/2022-10-09-00-08-45.png)
![](/static/2022-10-09-00-15-55.png)

* 匿名管道限定父子进程（通过fork fd描述符来完成进程通信）
* 命名管道，支持无关进程间通信

# 消息队列

![](/static/2022-10-09-00-20-14.png)

* 消息体有大小限制，消息队列不适合大数据传输
* 消息队列存在于内核，是消息链表
* 进程通信时产生用户态到内核态的切换开销

# 共享内存

![](/static/2022-10-09-00-23-17.png)

# =====================