# Content

抓threading和内存管理，调度 部分, 其他问的不是很深

* [Content](#content)
* [冯诺依曼模型](#冯诺依曼模型)
* [线路位宽,CPU位宽 (数据传输)](#线路位宽cpu位宽-数据传输)
* [程序执行步骤：取指，解码，执行](#程序执行步骤取指解码执行)
* [指令类型 & 执行速度](#指令类型--执行速度)
* [=====================](#)
* [存储器速度, 层次结构](#存储器速度-层次结构)
* [=====================](#-1)
* [cache](#cache)
  * [cache结构](#cache结构)
  * [内存地址->缓存地址](#内存地址-缓存地址)
* [=====================](#-2)
* [缓存一致性(内存,cache)](#缓存一致性内存cache)
* [多核缓存一致性问题](#多核缓存一致性问题)
* [写传播 & 事务串行化: 总线嗅探 & MESI协议](#写传播--事务串行化-总线嗅探--mesi协议)
* [=====================](#-3)
* [CPU读写数据-伪共享问题（缓存失效）](#cpu读写数据-伪共享问题缓存失效)
* [伪共享问题（缓存失效）解决](#伪共享问题缓存失效解决)
* [=====================](#-4)
* [CPU调度线程（linux, task_struct](#cpu调度线程linux-task_struct)
* [CPU运行队列](#cpu运行队列)
* [nice值调整普通任务优先级](#nice值调整普通任务优先级)
* [=====================](#-5)
* [中断, 软中断，硬中断](#中断-软中断硬中断)
* [=====================](#-6)
* [数值存储](#数值存储)
* [=====================](#-7)
* [内核态，用户态](#内核态用户态)
* [Linux内核](#linux内核)
* [win内核](#win内核)
* [=====================](#-8)
* [虚存，虚拟地址，物理地址](#虚存虚拟地址物理地址)
* [地址映射：内存分段](#地址映射内存分段)
* [地址映射：内存分页](#地址映射内存分页)
* [多级页表：解决页表占用空间过大问题](#多级页表解决页表占用空间过大问题)
* [TLB：页表缓存](#tlb页表缓存)
* [段页式内存管理](#段页式内存管理)
* [linux内存管理](#linux内存管理)
* [=====================](#-9)
* [=====================](#-10)
* [=====================](#-11)

# 冯诺依曼模型

![](/static/2022-09-23-21-55-56.png)

![](/static/2022-09-23-22-00-38.png)

![](/static/2022-09-23-22-01-47.png)

# 线路位宽,CPU位宽 (数据传输)

![](/static/2022-09-23-22-12-47.png)

![](/static/2022-09-23-22-15-19.png)

# 程序执行步骤：取指，解码，执行

![](/static/2022-09-23-22-21-52.png)
![](/static/2022-09-23-22-27-28.png)

![](/static/2022-09-23-22-30-21.png)
![](/static/2022-09-23-22-35-50.png)

![](/static/2022-09-23-22-37-46.png)
![](/static/2022-09-23-22-39-51.png)

# 指令类型 & 执行速度

![](/static/2022-09-23-22-41-11.png)
![](/static/2022-09-23-22-45-46.png)

* 流水线，指令重排，等
  * 目的，让某指令需要的CPU时钟周期数尽可能少

# =====================

# 存储器速度, 层次结构

![](/static/2022-09-23-22-58-38.png)

![](/static/2022-09-23-22-59-26.png)
![](/static/2022-09-23-23-00-02.png)
![](/static/2022-09-23-23-00-18.png)

![](/static/2022-09-23-23-01-58.png)

![](/static/2022-09-25-20-52-11.png)

# =====================

# cache

![](/static/2022-09-25-21-18-57.png)

![](/static/2022-09-25-21-19-41.png)

## cache结构

![](/static/2022-09-25-21-20-58.png)
![](/static/2022-09-25-21-47-15.png)
![](/static/2022-09-25-21-22-14.png)

由cache line大小决定一次装多少数据

## 内存地址->缓存地址

![](/static/2022-09-25-21-23-26.png)
![](/static/2022-09-25-21-26-57.png)
![](/static/2022-09-25-21-38-41.png)
![](/static/2022-09-25-21-44-30.png)

# =====================

# 缓存一致性(内存,cache)

![](/static/2022-09-26-22-04-48.png)

![](/static/2022-09-26-22-08-04.png)
![](/static/2022-09-26-22-08-51.png)

![](/static/2022-09-26-22-09-05.png)
![](/static/2022-09-26-22-14-06.png)

# 多核缓存一致性问题

![](/static/2022-09-26-22-17-01.png)
![](/static/2022-09-26-22-18-15.png)
![](/static/2022-09-26-22-19-11.png)
![](/static/2022-09-26-22-20-08.png)
![](/static/2022-09-26-22-21-25.png)

# 写传播 & 事务串行化: 总线嗅探 & MESI协议

bus snooping

* MESI协议基于总线嗅探，解决缓存一致性问题，，且不会不管其他核心是否缓存了相同数据，就广播任意事件

![](/static/2022-09-26-22-24-04.png)

---

![](/static/2022-09-26-22-26-44.png)
![](/static/2022-09-26-22-31-18.png)

![](/static/2022-09-26-22-54-32.png)

# =====================

# CPU读写数据-伪共享问题（缓存失效）

![](/static/2022-09-26-22-58-02.png)

![](/static/2022-09-26-22-58-39.png)
![](/static/2022-09-26-23-00-03.png)

---

![](/static/2022-09-26-23-19-07.png)

![](/static/2022-09-26-23-19-38.png)
![](/static/2022-09-26-23-20-10.png)
![](/static/2022-09-26-23-20-31.png)
![](/static/2022-09-26-23-21-13.png)
![](/static/2022-09-26-23-22-53.png)

# 伪共享问题（缓存失效）解决

![](/static/2022-09-26-23-41-40.png)
![](/static/2022-09-26-23-42-07.png)
![](/static/2022-09-26-23-43-14.png)

* 空间换时间，避免缓存失效

---

Java Disruptor - 避免伪共享场景

![](/static/2022-09-26-23-46-39.png)

# =====================

# CPU调度线程（linux, task_struct

> 系统中需要运行的多线程数一般都会大于 CPU 核心，这样就会导致线程排队等待 CPU，这可能会产生一定的延时，如果我们的任务对延时容忍度很低，则可以通过一些人为手段干预 Linux 的默认调度策略和优先级。

![](/static/2022-09-26-23-55-11.png)
![](/static/2022-09-26-23-57-11.png)
![](/static/2022-09-27-00-00-00.png)

* 实时任务
  * Realtime调度器，deadline调度器
  * 3种策略
* 普通任务 - 完全公平调度
  * 高权重任务vruntime少，优先被CFS调度器选择，，vruntime变大后有机会调度其他任务

# CPU运行队列

![](/static/2022-09-27-00-03-57.png)

# nice值调整普通任务优先级

![](/static/2022-09-27-00-05-35.png)
![](/static/2022-09-27-00-06-38.png)

* nice值不管怎么调都是普通任务
  * 除非改变任务调度策略 为实时任务，，&优先级

# =====================

# 中断, 软中断，硬中断

![](/static/2022-09-27-00-14-50.png)

![](/static/2022-09-27-00-19-27.png)

* 延迟执行，软中断（CPU内核线程执行
* 硬中断，直接被中断处理程序处理

---

linux中的软中断

![](/static/2022-09-27-00-26-25.png)
![](/static/2022-09-27-00-26-41.png)

解决软中断CPU占用率过高问题

![](/static/2022-09-27-00-29-45.png)
![](/static/2022-09-27-00-28-29.png)
![](/static/2022-09-27-00-28-55.png)

# =====================

# 数值存储

> 这个直接画pdf了，，
> 
> 重点就是为什么用补码 （省去判断当前二进制到底是正数还是负数，需要额外操作，然后考虑是否需要将op转换，
> 
> 然后就是浮点数精度会掉

# =====================

# 内核态，用户态

![](/static/2022-09-30-18-16-23.png)

![](/static/2022-09-30-17-40-51.png)
![](/static/2022-09-30-17-46-10.png)

# Linux内核

![](/static/2022-09-30-17-50-55.png)
![](/static/2022-09-30-17-51-24.png)
![](/static/2022-09-30-18-03-02.png)
![](/static/2022-09-30-18-14-08.png)

# win内核

![](/static/2022-09-30-18-15-08.png)
![](/static/2022-09-30-18-15-39.png)

# =====================

![](/static/2022-09-30-22-18-19.png)

# 虚存，虚拟地址，物理地址

![](/static/2022-09-30-18-28-29.png)

![](/static/2022-09-30-18-32-57.png)

# 地址映射：内存分段

![](/static/2022-09-30-18-37-30.png)
![](/static/2022-09-30-18-50-42.png)
![](/static/2022-09-30-18-58-13.png)

问题

![](/static/2022-09-30-18-59-30.png)
![](/static/2022-09-30-19-03-50.png)

* **内存碎片**
  * 分配不是连续的。。映射到非连续位置，释放后产生碎片
  * 通过**内存交换**解决。把内存数据先写进硬盘，再写入内存（空闲内存最开头），，后面的程序装载就能放进后序连续内存，。因为硬盘访问速度有瓶颈。。所以效率很低

# 地址映射：内存分页

![](/static/2022-09-30-19-16-43.png)
![](/static/2022-09-30-19-37-13.png)

* 会有内部内存碎片，因为最小分配单位是page
* 内存交换效率高
* 程序运行时才需要加载虚存中指令&数据至物理内存
  * 分段。。因为强制划分4个段，需要什么都要装进映射的物理内存特定位置

---

内存分页如何映射 虚拟地址->物理地址

![](/static/2022-09-30-19-48-14.png)
![](/static/2022-09-30-19-50-59.png)

# 多级页表：解决页表占用空间过大问题

![](/static/2022-09-30-19-59-57.png)
![](/static/2022-09-30-20-07-38.png)

---

64bit 系统，4级目录

![](/static/2022-09-30-20-10-42.png)

# TLB：页表缓存

![](/static/2022-09-30-20-24-14.png)

* CPU寻址：通过MMU先查TLB，找不到页表项，就查页表，映射

# 段页式内存管理

内存分段 & 分页结合

![](/static/2022-09-30-20-37-55.png)

# linux内存管理

![](/static/2022-09-30-20-41-19.png)

* 逻辑地址：程序所用地址，没被段式内存管理映射的地址

![](/static/2022-09-30-20-44-43.png)
![](/static/2022-09-30-20-45-26.png)
![](/static/2022-09-30-20-51-07.png)

![](/static/2022-09-30-20-55-09.png)

# =====================
# =====================
# =====================