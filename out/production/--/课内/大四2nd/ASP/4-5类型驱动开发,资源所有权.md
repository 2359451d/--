# Content

本讲座讨论了基于类型的建模和设计的概念，以及如何用它来提高系统程序的质量。它讨论了用于结构化系统的**类型驱动开发**的想法，以及这如何帮助**对问题域进行建模并帮助验证设计**。它还讨论了一些具体的例子，使用**类型来模拟数值；使用枚举来替代、选项和结果**；以及在状态机的建模中。还简要讨论了围绕**所有权跟踪**的想法，它是如何在Rust中实现的，以及如何使用它来改进系统设计。This lecture discusses the concept of type-based modelling and design, and how it can be used to improve the quality of systems programs. It discusses the idea of type-driven development for structuring systems, and how this helps model the problem domain and help validate the design. And it discusses some specific examples of this, using types to model numeric values; using enumerations for alternative, options, and results; and in the modelling of state machines. Ideas around ownership tracking, how it's realised in Rust, and how it can be used to improve system design are also briefly discussed.

* [Content](#content)
* [1-类型驱动开发-基于类型建模&设计:Type-based Modelling and Design](#1-类型驱动开发-基于类型建模设计type-based-modelling-and-design)
* [类型驱动开发: Type-driven Development](#类型驱动开发-type-driven-development)
* [定义类型：Define the Types](#定义类型define-the-types)
* [将属性与类型相关联：Associate properties with the types](#将属性与类型相关联associate-properties-with-the-types)
* [定义函数原型-类型作指导：Write the Function prototypes](#定义函数原型-类型作指导write-the-function-prototypes)
* [可用函数-类型约束行为：types constrain behaviour](#可用函数-类型约束行为types-constrain-behaviour)
* [系统模型细化-细化类型&函数：Refine Types and Functions](#系统模型细化-细化类型函数refine-types-and-functions)
* [利用类型系统检查模型(问题域)设计：Correct by Construction](#利用类型系统检查模型问题域设计correct-by-construction)
* [==========](#)
* [2-设计模式：Design Pattern](#2-设计模式design-pattern)
* [数值类型:Numeric Types](#数值类型numeric-types)
* [数值-强/弱类型：Strong Typing-Numeric Types](#数值-强弱类型strong-typing-numeric-types)
* [数值类型-添加更多triats：Numeric Types-COnversion](#数值类型-添加更多triatsnumeric-types-conversion)
* [数值类型-考虑需要的操作：Numeric Types-Operations](#数值类型-考虑需要的操作numeric-types-operations)
* [模式：数值封装(tuple结构体)-不会增加运行时开销：No runtime costs - Numeric Types](#模式数值封装tuple结构体-不会增加运行时开销no-runtime-costs---numeric-types)
* [模式：枚举类型&模式匹配模拟其他数据](#模式枚举类型模式匹配模拟其他数据)
* [Optional Values:Option<T>](#optional-valuesoptiont)
* [Result<T,E>](#resultte)
* [规避反模式-String：Features & Response Codes](#规避反模式-stringfeatures--response-codes)
* [规避反模式-boolean Flags](#规避反模式-boolean-flags)
* [Summary：类型系统建模问题域](#summary类型系统建模问题域)
* [==========](#-1)
* [3-状态机：State-Machines](#3-状态机state-machines)
* [状态机：State Machines](#状态机state-machines)
* [状态机实现：Implementing State Machine](#状态机实现implementing-state-machine)
* [状态机建模法-枚举: Enumerations for modelling state machines](#状态机建模法-枚举-enumerations-for-modelling-state-machines)
  * [例子：Using enum to Model State Machines](#例子using-enum-to-model-state-machines)
* [状态机建模法-结构体: Enumerations for modelling state machines](#状态机建模法-结构体-enumerations-for-modelling-state-machines)
  * [例子：Using struct to Model State Machines: Example](#例子using-struct-to-model-state-machines-example)
* [Summary: 权衡状态机2种表示法-Approaches to Representing State Machines](#summary-权衡状态机2种表示法-approaches-to-representing-state-machines)
* [==========](#-2)
* [4-所有权: Ownership](#4-所有权-ownership)
* [资源所有权管理：Ownership](#资源所有权管理ownership)
* [Rust所有权：Ownership in Rust](#rust所有权ownership-in-rust)
  * [例子](#例子)
  * [所有权传给函数：Ownership->Functions](#所有权传给函数ownership-functions)
  * [函数返回所有权：Return Value and Scope](#函数返回所有权return-value-and-scope)
  * [租借引用：References and Borrowing](#租借引用references-and-borrowing)
  * [可变引用：Mutable Reference](#可变引用mutable-reference)
* [String类型-堆&所有权例子](#string类型-堆所有权例子)
* [移动 vs 拷贝：move & clone](#移动-vs-拷贝move--clone)
* [Copy traits-栈数据拷贝：Stack-Only data copy](#copy-traits-栈数据拷贝stack-only-data-copy)
* [状态机&所有权：State Machines & Ownership](#状态机所有权state-machines--ownership)
  * [使用struct,enum状态机所有权对比](#使用structenum状态机所有权对比)
* [Recap-类型驱动开发：Type driven development](#recap-类型驱动开发type-driven-development)
* [typestate](#typestate)
* [phantom types结合类型移动](#phantom-types结合类型移动)
* [==========](#-3)
* [Readings](#readings)
* [=========](#-4)
* [Content](#content-1)
* [1-内存存储结构：Memory](#1-内存存储结构memory)
* [内存中的进程布局: Layout of a Processes in Memory](#内存中的进程布局-layout-of-a-processes-in-memory)
* [程序文本、数据和 BSS：Program Text, Data, and BSS](#程序文本数据和-bssprogram-text-data-and-bss)
* [栈：The Stack](#栈the-stack)
* [函数调用规范：Function Calling Conventions](#函数调用规范function-calling-conventions)
* [缓冲区溢出攻击：Buffer Overflow Attacks](#缓冲区溢出攻击buffer-overflow-attacks)
* [堆：The Heap](#堆the-heap)
* [内存映射文件和共享库：Memory Mapped Files and Shared Libraries](#内存映射文件和共享库memory-mapped-files-and-shared-libraries)
* [内核空间：The Kernel](#内核空间the-kernel)
* [==========](#-5)
* [2-自动内存管理-引用计数：Automatic Memory Management: Reference Counting](#2-自动内存管理-引用计数automatic-memory-management-reference-counting)
* [自动内存管理：Automatic Memory Management](#自动内存管理automatic-memory-management)
* [系统程序-内存管理：Memory Management in Systems Programs](#系统程序-内存管理memory-management-in-systems-programs)
* [堆管理：Managing the Heap](#堆管理managing-the-heap)
* [计数引用：Reference Counting](#计数引用reference-counting)
  * [优点：Benefits](#优点benefits)
  * [开销：Costs](#开销costs)
  * [适用场景](#适用场景)
* [==========](#-6)
* [3-基于区域的内存管理：Region-based Memory Management](#3-基于区域的内存管理region-based-memory-management)
* [基于区域内存管理目标：Rationale](#基于区域内存管理目标rationale)
* [基于栈内存管理：Stack-based Memory Management](#基于栈内存管理stack-based-memory-management)
  * [局限性](#局限性)
* [从栈内存管理延伸到堆管理：From Stack-to Region-based Memory Management](#从栈内存管理延伸到堆管理from-stack-to-region-based-memory-management)
* [======](#-7)
* [生命周期检查【引用】：Validating References with lifetimes](#生命周期检查引用validating-references-with-lifetimes)
  * [用生命周期防止悬空引用-Preventing Dangling References with Lifetimes](#用生命周期防止悬空引用-preventing-dangling-references-with-lifetimes)
  * [租借检查器：The Borrow Checker](#租借检查器the-borrow-checker)
  * [函数参数-通用生命周期：Generic Lifetimes in Functions](#函数参数-通用生命周期generic-lifetimes-in-functions)
    * [Lifetime Annotation Syntax 生存期注释语法](#lifetime-annotation-syntax-生存期注释语法)
  * [生命周期注解&悬挂指针](#生命周期注解悬挂指针)
* [结构体:引用字段-生命周期 Lifetime Annotations in Struct Definitions](#结构体引用字段-生命周期-lifetime-annotations-in-struct-definitions)
* [生命周期-省略规则](#生命周期-省略规则)
  * [方法定义-生命周期注解（规则1，3）：Lifetime Annotations in Method Definitions](#方法定义-生命周期注解规则13lifetime-annotations-in-method-definitions)
* [静态生命周期：The Static Lifetime](#静态生命周期the-static-lifetime)
* [泛型&traits bounds&生命周期](#泛型traits-bounds生命周期)
* [======](#-8)
* [智能指针](#智能指针)
* [======](#-9)
* [跟踪对象所有权-Rust有效化栈管理模式](#跟踪对象所有权-rust有效化栈管理模式)
* [函数返回数据所有权：Returning Ownership of Data](#函数返回数据所有权returning-ownership-of-data)
* [消除悬挂引用：No Dangling References](#消除悬挂引用no-dangling-references)
* [消除释放后使用：No Use-After-Free](#消除释放后使用no-use-after-free)
* [数据所有权转移给调用者：Taking Ownership of Data](#数据所有权转移给调用者taking-ownership-of-data)
* [==========](#-10)
* [4-资源管理：Resource Management](#4-资源管理resource-management)
* [引用租借：Borrowing Data](#引用租借borrowing-data)
* [迭代器无效-原生租借问题: Iterator Invalidation - Problems with Naive Borrowing](#迭代器无效-原生租借问题-iterator-invalidation---problems-with-naive-borrowing)
* [不同引用-安全租借：Safe Borrowing](#不同引用-安全租借safe-borrowing)
* [所有权追踪-优点：Benefits](#所有权追踪-优点benefits)
* [局限性-基于区域内存管理：Limitations of Region-based Systems](#局限性-基于区域内存管理limitations-of-region-based-systems)
* [Summary-基于区域内存管理：Region-based Memory Management](#summary-基于区域内存管理region-based-memory-management)
* [资源管理-(析构)确定性回收：Resource Management-Deterministic Cleanup](#资源管理-析构确定性回收resource-management-deterministic-cleanup)
* [所有权&状态-资源管理：Resource Management-Ownership and States](#所有权状态-资源管理resource-management-ownership-and-states)
* [==========](#-11)
* [Readings](#readings-1)

# 1-类型驱动开发-基于类型建模&设计:Type-based Modelling and Design

讲座的第一部分介绍了**类型驱动开发**的思想，这是一种开发软件的方式，首先定义类型，然后使用这些类型来指导完成系统所需的代码和功能的开发。它概述了为什么这种方法适用于使用具有强大类型系统的语言（例如 Rust）构建健壮、可靠的系统程序。The 1st part of the lecture introduces the idea of type-driven development, a way of developing software that starts by defining the types then using those to guide the development of the code and functions necessary to complete the system. It outlines why this approach is appropriate for building robust, reliable, systems programs in languages with powerful type systems, such as Rust.

# 类型驱动开发: Type-driven Development

表达式类型系统编程语言好处

![](/static/2022-02-18-00-26-04.png)

* 编译时期信息调试足够强大，足够大能力来检查系统模型设计，虽然前期需要一点开发设计成本，但对于大型系统来说减少了后期调试工作。越具有表现力，编译时期越是能有效捕捉错误，避免错误带到运行时期
* 而且能对状态机&行为编码（这是很多系统模型的基础）

---

* With expressive, strongly typed, languages – such as Rust, Swift, OCaml – can use the type system to help ensure correctness有了表现力的强类型化，语言--如Rust、Swift、OCaml--可以使用类型系统来帮助确保正确性
  * 现代编程语言，如我们在本课程中使用的Rust、Swift、OCaml、Scala、F#等等，都有非常有表现力的类型系统，而且有可能使用类型系统来帮助确保你所写代码的正确性。这样做的一种方式是被称为类型驱动开发的方法，它是在一种被称为Idris的语言中开创的。Modern programming languages such as Rust, which we’re using in this course, Swift, OCaml, Scala, F#, and so on, have very expressive type systems, and it's possible to use the type system to help ensure the correctness of the code that you write. One way of doing this is an approach known as type driven development, which was pioneered in a language known as Idris. 

---

- 首先定义类型 Define the types first
  - 在类型驱动的开发方法中，最初不是围绕着控制流来构造程序，围绕着程序应该做什么，而是首先围绕着类型来构造程序。想一想你的程序应该处理什么样的数据，什么样的对象，然后写下描述这些对象的类型. In a type driven development approach, rather than structuring a program initially around the control for flow, around what program should do, you structure it first around the types
  - 想一想你的程序应该处理什么样的数据，什么样的对象，然后写下描述这些对象的类型 Think about what sorts of data, what sort of objects, your program should be working with, and write down the types that describe those objects

---

然后以这些类型为指导，写下函数。写下这些函数的输入和输出类型，验证设计类型的检查和一致性，然后逐步完善这些函数。Then using the types as a guide, write down the functions. Write the input and output types of those functions, validate that the design type checks and is consistent, and then gradually refine the functions.

- 以类型为指导，编写函数 Using the types as a guide, write the functions
- 编写输入和输出类型 Write the input and output types
- 以类型的结构为指导，编写函数 Write the function, using the structure of the types as a guide
- 根据需要完善和编辑类型和函数 Refine and edit types and functions as necessary

---

基本的方法是，与其把类型看作是检查代码的一种方式，不如把它们看作是解决方案的一个计划，或者说是一个模型。你围绕着这些类型建立起设计，然后填入如何执行操作的细节。你让类型和编译器来指导你的设计结构  The fundamental approach is that rather than thinking of the types as a way of checking the code, you think of them as a plan, or as a model, for the solution. And you build up the the design around the types, and then fill in the details of how the operations are performed. You let the types, and the compiler, guide the structure of your design.

- 不要把类型看成是对代码的检查，要把它们看成是解决方案的一个计划--一个模型Don't think of the types as checking the code, think of them as a plan – a model – for the solution

# 定义类型：Define the Types

![](/static/2022-02-15-23-12-54.png)

第一阶段是定义类型。也就是说，考虑建立**问题域模型所需的类型** The first stage is to define the types. That is, think of the types which are needed to build a model of the problem domain

思考谁在互动，他们在与什么互动，以及他们交换的是什么类型的东西 Think about who's interacting, what are they interacting with, and what sorts of things do they exchange

* 问题域模型不同，所需类型 & 交互也不同
  * 这可能会导致你定义诸如发送者和接受者的类型。你可能有代表系统中不同实体之间的连接的类型，或者通过这些连接传输的TCP段 This will likely lead you to define types such as senders and receivers. You may have types that represent the connections between different entities in the system, or the TCP segments being transmitted over those connections.
  * 或者，如果你正在建立另一种类型的应用程序，你可能有雇员、车辆，或者在这些车辆中运输的不同类型的货物 Or, if you're building another type of application, you may have employees, vehicles, or different types of cargo that are transported in those vehicles.

想一想什么样的属性可以描述这些人和这些东西。并思考什么样的数据与他们每个人相关联。 Think about what sort of properties describe those people and those things. And think about what sort of data is associated with each of them.

* 这可能会使你想到诸如电子邮件地址、姓名、制造商等类型。或者代表物体属性的类型，如温度，或序列号，或颜色。 This probably leads you to types such as email addresses, names, manufacturers. Or types representing properties of objects, such as a temperature, or a sequence numbers, or a colour.

想一想系统可以处于哪些类型的状态，以及不同的交互可以处于哪些类型的状态。 Think about the types of states that the system can be in, and the types of states the different interactions can be in.

* 例如，一个消息应用，或一个电子邮件客户端，可能有表示发送消息的进度的状态。它可能有一个状态来表示它正在连接到服务器，一旦它被连接，就需要某种认证，或者它是否已经登录了。它可能有状态来表示消息是否已经被发送，或者正在发送过程中 A messaging app, or an email client, for example, may have states that represent the progress of sending a message. It may have a state to indicate that it is connecting to the server, that once it is connected that some some sort of authentication is required or whether it’s logged in. It may have states to represent whether the message has been sent, or is in the process of sending.

最初，这些类型很可能是定义不明确和抽象的。这并不重要。无论如何要把它们写下来。以后再细化它们。Initially, the types might very well be ill-defined and abstract. That doesn't matter. Write them down anyway. Refine them later. 

* 当你对问题有了更好的理解时，可以围绕这些类型进行重建和重新开发。不过，最主要的是要**考虑你需要什么类型来为问题领域建模。少考虑代码的结构，多考虑问题空间的结构，并将其表现为一组类型**。Circle around, rebuild and redevelop the types as you get a better understanding of the problem. The main thing, though, is to think about what types you need to model the problem domain. And think less about the structure of the code, and more about the structure of the problem space, and representing that as a set of types.

# 将属性与类型相关联：Associate properties with the types

![](/static/2022-02-15-23-30-58.png)

一旦你做到了这一点，想想与这些类型相关的属性。思考一下与你**系统中的每个事物相关联的数据类型，以及这些事物有什么属性**。Once you've done that, think about the properties that are associated with those types. Think about the types of data which which are associated with each of the things in your system, and what properties do those things have. 

* 例如，一个处理航运公司客户信息的程序可能有一个寄件人对象，其中包含客户的名字、他们的电子邮件地址和他们的邮政地址。For example, a program dealing with customer information for a shipping company might have a sender objects that hold the name of the customer, their email address, and their postal address. 
  * 写下这样的类型很容易，就像我们在幻灯片上看到的那样。我们不需要担心名字的格式，或电子邮件地址的格式，或邮政地址的格式。**我们只是注意到有这样一个类型，并在以后我们需要了解细节时再定义它**。It's easy to write down such a type, as we see on the slide. We don't need to worry about how a name is formatted, or an email addresses is formatted, or a postal address is formatted. We just note that there is a type for that, and define it later when we need to understand the details. 

同样地，我们思考**各种对象所处的状态**，我们写下**类型**来**代表**这些状态。Similarly, we think about states the various objects are in, and we write down types to represent the states. 

* 例如，如果系统正在登录某个网络资源，它可能有一些状态，分别代表尚未开始连接的系统和根本没有连接的系统；正在连接到远程服务器的系统；已经连接但尚未认证的系统；以及已经认证并登录的系统。For example, if the system is logging-in to some some networked resource, it may have states representing a system which has not started connecting, and is not connected at all; a system which is in the process of connecting to remote server; and a system which has connected, but has not yet authenticated; and a system which is authenticated and logged in. 
  * 而且，正如我们在枚举状态的例子中所看到的，**很容易写下一个类型来表示系统行为的这些不同方面**。And, as we see in the enum State example, it’s easy to write down a type that represents those different aspects of the system behaviour. 

用**不同的数据类型来表示行为的不同方面**，即**系统所处的不同状态**，可能也是有意义的。It may also make sense to represent the different aspects of the behaviour, the different states the system is in, in different data types. 

* 例如，我们可以把**经过认证的连接和未经认证的连接建模为两种不同类型的对象**，它们**都持有代表与远程资源连接的底层TCP套接字**。但它们被存储在不同类型的结构中，这**取决于系统当时正在做什么**。For example, we can model authenticated and unauthenticated connections as two different types of objects, both of which hold the underlying TCP socket that represents the connection to the remote resource. But which are stored in different types of structs, depending on what the system is doing at the time. 

重要的是写下这些类型，然后你可以根据需要进行完善和扩展，因为我们对系统的工作方式有了更好的把握。The important thing is to write down the types, which you can then refine and extend as needed, as we get a better handle on how the system is working.

# 定义函数原型-类型作指导：Write the Function prototypes

![](/static/2022-02-15-23-38-28.png)

一旦我们开始写下类型，我们就开始勾画函数。这里的想法是，通过**使用类型作为指导，我们勾勒出功能原型，而把系统的具体实现留到以后**。Once we’ve started by writing down the types, we then move on to sketching out functions. The idea here is that by using the types as a guide, we sketch out the function prototypes and leave the concrete implementation of the system until later. 

幻灯片上的例子显示了如何勾勒出一个电子邮件客户端的设计，例如。一个已经连接到服务器的电子邮件客户端可以是两种状态之一。The example on the slide shows how one might sketch out the design for an email client, for example. An email client that has connected to the server can be one of two states. 

* 在建立连接后的最初阶段，它将处于未经认证的状态，即连接到尚未登录的服务器上。在这种状态下，我们用幻灯片底部的未认证连接表示，它唯一可能执行的动作是**登录**或**断开连接**。Initially after it’s established the connection, it will be in an unauthenticated state, where it's connected to the server that has not yet logged in. In this state, which we represent by the unauthenticated connection at the bottom of the slide, the only possible actions that can perform are to **login or to disconnect**. 
  * 如果它登录了，它需要向服务器提供一些凭证。而且，其结果是，它要么成功登录，返回一个认证连接，要么提供了错误的凭证，我们会得到一个某种登录错误。If it logs in, it needs to provide some credentials to the server. And, as a result of that, it will either successfully login, returning an authenticated connection, or it will have provided the wrong credentials, and we'll get a login error of some sort. 
  * 重要的是，这种行为反映在函数的类型和操作中。 我们有一个经过认证的连接，我们对这个连接进行登录操作，给它一些凭证。如果它成功了，就会返回一个认证的连接，一个不同的连接类型。The important thing here is that this behaviour is reflected in the types and the operation of the function We have an authenticated connection, and we perform a login operation on that connection, giving it some credentials. **If it succeeds, it returns an authenticated connection, a different connection type.**
* 一旦我们有了一个认证连接，我们就可以执行你可能希望在电子邮件客户端执行的其他类型的操作。你可以列出文件夹，你可以列出文件夹中的邮件，最终你可以断开连接。Once we have an authenticated connection, we can perform the other types of operations you may wish to perform in an email client. You can list the folders, you can list the messages in a folder, and eventually you can disconnect. 

这里重要的是，仅从函数原型来看，系统的行为是很明显的。而我们**所处理的不同类型的对象制约了可能的行为**。What's important here is that the behaviour of the system is obvious just from looking at the function prototypes. And the different types of object we’re dealing with constrain the possible behaviours. 

* 如果我们没有登录，那么我们唯一能做的事情就是登录或断开连接，因为我们有一个未经认证的连接。If we're not logged in the only things we can do, given that we have an unauthenticated connection, is login or disconnect. 
* 如果我们登录了，我们唯一能做的事情就是列出文件夹，列出消息，或者断开连接。if we are logged in, the only things we can do is list the folders, list the messages, or disconnect. 
  * 这也许是显而易见的，但我们不能在登录之前尝试列出文件夹，我们也不能尝试锁定它登录两次。It's perhaps obvious, but we can't try to list the folders before we've logged in, and we can't try to lock it login twice. 

而且，不是系统禁止我们在运行时这样做，而是如果我们试图**在错误的(系统)状态下执行这些操作**，**代码就不会被编译**。那些函数，那些操作，并不存在于代表系统其他状态的类型上。And it's not the system prohibits us from doing this at runtime, is that the code won’t compile if we try to perform the operations in the wrong state. Those functions, those operations, don't exist on the types representing the other states of the system.

# 可用函数-类型约束行为：types constrain behaviour

![](/static/2022-02-16-15-04-20.png)

而这正是类型驱动设计的关键点之一。行为应该从类型中显而易见，而类型应该约束行为。And this is one of the key points of Type Driven Design. The behaviour should be obvious from the types, and the types should constrain the behaviour. 

在最简单的情况下。这意味着**使用特定的类型来模拟问题域，而不是使用类型**。In the simplest case. This means using specific types that model the problem domain, rather than using generic types. 

* 也就是说，传递一个Username参数，而不是一个String。或者传递一个摄氏度类型的温度，而不是一个Integer。That is, pass a username parameter around, rather than a string. Or pass a temperature in Celsius type around, rather than an integer. 
* 通过**使用更具体的类型，编译器可以检查我们在做什么**。它可以**检查我们所做的行为是否有意义**，并可以检查我们的设计。By using the more specific types, the compiler can check what we're doing. It can check that the behaviours we're doing makes sense, and can check our design. 
  * 本质上，它是机器可检查的文档,**如果我们的代码结构错误，它就不会被编译**。Essentially it's machine checkable documentation. If we structure the code wrong, it just won't compile. 

同样地，正如我们在上一张幻灯片上看到的，将状态编码为类型，将状态转换编码为操作这些类型的函数。Similarly, as we saw on the previous slide, encode the states as the types, and the state transitions as functions that manipulate those types. 

* 这张图显示了一个电子邮件客户端的状态机例子。你从预连接开始，系统还没有连接到服务器上。The diagram shows an example state machine for an email client. You start with a pre-connection, where the system is not yet connected to the server. 
* 你连接了，这就消耗了预连接，并返回一个代表未认证连接的新类型。You connect, and that consumes the pre-connection and returns a new type representing an unauthenticated connection. 
* 给予一个未认证的连接，你可以断开连接，这将关闭连接并给你一个预连接，或者你可以尝试登录。如果成功的话，你会得到一个认证的连接对象。Given an unauthenticated connection, you can either disconnect, which closes down the connection and gives you back a pre-connection, or you can attempt to login. And if that's successful you'll get an authenticated connection object. 
* 给予一个认证的连接对象，你可以列出文件夹，发送和接收电子邮件，或者你可以断开连接。Given an authenticated connection object, you can list folders, send and receive email messages, are you can disconnect. 

我们看到，这些**类型代表了状态机，而在不同状态之间转换的函数会返回不同的类型**。We see that the types represent the state machine, and that the functions which transition between the different states return different types. 

* 例如，登录函数消耗了足够多的未认证的连接对象，并返回一个认证的连接对象。它强行将程序从未认证状态转移到认证状态，因为它拿走了那个对象并返回新的对象。The login function, for example, consumes enough an unauthenticated connection objects and returns an authenticated connection object. It forcibly moves the program from the unauthenticated state to the authenticated state, because it takes away that object and returns the new object. 
* **这些函数只在那些对执行行为、执行逻辑、执行系统的状态机，为有意义的类型实现**。And the functions only get implemented on the types where they make sense to enforce the behaviour, enforce the logic, enforce the state machine of the system.

# 系统模型细化-细化类型&函数：Refine Types and Functions

![](/static/2022-02-16-15-27-17.png)

同样，我们的目标是**让类型和函数提供一个系统的模型。它们定义了你要处理的东西，以及当不同的操作被执行时，系统如何在其不同的状态之间移动**。Again, the goal is that the types and the functions provide a model of the system. They define what you're working with, and how the system moves between its various states as the different operations are performed .

你勾勒出一个初始设计，然后边走边**迭代** You sketch out an initial design, and then you iterate as you go.

* 每一次都要填入足够的细节以保证系统的编译，并**使用编译器来检查一致性**(**interactive design**). Each time just filling in enough details to keep the system compiling, and using the compiler to check for consistency. 
* 你逐渐完善设计，完善类型，完善函数，逐渐填充函数体，直到整个系统都被建模。And you gradually refine the design, you refine the types, you refine the functions, you gradually fill out the function bodies, until the whole system has been modelled. 
* 然后，逐渐加入具体的实现细节，根据需要进行完善。从本质上讲，你所做的是在你写出详细的实现之前，与编译器一起工作来验证设计。And, gradually, add in the concrete implementation details, refining as needed. Essentially, what you're doing is working with the compiler to validate the design, before you write the detailed implementation. 
* 然后，当你逐渐加入实现的细节时，编译器会让你保持正确。它在系统运行的各个环节验证你的设计是否正确。Then, as you gradually fill in the details of the implementation, the compiler keeps you right. It validates your design for correctness at all points through the operation of the system.

# 利用类型系统检查模型(问题域)设计：Correct by Construction

![](/static/2022-02-16-15-36-17.png)

这是一种被称为 "通过构造实现正确 "的方法。**使用类型，使用类型系统，对问题空间进行建模和检查，检查你的设计。并且在你开始运行代码之前就对你的设计进行调试**。It's an approach which is known as correct by construction. Use the types, use the type system, to model and check the problem space and check your design. And to debug your design before you even begin to run the code. 

这个想法是，你的程序中的**无意义的操作不会导致系统崩溃，相反，它们只是不被编译**。这是我们写代码的方式的一个变化。The idea is that nonsensical operations in your program don't cause the system to crash, rather they just don't compile. It's a change in perspective in the way we write code. 

使用类型系统，使用编译器，作为一个模型检查工具来帮助验证你的设计。**调试应该是一个检查设计正确性的过程，而不是寻找分段错误的地方**。Use the type system, use the compiler, as a model checking tool to help validate your design. Debugging should be a process of checking the design for correctness, not finding where the segmentation fault was.

# ==========

# 2-设计模式：Design Pattern

讲座的第二部分，扩展了类型驱动开发的思想，并讨论了一些具体的设计模式。特别是，本讲座**讨论了对数值使用特定的而不是的类型**；以及使用枚举类型，如Option和Result；以在代码中表达问题域的特征。这有助于对问题进行建模，并**让编译器开始帮助检查系统设计的一致性和正确性**。Part 2 of the lecture, expands on the ideas of type-driven development, and discuss some specific design patterns. In particular, the lecture discusses the use of specific rather than generic types for numeric values; and the use of enumeration types, such as Option and Result; to being to express features of the problem domain in the code. This helps model the problem, and lets the compiler start to help check system designs for consistency and correctness.

# 数值类型:Numeric Types

![](/static/2022-02-16-15-43-25.png)

根据类型驱动的设计方法，在构建系统时要问的一个关键问题是，一个数字值是否真的最好表示为浮点值或整数，或者它是否有一些可以包含在类型中的意义。One of the key questions to ask when building a system, according to the type driven design approach, is whether a numeric value is really best represented as a floating point value or an integer, or does it have some meaning that could be included in the types. 

* 例如，该值实际上是以摄氏度或华氏度为单位的温度，以英里/小时或公里/小时为单位的速度，一个用户ID，一个数据包序列号，或其他什么。For example, is the value actually a temperature in degrees Celsius or degrees Fahrenheit, a speed in miles per hour or kilometres per hour, a user ID, a packet sequence number, or whatever. 

我们的想法是，应该可以**将一个数值的含义编码在其类型中**，这样**编译器就可以检查该类型的一致使用**。The idea is that it should be possible to encode the meaning of a numeric value in its type, so the compiler can check for consistent usage of that type. 

* 如果类型不匹配，混合不同类型的操作应该失败。或者它们应该进行安全的单位转换。Operations that mix different types should fail if the types don't match. Or they should perform safe unit conversions. 
* 对于一个类型来说不合适的操作应该是不可能的。And operations that are inappropriate for a type shouldn't be possible. 

幻灯片上显示的那篇新闻文章给出了一个著名的例子，说明这种混乱可能导致的问题。火星气候轨道器的软件在代码的某些部分使用公制单位，而在其他部分使用英制单位，并且**无法分辨这两者何时被混淆**。That the news article shown on the slide gives a famous example of the problems this sort of confusion can cause. The software for the Mars Climate Orbiter used metric units in some parts of the code, and Imperial units in others, and wasn't able to tell when the two were being mixed up. 

* 其结果是航天器坠入行星，而不是进入轨道，浪费了数亿美元和多年的工作，因为它的推进器发射时间过长，由于计算错误。The result was that the spacecraft crashed into the planet, rather than entering orbit, wasting many hundreds of millions of dollars and many years of work, because it fired its thrusters for too long, due to a miscalculation. 
* 我认为这种类型的错误是不可能发生的。写得好的代码**应该把单位编码成数字类型**。**如果你的程序混淆了磅力秒和牛顿秒**，就像在火星气候轨道器中发生的那样，**代码不应该在运行时失败 - 它不应该被编译**。I'd argue that this type of error shouldn't be possible. Well written code should encode the units into the numeric types. If your program is mixing up Pound Force Seconds and Newton Seconds, as happened in the Mars Climate Orbiter, the code shouldn’t fail at runtime – it shouldn’t compile. 
* 那么，目标应该是在类型系统中表示不同的单位，不同类型的数字值。The goal then, should be to represent the different units, the different types of numeric values, in the type system.

# 数值-强/弱类型：Strong Typing-Numeric Types

弱类型

![](/static/2022-02-16-15-48-08.png)

因此，让我们把这个问题变得更具体一点。右边的代码是一个非常简单的例子。So let's make this a little bit more concrete. The code on the right is a very simple example. 

* 它将变量C设置为15--温度（摄氏度），将变量F设置为50--温度（华氏度）。然后它计算出T的值为F和C之和，并打印出结果。它打印出的值是65。50和15的总和。It sets the variable C to be 15 – the temperature in degrees Celsius, And the variable F to be 50 – a temperature in degrees Fahrenheit. And it then calculates the value T as being the sum of F and C, and prints out the result. It prints out the value of 65. The sum of 50 and 15. 
* 而且，从数字上看，这是有意义的。然而，作为一个程序员，我们知道它实际上给出了错误的答案。And, numerically, this makes sense. However, as a programmer, we know that it's actually giving the wrong answer. 
* 不幸的是，编译器并不知道。编译器不知道15摄氏度加上50华氏度是109华氏度，所以它默默地给出了错误的答案。Unfortunately, the compiler doesn’t. The compiler doesn't know that 15 Celsius plus 50 Fahrenheit is 109 Fahrenheit, so it silently gives the wrong answer. 

**程序员所知道的关于设计的约束条件并【没有在类型中体现出来】，所以编译器无法抓住这个错误**。The constraints the programmer knows about the design are not represented in the types, so the compiler can't catch the mistake.

---

强类型

![](/static/2022-02-16-16-03-58.png)

为了开始解决这个问题，我们应该定义更具体的类型，代表摄氏和华氏的温度，并在整个程序中使用这些类型，而不是整数或浮点值。To begin to address this problem, we should define more specific types representing temperatures in Celsius and in Fahrenheit, and use those types, instead of integers or floating point values throughout our program. 

* 例如，如果我们看一下幻灯片上样本底部的主函数，我们让数值C等于15摄氏度，数值F等于50华氏度，然后当我们试图将它们相加时，你会得到你在左边看到的错误。这段代码不能编译。For example, if we look at the main function at the bottom of the sample on the slide, we let the value C equal 15 Celsius and the value F equals 50 Fahrenheit, and then when we try to add them, you get the error you see on the left of the side. The code doesn't compile. 
* 它期望的是摄氏度。它找到了华氏温度。而这里并没有定义它们之间的转换。**编译器检测到了这个错误**。It's expecting Celsius. It found Fahrenheit. And t here's no conversion between them defined. The compiler detects the bug. 

我们如何定义这些更具体的类型呢？它们是tuple structs，如列表顶部所示。它们从标准库中派生出PartialEq和PartialOrd特性，这些特性允许它们进行平等比较并提供排序。它们派生出Debug特性，允许它们被调试函数打印出来。How do we define these more specific types? They’re tuple structs, as shown at the top of the listing. They derive the PartialEq and PartialOrd traits, from the standard library, that allow them to be compared for equality and provide ordering. And they derive the Debug trait, that allows them to be printed by debugging functions. 

* 而且，我们在代码的其余部分看到，我们实现了加法函数，即来自标准库的Add特性，它允许我们将摄氏度的值加在一起，或者允许我们将华氏度的值加在一起。And, we see in the rest of the code, we implement the addition function, the Add trait from the standard library, that allows us to add values in Celsius together, or allows us to add values in Fahrenheit together. 
* 因此，如果我们有正确的类型，如果我们一贯使用摄氏度，或者一贯使用华氏度，加法将正确工作。So if we have the types right, if we're consistently using Celsius, or if we're consistently using Fahrenheit, the addition will work correctly. 
* 然而，在这种情况下，代码是不正确的，而且编译器抓住了我们的错误。However, in this case the code isn't correct and the compiler catches our mistake. 

现在，这显然是一个简单的例子。我们只定义了摄氏度和华氏度类型，我们只实现了Add运算，我们只派生了PartialEq和PartialOrd的特性。当然，在一个真正的实现中，我们还会实现减法、乘法和除法，可能还有其他一些操作。Now this is obviously a simple example. We’re only defining Celsius and Fahrenheit types, and we only implement the addition operation, and we only derive the partial equality and partial ordering traits. And of course in a real implementation we’d also implement subtraction and multiplication and division, and possibly a number of other operations. 

* 但它显示了这个原理。我们可以**通过使用特定的数字类型来代替类型来开始捕捉错误**。But it shows the principle. We can begin to catch errors by using specific numeric types in place of the generic types. 
* 当然，这里有一些复杂性。我们需要定义tuple structs来表示摄氏度和华氏度类型，我们还需要为我们需要的操作实现各种traits。 There's some complexity here, of course. We need to define tuple structs to represent the Celsius and Fahrenheit types, and we need to implement the various traits for the operations we require. 
  * 有更多的前期设计工作，**更多的前期实现工作，但我们获得了检查设计正确性的能力**。There's more up-front design work, more up-front implementation work, but we gain the ability to check the designs for correctness. 
  * 对于小程序来说，这可能不是一个胜利，但**随着系统变得越来越复杂，随着我们在类型中包含更多关于设计的约束信息，我们可以捕捉到越来越多的错误**。对于大型系统来说，这是一个非常大的胜利。For small programs this probably isn't a win, but as the system gets more complex, and as we include more information about the constraints on the design in types, we can catch more and more bugs. It's very much a win overall for large systems.

# 数值类型-添加更多triats：Numeric Types-COnversion

![](/static/2022-02-16-16-15-07.png)

Rust中的类型系统足够灵活，我们可以添加更多的功能来使这些类型的使用更加自然。The type system in Rust is flexible enough that we can add more features to make use of these types more natural. 

例如，我们可以添加执行单位转换的实现。标准库定义了代表标准数字运算的traits，例如加法、减法、乘法和除法，这些**traits都是由它们所操作的类型来决定的**。 For example, we can add implementations that perform unit conversions. The standard library defines traits to represent standard numerical operations, such as addition, subtraction, multiplication and division, for example, that are parameterised by the types on which they operate. 

在这个例子中，我们以华氏温度作为类型参数，为摄氏温度类型实现加法特性。这描述了你如何将华氏值添加到摄氏值中。而且它允许main()函数中的代码成功地添加摄氏度和华氏度的值，并打印出正确的结果。In this example, we implement the Add trait, with Fahrenheit as a type parameter, for the Celsius type. This describes how you add a Fahrenheit value to a Celsius value. And it allows the code in the main() function to successfully add Celsius and Fahrenheit values and print out the correct result.

# 数值类型-考虑需要的操作：Numeric Types-Operations

![](/static/2022-02-16-16-24-51.png)

你还应该考虑所有的标准操作对你定义的数字类型是否有意义。You should also think whether all the standard operations makes sense for the numeric types you define. 

* 例如，比较温度值是否相等是合理的，或者比较两个温度看哪个是最大的，所以你要实现提供这些操作的标准平等和序数特性。It's reasonable to compare temperature values for equality, for example, or to compare two temperatures to see which is the largest, so you'd implement the standard equality and ordinal traits that provide these operations. 
* 不过，为所有类型实现这些操作并不一定有意义。如果你有一个UserID类型，你可能想实现Eq特性，以便能够检查两个UserID值是否相同。 It doesn't necessarily make sense to implement such operations for all types, though. If you have a UserID type, you may want to implement the equality trait to be able to check if two UserID values are the same. 
* 但是把两个UserID值加在一起，或者比较UserID值看哪个是最大的，可能都没有意义。你不一定需要为你定义的特定数字类型实现所有的标准操作。But adding two UserID values together, or comparing UserID values to see which is largest, may not be meaningful. You don't necessarily need to implement all the standard operations for the specific numeric types you define. 

**你只需实现那些对这些类型有意义的操作即可**。并非所有的数字类型实际上都是数字，也并非所有的数字类型都应该被当作是数字。You just implement those that makes sense for those types. Not all numeric types are actually numbers, and not all numeric types should be treated as if they are numbers. 

* 有些仅仅是标识符，你可以通过**禁止对数据没有意义的操作来确保它们以这种方式被使用**。Some are merely identifiers, and you can make sure that they're used in that way, by disallowing operations that are not meaningful for the data.

# 模式：数值封装(tuple结构体)-不会增加运行时开销：No runtime costs - Numeric Types

![](/static/2022-02-16-16-35-45.png)

有趣的是，在Rust中，以这种方式将数值包裹在tuple structs中，没有任何运行时开销。What's interesting is that wrapping numeric values inside tuple structs in this way has no runtime overhead in Rust.

* 但显然有一些程序员的开销。程序员需要考虑存在哪些类型，以及**哪些操作对这些类型有意义**。并且需要实现标准操作。所以，有一堆额外的代码是需要的。有更多的前期设计工作，更多的前期实现工作。There's clearly some programmer overhead. The programmer needs to think about what types exist, and what operations make sense on those types. And needs to implement the standard operations. So there's a bunch of extra code that's needed. There’s more up-front design work, more up-front implementation work. 
* 我不想淡化这一点。这可能是相当多的工作。你需要实施一个相当大的系统，然后才值得努力。但我要指出的是，有一些宏，比如幻灯片上提到的
* newtype_derive crate，在常见的情况下使之更容易，并使之**直接用很少的代码来定义常见的操作**。And I don't want to downplay this. It can be quite a lot of work. You need to be implementing a reasonably large system before it becomes worth the effort. I’ll note, though, that there are macros, such as the newtype_derive crate mentioned on the slide, that make this easier in the common cases, and make it straightforward to define the common operations with little code. 

这种额外的代码--这种额外的实现努力--导致生成的代码没有运行时的变化。额外的检查，额外的功能，纯粹是在**编译时存在的**。为什么没有运行时成本？This extra code – this extra implementation effort – leads to no runtime change in the generated code. The additional checking, the additional functionality, exists purely at compile time. Why is there no runtime cost? 

* 部分原因是**tuple structs**与整数或浮点类型相比**没有增加额外的信息**。它们持有相同的值，所以有相同的大小。in part because tuple structs add no extra information compared to an integer, or a floating point type. They hold the same values, and so have the same size.
* 而且，由于**Rust不会自动对值进行装箱**，它们的传递方式与原始类型完全相同。在生成代码时，**编译器和优化器认识到所执行的操作与原始类型上的操作是等价的，并将生成完全相同的代码来完成这些操作，就像他们在这些原始类型上的操作一样**。And since Rust doesn't automatically box values, they’re passed around in exactly the same way as the primitive types. When generating code, the compiler and optimiser recognise that the operations being performed are equivalent to those on the primitive types, and will generate the exact same code to do so, as if they were operating natively on those primitive types. 
* 例如，在**Add摄氏度和华氏度值**时，正如我们在前面的幻灯片中看到的那样，**所生成的代码与我们在原生地处理浮点值的代码完全相同**。When adding Celsius and Fahrenheit values, for example, as we saw in the previous slides, the code that’s generated is the exact same code as if we were natively working with floating point values.
  * 底层就是处理float

将原始类型包裹在一个tuple structs中并实现各种操作，**提供了编译时的正确性检查，但不会以任何方式影响生成的代码**。而且这种行为并不是Rust独有的。Wrapping the primitive type in a tuple struct and implementing the various operations provides compile-time checking for correctness, but doesn’t affect the generated code in any way. And this behaviour is not unique to Rust.

* 例如，同等的C++代码具有完全相同的属性，但**没有多少语言允许你传递未装箱的值，并对数据布局进行精确控制**。 Equivalent C++ code has exactly the same properties, for example, but there are not many languages which allow you to pass unboxed values around, and to have precise control over the data layout. The type system in 
* Scala的类型系统有足够的表现力来表示这些数字类型，并且可以执行我所描述的各种检查。但是，**由于所产生的代码在Java虚拟机上运行，它的开销会更大**。Scala is expressive enough to represent numeric types such as these, and to perform the sorts of checks I’ve described. But, because the resulting code runs on the Java virtual machine, it would have a lot more overhead. 
* 在Rust或C++中，你**可以将原始类型包裹在一个结构中，这样做没有运行时的开销**。这在许多其他语言中是不可能的。In Rust or C++ you can wrap a primitive type in a struct, and do so with no runtime overhead. That's not possible in many other languages.

# 模式：枚举类型&模式匹配模拟其他数据

![](/static/2022-02-16-16-56-54.png)

封装数字类型是一种重要的设计模式，在类型驱动设计中很有用。Wrapping numeric types is an important design pattern that's useful in Type Driven Design. 

另一种在Rust中变得有用的模式，是使用枚举类型和模式匹配来模拟备选方案、Option、Result、特征和响应代码以及标志。Another such a pattern that becomes useful in Rust, is to use enum types and pattern matching to model alternatives, options, results, features and response codes, and flags. 

* 这可以让编译器检查这些类型的正确性，并进一步帮助我们在开始运行和调试代码之前调试我们的设计。This lets the compiler check these types for correctness, and further helps us debug our design before we start running and debugging our code.

# Optional Values:Option<T>

![](/static/2022-02-16-17-00-58.png)

有时候，一个程序**必须要处理可能不存在的值**。我们可以在Rust中使用**Option类型**来表示这些。Sometimes a program has to work with values that might not be present. We can use the Option type to represent these in Rust. 

* 例如，如果一个函数可能会返回一个值，或者可能找不到那个值，比如幻灯片上显示的lookup()函数，我们会返回一个可选的结果。 For example, if a function might return a value, or might not be able to find that value, such as the lookup() functions shown on the slide, we return an optional result. 
* 正如我们在前面的讲座中看到的，这比返回一个可选的空指针更安全，因为编译器迫使我们在使用该值时进行模式匹配，并处理Some和None两种情况。As we saw in the previous lecture, this is safer than returning an optional null pointer because the compiler forces us to pattern match when using the value and handle both the Some and None cases. 
* 这在语义上也更有意义。它使程序中的意图更加清晰。本质上，**它提供了机器可检查的文档**。 It's also more semantically meaningful. It makes the intent clearer in the program. Essentially, it provides machine checkable documentation. 

也可以将可Option值作为结构定义的一部分。 It's also possible to use optional values as part of struct definitions. 

* 例如，在这里我们看到网络数据包格式的定义，即RTP头，如右图所示。这在Rust代码中表现为左边所示的结构RtpHeader类型的定义。For example, here we see the definition of a network packet format, an RTP header, as shown on the right. This is represented in Rust code is shown on the left, with the definition of the struct RtpHeader type. 
* 一个RTP头包含一个可选的字段，被称为头的扩展。我们可以在结构中表示这一点，方法是在结构定义中包括一个代表该格式的 Option 类型。同样，这使得编译器和其他程序员都能清楚地了解其意图。An RTP header contains an optional field, known as the header extension. We can represent this in the struct, by including an Option type in the struct definition representing that format. Again, this makes the intent clear to both the compiler and to other programmers.

---

![](/static/2022-02-16-17-16-50.png)

在这两种情况下，无论我们是将 Option 作为一个函数的返回值，还是作为一个结构中的字段，**编译器都会强制要求处理这两种变体**。In both cases, whether we use an Option as a return value from a function, or as a field in a struct, the compiler enforces that both variants are handled. 

* 编译器强制要求我们既要检查值存在的Some情况，又要检查字段或值不存在的None情况。The compiler enforces that we check both the Some case, where the value exists, and the None case where the field or the value isn't present. 
* 我们**不能意外地写出假定值总是存在的代码**，如果不存在，就会在运行时崩溃。We can't accidentally write code that assumes the value is always present and crashes at run time if not.

# Result<T,E>

![](/static/2022-02-16-17-22-10.png)

除了Option之外，Rust还有一个Result类型，代表了**可能失败的计算**。In addition to Option, Rust has a Result type that represents a computation that can fail. 

* 例如，幻灯片显示了一个load_document()函数，它返回的结果可以是一个Document对象，也可以是一个数据库错误。For example, the slide shows a load_document() function that returns a result that can either be a Document object, or a database error. 
* 就像Option类型对失败时返回空指针这一习惯的更好版本进行编码一样，**Result类型也是对异常处理或返回一个哨兵值（如-1）以表示Error**的函数的更好版本。 In the same way that the Option type encode a better version of the idiom of returning a null pointer on failure, the result type is a better version of exception handling or of functions that return a sentinel value, such as -1, to indicate an error. 

而且，与Option类型迫使我们通过模式匹配来提取值，并确保我们考虑到值不存在的情况一样，**Result类型确保我们同时考虑到成功和失败的情况。获取结果值的唯一方法是模式匹配**。And, in the same way that the Option type forces us to pattern match to extract the value, and make sure we consider the case where the value is absent, the Result type make sure that we consider both the success and failure conditions. The only way to get at the result value is by pattern matching. 

* 我们可以检查Ok()情况并检索出成功的值，或者我们可以检查Err()情况并检索出失败值。**不可能写出不进行检查的代码--这样的代码是不会被编译的**。We can either check the Ok() case and retrieve the successful value, or we can check the Err() case and retrieve the failure value. It's not possible to write code that doesn't perform the check – such code won’t compile. 

Result类型相当于Rust中的异常处理。与异常不同的是，它更加明确。The Result type is the equivalent of exception handling in Rust. The difference from exceptions is that it's more explicit. 

* **异常可以在代码中的任何一点明确抛出**，但也可以由任何被调用的方法或函数抛出。**一般来说，除非仔细阅读文档，否则不可能知道一个操作是否会抛出一个异常。一个函数抛出一个异常，在代码中一般是不可见的**。Exceptions can be explicitly thrown at any point in the code, but can also be thrown by any method or function that is called. In general, it’s not possible to know if an operation will throw an exception or not, except by careful reading to the documentation. That a function throws an exception is generally not visible in the code. 
* **Result是由函数明确返回的**。Rust函数何时会失败总是很清楚的，因为它的返回值是一个结果类型。与Option类型一样，有必要对Result进行**模式匹配**，以确定它们是编码成功还是失败，并提取结果值。这使得代码必须处理这两种情况。 Results, on the other hand, are explicitly returned from functions. It’s always clear when a Rust function can fail, because it will have a Result type as its return value. As with the Option type, it’s necessary to pattern match on Results to determine if they encode success or failure, and to extract the result value. This forces code to handle both cases.

不过，Rust有一个传播错误的捷径。如果我们看一下幻灯片上对open_database()和db.load()函数的调用，我们会发现它们**以问号结尾**。**这些函数返回一个结果类型，注解表明这可能会在调用链上传播。编译器会扩展以这种方式注解的函数或方法调用，在它们周围添加相当于匹配语句的内容**。Rust has a shortcut, though, for propagating errors. If we look at the calls to the open_database() and db.load() functions on the slide, we’ll see that they end in a question mark. These functions return a Result type, and the annotation indicates that this should potentially be propagated up the call chain. The compiler expands function or method calls annotated in this way, adding the equivalent of a match statement around them. 

* 如果被调用的函数返回**Ok()**，这只是**提取该值并继续**。 If the called function returns Ok(), this simply extracts that value and continues. 
* 但是，如果被调用的函数**返回一个错误，那么它就执行一个返回语句来进一步传播这个错误**。 But, if the called function returns an error, then it executes a return statement to propagate that error further. 
  * 例如，如果open_database()调用返回一个显示错误的结果，该调用的注释将**导致load_document()函数在这一点上返回，将错误传递给其调用者**。 For example, if the open_database() call returns a result indicating an error, the annotation on the call will cause the load_document() function to return at that point, passing the error up to its caller. 
* 这和抛出一个异常有同样的效果，**错误在调用堆栈中一路向上，直到它遇到一个处理它的匹配语句，或者直到它到达main()，在这种情况下，如果错误没有被处理，程序会被干净地中止**。 This has the same effect as throwing an exception, with the error working its way up the call stack until it either hits a match statement that handles it, or until it reaches main(), in which case the program is cleanly aborted if the error is not handled.

# 规避反模式-String：Features & Response Codes

![](/static/2022-02-16-18-02-55.png)

Rust中的选项和结果类型是非常有用的，有助于在编译时发现常见的问题。**枚举类型**对于编码与问题领域相关的设计属性也很有用。它们通常可以用来帮助**避免系统设计中常见的反模式**。The option and result types in Rust are very useful, and help detect common problems at compile time. Enum types are also useful to encode properties of the design that relate to the problem domain. They can often be used to help avoid common anti-patterns in system design. 

这些反模式中的第一个就是所谓的String类型。**字符串类型是指方法参数、返回类型和数据值被编码为非结构化的字符串**，而不是一些更合适的类型。The first of these anti-patterns is known as string typing. String typing is where method parameters, return types, and data values are coded as unstructured strings, rather than as some more appropriate type. 

* 例如，这是从一些网络操作中**返回的字符串，如HTTP响应代码，被直接用于程序的其余部分，而不是被转换为一些结构化的内部表示**。For example, it’s the case where strings returned from some network operation, such as HTTP response code, are used directly in the rest of the program, rather than being converted to some structured internal representation. 
* 通过使用枚举，我们可以**用一种结构化的方式来表示这样的数据**，它可以取几个可能的值之一。这有一些（开发）开销，因为我们**必须定义代表不同状态的枚举，并将字符串表示转换为内部格式，但提供了一些很好的属性。它可以进行穷举检查**。By using an enum, we can represent data such as this, that can take one of several possible values, in a structured way. This has some overhead, because we must define the enum that represents the different states, and convert the string representation into the internal format, but provides some nice properties. It enables exhaustiveness checking. 
* **我们可以确保我们的代码可以处理所有可能的值。而且我们可以确保编译器会捕捉到我们遗漏的任何情况，如果新的值被引入，代码需要更新以处理它们**。We can be sure our code handles all possible values. And we can be sure the compiler will catch any cases we miss, if new values are introduced and the code needs to be updated to handle them. 
* 我们获得了**重构的便利性**，因为**内部代码与外部表示解耦，而且我们使无意义的值无法表示**。只有**编码到枚举中的值可以在内部传递，无效的值不能从系统的其他部分泄漏到我们的程序中**。We get ease of refactoring, since the internal code is decoupled from the external representation And we make nonsensical values unrepresentable. Only the values encoded into the enum can be passed around internally, and invalid values can’t leak into our program from the rest of the system. 
* 本质上，**类型提供了一个对编译器也有意义的表示和文件，并且可以被编译器检查**，而字符串类型只对程序员有意义。Essentially, the types provide a representation and documentation that’s also meaningful to, and can be checked by, the compiler, whereas the string types are only meaningful to the programmer.

# 规避反模式-boolean Flags

![](/static/2022-02-16-18-30-11.png)

第二个反模式是过度使用布尔标志。**使用布尔标志作为函数的参数会掩盖意义**。The second anti-pattern is over-use of boolean flags. The use of boolean flags as arguments to function obscures meaning. 

* 比较幻灯片上的两个例子。第一个例子，调用file.open()，并传入一个文件名和两个标志，一个是真，一个是假。Compare the two examples on the slide. The first, calls file.open(), and passes in a filename and two flags, one true and one false.
  * **这些标志的含义是完全隐藏的**，除非你记住了open()函数的文档。What those flags mean is entirely hidden, unless you’ve memorised the documentation for the open() function. 
* 第二个变体执行同样的操作，但这次的参数被**编码为枚举类型而不是布尔**。第一个参数是一个枚举，值为**TextMode和BinaryMode**，第二个是一个枚举，值为**ReadOnly和ReadWrite**。 The second variant performs the same operation, but this time the arguments are encoded as enums rather than booleans. The first argument is an enum with values TextMode and BinaryMode, and the second is an enum with values ReadOnly and ReadWrite. 
  * **底层逻辑是相同的，但类型使行为更加明显。它们对程序员来说更容易阅读。而且它们允许编译器检查参数是否被正确传递**。The underlying logic is the same, but the types make the behaviour more obvious. They’re easier for the programmer to read. And they allow the compiler to check that the arguments are passed correctly. 
* 在第一个版本的代码中，**使用布尔参数，如果程序员不小心调换了参数，那么代码的编译会很顺利，但在运行时就会失败**。 In the first version of the code, with the boolean arguments, if the programmer swaps the arguments by accident, then the code will compile fine, but fail at runtime. 
* **在使用枚举的版本中，代码更加明显，而且如果参数的传递顺序不对，代码也不会被编译，因为类型不匹配**。幻灯片上列出的博文更详细地讨论了这个想法。 In the version using enums, the code is both more obvious, and won’t compile if the arguments are passed in the wrong order, because the types won’t match. The blog posts listed on the slide talk about this idea in more detail.

# Summary：类型系统建模问题域

![](/static/2022-02-16-18-37-46.png)

类型驱动设计的基本思想是使用类型系统来描述系统设计的特征，所以编译器可以帮助检查它们的正确性。当然，这有一个前期的成本。你需要定义这些类型。这样做的好处是，当程序失败时，修复编译错误比修复沉默的数据损坏要容易。对于小系统来说，这个成本可能超过了好处。但是，对于大型系统来说，由于使用了类型，编译器强制执行的一致性检查可能是一个重要的胜利。 The fundamental idea of type driven design is to use the type system to describe features of the system design, so the compiler can help check them for correctness. There’s an up-front cost, of course. You need to define the types. The benefit is that fixing compilation errors is easier than fixing silent data corruption, when the program fails. For small systems, the cost may outweigh the benefit. But, for large systems, compiler enforced consistency checks due to use of types can be a significant win.

# ==========

# 3-状态机：State-Machines

本讲座的第3部分讨论了如何实现状态机。状态机在设备驱动和网络协议的实现中被广泛使用，因此能够在系统程序中**干净地表达**它们是很重要的。本讲座回顾了两种方法，**一种是使用枚举实现，一种是使用结构类型**，并讨论了它们**之间的权衡**。The 3rd part of the lecture discusses how state machines can be implemented. State machines are widely used in the implementation of device drivers and network protocols, so it's important to be able to express them cleanly in systems programs. The lecture reviews two ways of doing this, one implemented using enumerations, one using structure types, and discusses the trade-offs between them.

# 状态机：State Machines

![](/static/2022-02-16-18-44-20.png)

**状态机在系统代码中很常见**。它们经常被用来表示网络协议、文件系统、设备驱动等的行为。State machines are common in systems code. They’re frequently used to represent the behaviour of a network protocol, file systems, device drivers, and so on. 

* **它们将系统的行为建模为一组反映系统状态的状态，由事件触发的这些状态之间的转换，以及持有系统配置的状态变量**。* They model the behaviour of the system as a set of states reflecting the status of the system, transitions between those states triggered by events, and state variables that hold the system configuration. 
* 图中显示了一个例子，系统在不同的状态（黄框）之间移动，以响应事件。* The figure shows an example of this, where the system moves between different states, the yellow boxes, in response to events. 
  * 其中一些事件可能是由程序员的行为触发的，而另一些则是对外部事件和行为的响应。我们看到，系统可以通过这些状态移动，最终达到IO_RUNNING状态，也可以在不同的点上重新配置，回到IO_CONFIGURE_BEGIN状态。* Some of those events may be triggered by programmer actions, while others are in response to external events and actions. We see that the system can move through the states to eventually reach to IO_RUNNING state, or can be reconfigured at various points, returning to the IO_CONFIGURE_BEGIN state.

这个例子代表了一个网络设备驱动程序，它所做的细节并不重要。不过，重要的是这个模式。我们在许多系统中都能看到状态机。The example represents a network device driver, and the details of what it’s doing aren’t important. What matters, though, is the pattern. We see state machines in many systems.

* 代表一个以太网驱动的行为，如本例，或一个WiFi接口。* To represent the behaviour of an Ethernet driver, as in the example, or a WiFi interface.
* 代表TCP连接建立的握手过程。* To represent the TCP connection establishment handshake.
* 或者一个文件系统的状态，或者一个磁盘驱动器，或者其他一些硬件。* Or the state of a file system, or a disk driver, or some other piece of hardware. 

**将代码正规化，明确写下状态机及其各种事件和转换，并使用它来驱动实现，这通常是有用的**。And it’s often useful to formalise the code, and explicitly write down the state machine, with its various events and transitions, and use this to drive the implementation.

* **状态机抓住了系统行为的本质。它抓住了设计的高层结构**。* The state machine captures the essence of the systems behaviour. It captures the high-level structure of the design. 
* 而且它**应该很容易推理**。要证明诸如终止、没有死锁、所有状态是否可达等属性。* And it should be easy to reason about. To prove properties such as termination, absence of deadlocks, whether all states are reachable, and so on.

# 状态机实现：Implementing State Machine

![](/static/2022-02-16-18-55-04.png)

在代码中**干净地实现状态机是很困难的**。 That said, it can be difficult to cleanly implement state machines in code. 

* **代码的结构往往与状态机的结构不一致，而且往往不容易理解系统处于什么状态，也不容易将转换过程可视化**。* The structure of the code often tends not to match the structure of the state machine, and it’s often not easy to understand what state the system is in, or to visualise the transitions. 
* 这些信息往往被编码在**可变的状态变量**中，**隐藏在大量的条件操作中**，并分布在代码中。这使我们**很难根据规范来验证代码。这使得检查状态机变得很困难**。* This information is often encoded in mutable state variables, hidden in a mass of conditional operations, and spread throughout the code. This makes it difficult to validate the code against the specification. It makes it difficult to check the state machine. 
* 最近，我们开始看到**用强类型的函数式语言对状态机进行建模的新方法。这些方法使代码更清晰，并使状态机更明显**。* Recently, though, we’ve started to see new approaches to modelling state machines in strongly-typed functional languages. These make the code clearer, and make the state machine more obvious. 
  * **他们将状态和事件编码为枚举，并对状态事件tuple进行模式匹配。或者它们将状态编码为类型，将转换编码为函数**。* They encode states and events as enumerations, and pattern match on state-event tuples. Or they encode states as types, and transitions as functions. 
  * 或者他们**在语言和运行时中加入一流的状态机支持**。* Or they add first-class state machine support to the language and to its runtime. 
    * 后者显示在右边，是来自微软研究院的一篇关于Singularity操作系统的论文的代码片段。这也是异步代码所采取的方法，通常用于并发，我们将在第8讲中谈论这个问题。This latter is shown on the right, and is a code fragment taken from a paper about the Singularity operating system from Microsoft Research. It’s also the approach taken by asynchronous code, often used for concurrency, that we’ll talk about in Lecture 8.

# 状态机建模法-枚举: Enumerations for modelling state machines

![](/static/2022-02-16-19-18-35.png)

有两种可能的状态机实现策略可以利用这些洞察力，并且可以在Rust中使用。There are two possible state machine implementation strategies that leverage these insights and can be used in Rust.

第一种是**使用枚举类型**，即枚举，来**表示状态和事件**，并**使用函数来表示状态转换和动作**。The first is to use enumerated types, enums, to represent the states and the events and to use functions to represent state transitions and actions.

* 在这种方法中，你定义一个**枚举类型来表示所有可能的状态，另一个枚举类型来表示所有可能的事件**。 In this approach you define one enum type to represent all the possible states, and another to represent all the possible events. 
* 你定义了**一个函数**，它**接收一个状态和事件的元组，并返回下一个状态，对状态转换进行编码。你还定义了一个函数来表示在每个转换过程中执行的行动**。You define a function that takes a tuple of state and event, and returns the next state, encoding the state transitions. And you define a function to represent the action performed on each transition. 

这种方法**建立在枚举类型表达备选方案的直觉上**。还有一个想法是，状态机是一组替代状态，这些状态之间的转换驱动着一组可能的事件。This approach builds on the intuition that enum types express alternatives. And the idea that a state machine is a set of alternative states with transitions between those states driven a set of possible events.

## 例子：Using enum to Model State Machines

![](/static/2022-02-16-19-24-18.png)

你首先要**定义代表状态和事件的枚举**。You start by defining the enums that represent the states and the events.

* 在这个例子中，代表状态的枚举是ApcState枚举，而代表事件的枚举是ApcEvent枚举。这个系统的模型是什么并不重要，但是我们**从ApcState中看到，它涉及到连接、TcpStream对象，以及可以在这些连接上发送和接收的消息**。它是某种网络协议。我们看到，**对于一个网络系统来说，该系统有一套典型的状态。它可以被初始化、等待连接、接受连接、接收消息、关闭连接**，等等。* In this example, the enum representing the states is enum ApcState, and that representing the events is the ApcEvent enum. What the system is modelling isn’t really important, but we see from ApcState that it involves connections, TcpStream objects, and messages that can be send and received on those connections. It’s a network protocol of some sort. And we see that the system has a typical set of states for a networked system. It can be initialised, waiting for connections, accepting connections, receiving messages, closing a connection, and so on. 
* 同样，在ApcEvent枚举中，我们看到一个**联网系统的典型事件集**。一个TCP连接已经连接。一个消息已经被接收。一些响应是有效的。**以此类推。状态和事件都被编码为枚举，这些枚举的参数持有提供额外背景的状态变量**。* Similarly, in the ApcEvent enum, we see a typical set of events for a networked system. A TCP connection has connected. A message has been received. Some response is valid. And so on. Both the states and the events are encoded as enums, with parameters to those enums holding state variables that provide additional context.

---

![](/static/2022-02-16-19-28-54.png)

在定义了代表状态和事件的枚举后，你**定义一个在状态之间映射的函数**。Having defined the enums representing the states and events, you define a function that maps between states. 

* 在这个例子中，这个函数是一个方法，**next()，在ApcState枚举中实现。它的参数是self，一个代表当前状态的ApcState枚举的实例，以及一个ApcEvent对象的实例**。* In the example, this function is a method, next(), implemented on the ApcState enum. Its parameters are self, an instance of an ApcState enum representing current state, and an instance of an ApcEvent object. 
* 该函数模式**在self、当前状态和发生的事件的元组上匹配**，并**返回一个新的ApcState实例**。* The function pattern matches on the tuple of self, the current state, and the event that occurred, and returns a new ApcState instance. 
  * 我们看到该函数的主体是一个表，与（状态，事件）元组匹配，直接编码状态转换。* We see that the body of the function is a table, matching the (state, event) tuples, that directly encodes the state transitions. 
  * 状态和事件的元组与系统可能处于的状态列表以及在这些状态下可能发生的事件相匹配，并评估为一个新的ApcState对象的实例，由函数返回。* The tuple of state and event is matched against a list of states the system can be in, and the events that can occur in those states, and evaluates to a new instance of an ApcState object, that’s returned by the function. 
  * 如果没有匹配，那么匹配语句末尾的catch-all将被删除，系统将失败。**这给出了一个非常简洁的状态转换表，很容易根据规范进行验证**。* In there’s no match, the catch-all at the end of the match statement is taken, and the system fails. This gives a very clean representation of the state-transition table, that’s easy to validate against the specification. 
* 重要的是，**next()函数取得了self的所有权**。也就是说，参数是self而不是&self。正如我们稍后将看到的，**这意味着它消耗了状态，并返回新的状态，强制过渡发生**。* Importantly, the next() function takes ownership of self. That is, the parameter is self rather than &self. As we’ll see later, this means it consumes the state, and returns the new state, enforcing that the transition occurs.

---

![](/static/2022-02-16-19-46-21.png)

代表**状态和事件的枚举，以及在状态之间进行映射的状态转换函数**，被**汇集**到一个代表状态机本身的**新结构**中。The enums representing the states and events, and the state transition function that maps between the states, are brought together in a new struct representing the state machine itself.

* 在这个例子中，**ApcStateMachine结构持有当前状态和系统运行所需的任何额外数据**。在这个例子中，是一个SocketAddr和一个超时。* In this example, the ApcStateMachine struct holds the current state and any extra data needed for the system to operate. In this case, a SocketAddr and a timeout. 
* 状态机定义了两个函数。* The state machine defines two functions. 
  * new()函数在初始状态下创建一个状态机的实例。* The new() function creates an instance of the state machine, in the initial state. 
  * run_once()函数执行当前状态的动作。它与**当前状态的值以及编码到该枚举变量的任何状态变量相匹配，并执行任何需要的处理**。**当有可能导致状态改变的事情发生时，它会返回一个描述发生了什么的事件**。* The run_once() function performs the actions for the current state. It matches on the value of the current state, and any state variables encoded into that enum variant, and performs whatever processing is needed. When something happens that could potentially cause the state to change, it returns an event that describes what happened. 
* 我们在右边看到的run_state_machine()函数显示了状态机的使用方式。它实例化了ApcStateMachine对象，然后进行循环。* The run_state_machine() function we see on the right shows how the state machine is used. It instantiates the ApcStateMachine object, and then loops. 
  * 对于**每个循环，它调用run_once()方法，以检索下一个事件。然后，它在状态上调用next()函数，检索下一个状态并将其存储到状态机结构中。如果系统进入了 "完成 "状态，它就会跳出循环。否则，它将循环并处理下一个事件**。* For each loop, it calls the run_once() method, to retrieve the next event. Then it calls the next() function on the state, retrieving the next state and storing it into the state machine struct. If the system has entered the Finish state, it breaks out of the loop. Otherwise, it loops around and processes the next event.
* **控制状态间转换所需的逻辑(`next()`**)是在代表状态和事件的**枚举参数**中。而**在每个状态下执行的操作都写在run_once()函数中的匹配语句的分支中**。* The logic needed to control the transition between states is in the parameters of the enums representing the states and events. And the operations performed in each state are written in the branches of the match statement in the run_once() function. 
  * 这样就**把在每个状态下执行的操作与管理状态转换的代码干净地分开了**。而且它干净地将状态转换逻辑编码到一个单一的函数中。这是一种非常优雅的、易于检查的表示状态机的方式。* This cleanly separates the actions to be performed in each state, from the code that manages the state transitions. And it cleanly encodes the state transition logic into a single function. It’s a very elegant, easy to check, way of representing state machines.

# 状态机建模法-结构体: Enumerations for modelling state machines

![](/static/2022-02-16-19-57-21.png)

Rust也允许用另一种方式来模拟状态机，即围绕结构类型。在这种方式中，**每个状态由一个结构来表示。事件由对这些结构的方法调用来表示**。而**状态转换**是通过**返回一个代表新状态的结构**来建模的。Rust also permits an alternative way to model state machines, based around structure types. In this alternative, each state is represented by a struct. One struct per state. Events are represented by method calls on those structs. And state transitions are modelled by returning a struct that represents the new state. 

* 这种方法建立在这样的直觉上：状态持有具体的状态，而事件是在状态中发生的事情。This approach builds on the intuition that states hold concrete state, and events are things that happen in states.

---

## 例子：Using struct to Model State Machines: Example

![](/static/2022-02-16-20-02-14.png)

本幻灯片中的代码片段展示了一个基于结构的状态机建模方法的例子。这个系统有三种可能的状态。它可以是未认证的连接、认证的连接或未连接。The code fragments on this slide show an example of the struct-based approach to modelling state machines. There are three possible states this system can be in. It can be an Unauthenticated Connection, an Authenticated Connection, or NotConnected. 

* **每个状态都由一个结构类型表示**。* Each is represented by a struct type. 
* 在这些**结构上实现了许多方法**，幻灯片显示了UnauthenticatedConnection结构的一些方法。* A number of methods are implemented on these structs, and the slide shows some of those for the UnauthenticatedConnection struct. 
  * 我们看到login()方法将该结构作为自己的参数，加上一些凭证，并尝试登录。* We see that the login() method takes the struct as its self parameter, along with some credentials, and attempts to login. 
    * 如果成功了，它返回的结果包括一个AuthenticatedConnection对象，代表新的状态。* If it succeeds, the Result it returns includes an AuthenticatedConnection object, representing the new state. 
    * 如果登录失败，它将返回一个包含当前状态和错误信息的元组。* If the login fails, it returns a tuple comprising the current state and the error message. 
  * 类似地，disconnect()方法将self作为参数，并返回一个NotConnected结构，代表系统处于断开连接的状态。* Similarly, the disconnect() method takes self as its parameter, and returns a NotConnected struct representing the system in the disconnected state. 
* **每次调用都会返回系统所处的新状态**。而且，**由于Rust的所有权规则（我们将在本讲座的最后部分讨论），它将消耗旧的状态，强制执行状态转换**。* Each call returns the new state the system is in. And, due to Rust’s ownership rules, that we’ll discuss in the final part of this lecture, it consumes the old state, enforcing the state transition.

# Summary: 权衡状态机2种表示法-Approaches to Representing State Machines

![](/static/2022-02-16-20-08-58.png)

哪种表示状态机的方法是最好的？当然，这取决于你的优先级。Which approach to representing a state machine is best? It depends on your priorities, of course.

* 基于枚举的方法是紧凑的，使**状态和事件在类型中明确，并且有一个清晰的【状态转换表**。】* The enum-based approach is compact, makes states and events clear in the types, and has a clear state transition table. 
  * **如果状态机很复杂，有许多不同的状态和转换，使得能够很容易地检查状态转换表的正确性很重要，那么它就很好**。* It’s good if the state machine is complex, with many different states and transitions, making it important to be able to easily inspect the state-transition table for correctness. 
  * 它还**依赖于具有表达式枚举类型的语言**，以允许其实现。例如，这种方法在Rust、Swift或OCaml中运行良好，但**在具有较弱枚举类型和模式匹配的语言中很难表达**。* It also relies on a language that has expressive enum type, to allow its implementation. This approach works well in Rust, Swift, or OCaml, for example, but it’s difficult to express in languages with weaker enum types and pattern matching. 
* 基于结构的方法**在类型中编码状态和状态转换，并将事件实现为这些类型的方法**。**状态转换**表在代码中不太明显，因为它被**编码在方法的返回类型**中。* The struct-based approach encodes states and state transitions in the types, and events as methods on those types. The state transition table is less obviously explicit in the code, since it’s encoded in the return types of methods, 
* <font color="deeppink">但当在Rust中实现时，所有权规则干净利落地执行了转换，并确保在新的状态中无法访问前一个状态的任何东西。这两种方法都很好用</font> * but when implemented in Rust the ownership rules cleanly enforce the transitions and ensure nothing from the previous state is accessible in the new state. Both approaches work well.

# ==========

# 4-所有权: Ownership

本讲座的最后部分讨论了所有权问题。它回顾了**Rust编程语言中允许其跟踪数据所有权的特性**，以及这些特性**与Rust中引用类型的设计之间的关系**。在第三部分的基础上，它展示了**如何利用所有权类型来改进状态机的实现**。The final part of the lecture discusses ownership. It reviews the features of the Rust programming language that allow it to track ownership of data, and how these relate to the design of reference types in Rust. Them, building on the material in the third part of the lecture, it shows how ownership types can be used to improve the implementation of state machines.

# 资源所有权管理：Ownership

![](/static/2022-02-16-21-13-58.png)

系统程序关心资源的**所有权问题**。在某种程度上，这在**实现状态机**时很重要，正如我们在本讲座的前一部分所讨论的。这对于**管理内存和管理文件、套接字、锁等资源**也很重要，我们将在第五讲中讨论。Systems programs care about ownership of resources. In part this is important when implementing state machines, as we discussed in the previous part of this lecture. It’s also important for managing memory, and for managing resources such as files, sockets, locks, and so on, as we’ll discuss in Lecture 5. 

在**管理内存等资源**时，程序员会保持一些心理模型，即代码的哪些部分拥有每个资源。When managing resources, such as memory, a programmer will maintain some mental model of what parts of the code own each resource. 

* 例如，在**C语言**中，由于采用了**手动内存管理**，程序员需要跟踪哪些函数调用malloc()来分配内存，以及这些内存在哪里被释放（）。* In languages like C, for example, with manual memory management, the programmer needs to keep track of what functions call malloc() to allocate memory, and where that memory is freed(). 
  * 对于每一个以指针为参数的C函数，程序员必须知道该函数是否会释放内存，或者是否会将其留给其他函数来释放。* For every C function that takes a pointer as an argument, the programmer has to know whether that function will free the memory, or whether it will leave it for some other function to free. 
  * 同样地，每个返回指针的C函数都必须明确该指针是否为返回它的库所拥有，并将在以后调用库的某个函数时被释放，或者是否必须由调用者释放。* Similarly, every C function that returns a pointer has to make it clear whether that pointer is owned by the library returning it, and will be freed be a later call to one of the library functions, or whether it must be freed by the caller. 
* **如果程序员有错误的理解，要么程序忘记释放内存，导致内存泄漏，要么过早地释放内存，导致未定义行为和分段故障。类似的问题也存在于其他资源的管理中，如文件描述符和套接字。必须明确由谁负责关闭文件或连接**。* If the programmer has the wrong understanding, either the program forgets to free memory, leading to a memory leak, or it frees the memory too early, leading to undefined behaviour and a segmentation fault. Similar issues exist around management of other resources, such as file descriptors and sockets. It has to be clear who’s responsible for closing the file or connection.

不同的语言试图以不同的方式解决**资源所有权的问题**。Different languages try to address the problem of resource ownership in different ways. 

* 有些语言，如**Java，使用垃圾收集器来管理资源**。这可以防止资源过早地被释放，但仍然需要程序员了解数据所有权，以便知道何时释放一个对象的引用。* Some languages, such as Java, use a garbage collector to manage resources. This prevents resources from being freed too early, but still requires the programmer to understand data ownership to know when to release a reference to an object
* 例如，**如果操作不当，这可能导致Java程序中的内存泄漏**。* This can lead to memory leaks in Java programs, if done incorrectly, for example. 

其他语言，如**C++和Python**，通过**将资源寿命与程序范围规则联系起来，简化了资源管理**。Other languages, such as C++ and Python, simplify resource management by linking resource lifetime to program scoping rules. 

* 例如，幻灯片上的代码显示了一个Python的with语句，它打开了一个文件并将其分配给一个变量，该变量在with语句的持续时间内存在。当**变量超出范围时，该对象的析构器就会关闭该文件。这是一个强大的方法，并在作用域结束时提供自动资源清理**。* For example, the code on the slide shows a Python with statement, that opens a file and assigns it to a variable that lives for the duration of the with statement. When the variable goes out of scope, the destructor for the object close the file. This is a powerful approach, and gives automatic resource clean-up at the end of the scope.

# Rust所有权：Ownership in Rust

![](/static/2022-02-18-02-05-21.png)

**跟踪代码的哪些部分正在使用堆上的哪些数据，最小化堆上重复数据的数量，以及清理堆上未使用的数据以防空间耗尽**，这些都是所有权解决的问题。**一旦理解了所有权，您就不需要经常考虑堆栈和堆**，但是知道所有权的主要目的是管理堆数据可以帮助解释为什么它是这样工作的。

---

![](/static/2022-02-16-21-27-48.png)

Rust采取了一种不同的、更全面的方法来管理资源。**Rust编译器和类型系统跟踪程序中所有数据的所有权**。它**强制要求程序中的每个值在任何时候都有一个单一的所有者**。为了做到这一点，Rust的类型系统**定义了关于函数和方法调用中数据所有权转移的规则**。有三种情况。Rust takes a different, and more comprehensive, approach to managing resources. The Rust compiler and type system tracks ownership of all data in a program. It enforces that every value in the program has a single owner at all times. To do this, Rust’s type system defines rules about the transfer of ownership of data in function and method calls. There are three cases. 

* ![](/static/2022-02-18-02-10-41.png)
* 在第一种情况下，**一个函数通过值传递一个参数，就会取得该值的所有权**。我们在幻灯片上的consumer()函数中看到了这一点，**该函数将一个资源r作为其参数传递，并取得了该资源的所有权**。* In the first Zase, a function that’s passed a parameter by value will take ownership of that value. We see this in the consume() function on the slide, that’s passed a resource, r, as its parameter, and takes ownership of that resource. 
  * 一旦consume()函数被调用，**调用者就不能再访问该资源，一旦函数完成，该资源就被释放。该函数消耗了该资源**。* The resource is no longer accessible to the caller once the consume() function has been invoked, and is freed once the function completes. The function consumes the resource. 
  * ![](/static/2022-02-16-21-47-39.png)
* 在第二种情况下，**一个函数通过引用传递一个参数。这被称为 "租借**"。* In the second case, a function is passed a parameter by reference. This is known as borrowing a value. 
  * 当一个参数以这种方式被借用时，资源的所有权仍然属于调用者。函数可以在调用过程中使用它所借用的资源，但不能再使用(不能修改)。**当函数返回时，调用者仍然有对资源的访问和所有权**。这意味着借用资源的结构上的方法不能在结构中存储对该资源的引用，以便在函数返回时访问。如果你想保留对资源的引用，你必须消耗它而不是借用它。* When a parameter is borrowed in this way, ownership of the resource remains with the caller. The function can use the resource it’s borrowed for the duration of the call, but no longer. And when the function returns, the caller still has access to, and ownership of, the resource. This means that a method on a struct that borrows a resource can’t store a reference to that resource in the struct, for access once the function returns. If you want to keep a reference to a resource, you must consume it rather than borrowing it. 
  * 幻灯片上的borrow()示例函数需要一个不可变的资源引用，**这允许它读取资源，但不能修改它**。**借用也适用于可变的引用，写成&mut**，前提是第3讲中讨论的关于引用的约束条件成立。The borrow() example function on the slide takes an immutable reference to the resource, that allows it to read the resource but not modify it. Borrowing also works with mutable references, written &mut, provided the constraints on references discussed in Lecture 3 hold.
  * 引用不会获得值的所有权。
  * 引用只能租借（Borrow）值的所有权。
  * 引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权：
  * ![](/static/2022-02-16-21-40-44.png)
  * ![](/static/2022-02-16-21-41-55.png)
  * ![](/static/2022-02-16-21-43-02.png)
  * ![](/static/2022-02-16-21-49-07.png)
  * ![](/static/2022-02-16-21-50-34.png)
* 最后一种情况是，**一个函数可以返回一个值的所有权**。* The final case is that a function can return ownership of a value.
  * 在这种情况下，**函数将资源交给它的调用者，使调用者负责释放该资源**。当**函数或方法**以这种方式**放弃所有权时，不能保留对该资源的任何引用**。* In this case, the function gives the resource to its caller, making the caller responsible for freeing that resource. The function or method cannot retain any references to the resource when it gives up ownership in this way.
  * ![](/static/2022-02-16-21-48-29.png)

## 例子

![](/static/2022-02-16-22-06-43.png)

这个代码示例展示了Rust中所有权的关键特征。函数main()创建了一个资源，并将其存储在一个局部变量r中。然后它将该资源传递给consumer()函数，该函数取得了该资源的所有权。This code sample show the key features of ownership in Rust. The function main() creates a resource, and stores it in a local variable, r. It then passes that resource to the consume() function, that takes ownership of the resource.

* 也就是说，它将资源的值传递给了该函数。然后main()函数试图打印资源的值r。如果你试图编译和运行这段代码，你会发现它无法编译。主函数 * That is, it passes the resource by value to the function. The main() function then tries to print the value of the resource, r. If you try to compile and run this code, you’ll find that it doesn’t compile. The
* **consume()函数取得了资源的所有权，并没有把它传回给调用者。因此，当consumer()函数返回时，资源被解配。由于它把资源的所有权交给了consumer()函数，此后main()函数就无法访问该资源了**。* consume() function takes ownership of the resource, and doesn’t pass it back to the caller. Accordingly, when the consume() function returns, the resource is deallocated. Since it gave ownership of the resource to the consume() function, the main() function has no access to that resource thereafter. 
* 因此，println!()调用失败了：main()放弃了资源，不再有访问权，所以它不能打印它。**如果main()函数调用borrow()函数，如上一张幻灯片所定义的，而不是consumer()，那么这段代码就会被编译和运行。借用其参数的函数在结束时将其归还。而消耗其参数的函数则不会**。* The println!() call therefore fails: main() gave away the resource and doesn’t have access anymore, so it can’t print it. If the main() function called the borrow() function, as defined on the previous slide, instead of consume(), then the code would compile and run. A function that borrows its argument gives it back when it concludes. One that consumes its argument does not.

## 所有权传给函数：Ownership->Functions

![](/static/2022-02-18-02-36-03.png)

## 函数返回所有权：Return Value and Scope

返回值也可以转移所有权。清单4-4显示了一个函数的示例，该函数返回一些值，其中包含与清单4-3中相似的注释。

![](/static/2022-02-18-02-37-52.png)

---

![](/static/2022-02-18-02-39-19.png)

如果我们**想让一个函数使用一个值而不是获得所有权**，那该怎么办？如果我们想再次使用它，除了我们可能想要返回的函数体产生的任何数据之外，我们传入的任何内容都需要被传回，这是相当恼人的。

* 租借引用

## 租借引用：References and Borrowing

![](/static/2022-02-18-02-40-54.png)
![](/static/2022-02-18-02-41-40.png)
![](/static/2022-02-18-02-43-13.png)

---

禁止修改不可变引用（正如变量在默认情况下是不可变的，引用也是如此。我们不允许修改我们有引用的东西。

![](/static/2022-02-18-02-44-00.png)

## 可变引用：Mutable Reference

![](/static/2022-02-18-02-45-09.png)
![](/static/2022-02-18-02-46-46.png)
![](/static/2022-02-18-02-48-51.png)

* 可变引用同一个scope中只能唯一
  * ![](/static/2022-02-18-02-50-26.png)
* 可以有多个不可变引用
  * ![](/static/2022-02-18-02-52-48.png)
* 可变引用&不可变引用不能同时存在【Non-Lexical Lifetimes (NLL for short)】
  * ![](/static/2022-02-18-02-51-14.png)
  * ![](/static/2022-02-18-02-53-16.png)
* 不能对不可变变量进行可变引用，可变变量可以有不可变引用
* 优点
  * data races
    * 数据竞争会导致数据未定义行为，当你试图在运行时跟踪数据竞争时很难诊断和修复; **Rust 通过拒绝编译带有数据竞争的代码来防止这个问题**！

# String类型-堆&所有权例子

![](/static/2022-02-18-02-15-04.png)
![](/static/2022-02-18-02-15-56.png)

---

![](/static/2022-02-18-02-17-31.png)

* 很强大，但需要注意多个堆变量的场景

---

![](/static/2022-02-18-02-19-13.png)
![](/static/2022-02-18-02-20-39.png)
![](/static/2022-02-18-02-20-59.png)
![](/static/2022-02-18-02-22-34.png)
![](/static/2022-02-18-02-23-43.png)
![](/static/2022-02-18-02-24-25.png)

* Rust防止了两次free
* 移动 - move

# 移动 vs 拷贝：move & clone

![](/static/2022-02-18-02-23-43.png)
![](/static/2022-02-18-02-24-25.png)
![](/static/2022-02-18-02-25-36.png)

# Copy traits-栈数据拷贝：Stack-Only data copy

![](/static/2022-02-18-02-31-46.png)
![](/static/2022-02-18-02-32-14.png)

基本类型？编译时期已知的？（可以快速复制，不会失效）

![](/static/2022-02-18-02-29-40.png)

# 状态机&所有权：State Machines & Ownership

![](/static/2022-02-16-22-11-14.png)

正如我们在本讲座的前一部分看到的，状态机管理资源。As we saw in the previous part of this lecture, state machines manage resources. 

* 一个代表网络协议的状态机管理连接和通过它们发送的数据。代表设备驱动程序的状态机管理着设备的硬件。以此类推。* A state machine representing a network protocol manages connections and the data sent over them. A state machine representing a device driver manages the hardware of the device. And so on. 
* **状态转换表示资源所有权的变化。它们表明一些事件已经发生，系统必须转移到一个新的状态，可能会消耗或释放旧状态所持有的资源，或保留它们供新状态使用**。这与Rust中的所有权规则很自然地契合。* State transitions indicates changes to resource ownership. They indicate that some event has occurred, and that the system must move to a new state, potentially consuming or releasing resources held by the old state, or keeping them for use by the new state. This is a natural fit for the ownership rules in Rust.

---

基于结构体状态机 - 状态转换所有权

![](/static/2022-02-16-22-22-24.png)

如果我们回想一下我们在本讲座前一部分看到的基于结构的状态机编写方法，我们会发现它使用Rust的所有权规则来执行干净的状态转换。If we think back to the struct-based approach to writing state machines, that we saw in the previous part of this lecture, we see that it uses Rust’s ownership rules to enforce clean state transitions. 

* 在这种方法中，每个状态由一个结构表示，而状态转换则由在该结构上实现的方法表示。* In this approach, each state is represented by a struct, and state transitions are represented by methods implemented on that struct. 
* 重要的是，**这些方法对结构具有所有权**。也就是说，它们会**消耗它们要转换的状态，确保不再有对该状态的引用，并且释放它们没有明确返回的任何资源。然后过渡方法返回一个代表新状态的值的所有权，其中包括需要保留的前一个状态的任何值**。* Importantly, those methods take ownership of the struct. That is, they consume the state they’re transitioning away from, ensuring there are no more references to that state and any resources they don’t explicitly return are freed. The transition methods then return ownership of a value representing the new state, populated with any values that need to be retained from the previous state. 
  * 例如，UnauthenticatedConnection结构的login()方法会消耗该结构，成功后会创建并返回一个新的AuthenticatedConnection结构的所有权。* For example, the login() method of the UnauthenticatedConnection struct consumes the struct, and creates and returns ownership of a new AuthenticatedConnection struct on success. 
  * **login()方法明确地将任何需要保留的数据复制到其返回的新结构中**；**没有复制过来的状态被释放**。* The login() method explicitly copies any data that needs to be retained to the new struct it returns; state that isn’t copied over is released.
  * **如果login()方法失败，它会返回一个由错误和self值组成的元组。也就是说，在获得了self的所有权后，当失败发生时，它会将其传回给调用者**。这使得对象在**出错的情况下**保持活力：**旧的状态变成新的状态**。 If the login() method fails, it returns a tuple comprising an error and the value of self. That is, after taking taken ownership of self, it passes it back to the caller when a failure occurs. This keeps the object alive if something goes wrong: the old state becomes the new state.

## 使用struct,enum状态机所有权对比

![](/static/2022-02-16-22-33-29.png)

那么，这就是**基于结构**的状态机方法的优势。This, then, is the advantage of the struct-based approach to state machines. 

* 它使用Rust的**所有权规则来强制执行状态转换，并保证在状态转换发生时对资源进行清理**。基于结构的状态机管理方法**有利于确保所有资源在使用后被清理**。如果你的状态**机管理着复杂的资源集，在每个状态下使用的资源集都不一样，那就更好**。* It uses Rust’s ownership rules to enforce state transitions, and to guarantee that resources and cleaned-up when state transitions occurs. The struct-based approach to managing state machines is good for ensuring that all resources are cleaned-up after use. It’s better if your state machine manages a complex set of resources, where the set of resources used in each state differs. 

基于**枚举的状态机方法使状态转换图更清晰，但更依赖于程序员的纪律来管理和清理资源**。The enum-based approach to state machines makes the state transition diagram clearer, but relies more on programmer discipline to manage and clean-up resources.

# Recap-类型驱动开发：Type driven development

类型驱动的开发是一种结构化开发过程的方法，强调使用类型系统来确保设计的正确性。Type-driven development is an approach to structuring the development process that emphasises use of the type system to ensure the design is correct. 

* 它允许你逐步调试设计，并且随着代码的发展也调试实现，使用编译器作为模型检查器来确保一致性。* It allows you to incrementally debug the design, and as the code develops also the implementation, using the compiler as a model checker to ensure consistency. 

![](/static/2022-02-16-22-36-20.png)

在类型驱动的设计中，你首先要做的是定义类型。你定义特定的数字类型来代表不同种类的数字值和标识符，你的代码将与之打交道。你定义枚举类型来表示替代物，并表示可选的值、结果和错误。In type-driven design, you proceed by defining the types first. You define specific numeric types to represent the different sorts of numeric values and identifiers your code will work with. You define enum types to represent alternates, and to indicate optional values, results, and errors

---

![](/static/2022-02-16-22-38-09.png)

* 以类型为指导，你**编写函数。编写输入和输出类型--函数原型**--并运行编译器来检查设计的一致性。Using the types as a guide, you write the functions. Write the input and output types – the function prototypes – and run the compiler to check the design for consistency.
* 然后，**以类型的结构为指导，逐步实现这些函数**，一块一块的。 Then, gradually implement the functions, piece by piece, using the structure of the types as a guide. 
* **使状态机明确化。并考虑数据的所有权，以及它如何在函数之间和状态机周围传递**。Rust的**所有权规则和编译器将帮助你检查这是否正确和一致**。* Make the state machine explicit. And think about ownership of the data, and how it’s passed between function and around in state machines. The Rust ownership rules, and the compiler, will help you check that this is being done correctly and consistently.

---

![](/static/2022-02-16-22-40-28.png)

* **根据需要完善和编辑类型和函数**。Refine and edit the types and functions as necessary.
* **将编译器作为一个工具来帮助你调试你的设计**。重要的是，**不要把类型看成是对代码的检查，要把它们看成是解决方案的一个计划、一个模型--作为机器检查的文件**。在你**运行你的代码之前，把编译器作为一个工具来调试你的设计**。 Use the compiler as a tool to help you debug your design. Importantly, don’t think of the types as checking the code, think of them as a plan, a model, for the solution – as machine checkable documentation. Use the compiler as a tool to debug your design, before you run your code.

# typestate

![](/static/2022-02-18-16-43-38.png)
![](/static/2022-02-18-16-44-29.png)

# phantom types结合类型移动

phantom types没有字段的结构体（值不重要）

![](/static/2022-02-18-17-27-57.png)
![](/static/2022-02-18-17-28-28.png)

* 强制想要的状态转移

# ==========

# Readings

1. https://www.luu.io/posts/dont-use-booleans/
2. https://wiki.c2.com/?UseEnumsNotBooleans
3. https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html
4. https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
5. https://doc.rust-lang.org/book/ch15-00-smart-pointers.html

# =========

# Content

本讲座开始讨论现代编程语言中资源所有权和内存管理的各种选择。它讨论了**运行中的程序如何在内存中排列**，并概述了**自动内存管理的必要性**。然后，它讨论了两种内存管理方法：**引用计数和基于区域的内存管理**，考虑了它们的各种成本和好处。**Rust中使用的基于区域的方法**被证明有几个重要的好处，即高效和确定的内存管理，但代价是使某些类别的程序表达更加复杂。This lecture begins to discuss the various options available for resource ownership and memory management in modern programming languages. It discusses how running programs are arranged in memory, and outlines the need for automatic memory management. It then discusses two approaches to memory management: reference counting and region-based memory management, considering their various costs and benefits. The region-based approach used in Rust is shown to have several important benefits, in terms of efficient and deterministic memory management, but at the cost of making certain classes of program more complex to express.

# 1-内存存储结构：Memory

本讲座的第一部分回顾了**进程在内存中的存储**，以及**运行中的进程中存在哪些不同类型的内存**，作为讨论自动内存管理的前奏。它还讨论了**内存不安全的行为如何通过缓冲区溢出攻击导致安全漏洞**。 The first part of this lecture reviews of a process is stored in memory, and what different types of memory exist within a running process, as a prelude to the discussion of automatic memory management. It also discusses how memory-unsafe behaviour can lead to security vulnerabilities through buffer overflows attacks.

# 内存中的进程布局: Layout of a Processes in Memory

![](/static/2022-02-16-22-56-07.png)

要了解内存管理，你必须首先了解需要管理的内存是什么。**在所有的现代操作系统中，每个进程都有一个【虚拟地址空间】，它在其中执行**。To understand memory management, you must first understand what memory needs to be managed. In all modern operating systems, every process is given a virtual address space in which it executes.

* **每个进程都认为它是机器上唯一运行的进程，并且可以访问全部的内存地址**。底层硬件将这些**虚拟地址转化为物理地址**，代表真实内存中的特定位置，并**确保不同进程之间相互隔离**。* Each process thinks it’s the only one running on the machine, and has access to the full range of memory addresses. The underlying hardware translates these virtual addresses into physical addresses that represent particular locations in real memory, and makes sure that the different processes are isolated from each other. 
* **一个进程所看到的虚拟地址空间被分为几个不同的部分**。* The virtual address space that a process sees is divided into several different parts. 
  * 在内存的底部，从最低编号的地址开始，坐落着**程序文本本身：代表运行程序的机器运行**。* At the bottom of memory, starting with the lowest numbered address sits the program text itself: the machine runs that represents the running program. 
  * 紧接着是**静态数据和任何全局变量的空间**。* That’s immediately followed by the static data and space for any global variables. 
  * 接下来是**堆**：使用malloc()或类似机制分配的内存。。* Following this in memory is the heap: memory allocated using malloc(), or similar mechanisms.
  * 之后是**用于保存共享库和内存映射文件的内存** Following that is the memory used to hold shared libraries and memory mapped files. 
  * 然后是**栈空间**，从用户可访问内存的顶部开始向下增长。 * Then the stack space, growing down from the top of user accessible memory. 
    * **自顶向下**
  * 然后，最后，**操作系统内核本身占据了地址空间的顶端部分**。* Then, finally, the operating system kernel itself occupies the top part of the address space.

分配给这些**内存的数量**，以及**每个内存位于哪些虚拟地址之间**，取决于你的**机器是32位还是64位，也取决于你运行的是什么操作系统**。但所有的系统都遵循相同的基本方法。How much memory is allocated to each of these, and what virtual addresses each sits between, depend on whether you have a 32-bit or a 64-bit machine, and on what operating system you’re running. But all the systems follow the same basic approach.

# 程序文本、数据和 BSS：Program Text, Data, and BSS

![](/static/2022-02-16-23-07-00.png)

**程序文本、数据和全局变量占据了地址空间的最低部分**。这有四个部分。The program text, data, and global variables occupy the lowest part of the address space. There are four parts to this.

* 最底层的**内存页（保留页**)，通常是从**地址0开始的前4096字节，是保留的**。* The very lowest page of memory, usually the first 4096 bytes starting at address zero, is reserved. 
  * 在C语言中，一个**空指针由地址0代表**，所以**硬件虚拟内存控制器被编程为禁止访问该地址，以及相邻的地址，作为一种捕获空指针解除引用的方式**。* In languages like C, a null pointer is represented by address zero, so the hardware virtual memory controller is programmed to prohibit access to that address, and to adjacent addresses, as a way of trapping null-pointer dereferences.
    * **试图访问这块内存将被操作系统捕获，它将以违反分段的错误杀死该进程**。 Trying to access this memory will trap into the operating system, which will kill the process with a segmentation violation error.
* 在这个保留页之后，是**编译后的程序文本**。也就是说，代表**程序的机器代码**。它占据了**地址空间的最低部分，就在地址0上方开始**。* Following this reserved page, sits the compiled program text. That is, the machine code representing the program. This occupies the lowest part of the address space, starting just above address zero.
* 接下来是**数据段**。这包括**字符串字面和静态全局变量**。* Next comes the data segment. This comprises string literals and static global variables.
  * 数据和全局变量的**值在编译时是已知的**。这些数据和全局变量与可执行的机器代码一起**存储在编译后的二进制文件中，并在程序文本之后加载到内存中**。 Data and global variables where the value is known at compile time. These are stored in the compiled binary, along with the executable machine code, and loaded into memory following the program text. 
* 然后，为**BSS段**分配空间。
  * 这为**程序中定义的未初始化的全局变量提供保留空间**。BSS这个名字代表了 "由符号启动的块"，是一个历史遗留问题。* Then, space is allocated for the BSS segment. This provides reserved space for uninitialised global variables defined in the program. The name BSS stands for “block started by symbol”, and is a historical relic. 
* **程序文本和数据段是固定的。它们包括编译后的程序代码和编译时已知的数据**。同样，**BSS段的大小也是在编译时已知的**。The program text and data segments are fixed. They comprise the compiled program code and data known at compile time. Similarly, the size of the BSS segment is known at compile time.

---

* 在**旧的操作系统**中，程序和数据总是从**内存的起始处的一个固定位置开始**。* In older operating systems, the program and data always start at a fixed location at the start of the memory. 
* 在现代系统中，它们**仍然在内存的【起始位置附近加载**】，但每次**程序运行时实际的起始地址是随机的**。* In modern systems, they’re still loaded near the start of the memory, but the actual starting address is randomised each time the program runs. 
  * 为什么是随机的？这是一种安全措施。这**使得作为缓冲区溢出攻击的一部分执行的代码更难调用程序的其他部分，因为它不知道它们在内存中的位置**。* Why is it randomised? It’s a security measure. It makes it harder for code executed as part of a buffer overflow attack to call into other parts of the program, since it can’t know where they’ll be located in memory.

# 栈：The Stack

存储在堆栈上的所有数据必须具有已知的固定大小。在编译时具有未知大小或可能更改的大小的数据必须存储在堆上。

推入堆栈比在堆上分配更快，**因为分配器从不需要搜索存储新数据的位置; 该位置始终位于堆栈的顶部**。相比之下，在堆上分配空间需要做更多的工作，因为分配器必须首先找到一个足够大的空间来保存数据，然后执行簿记，为下一次分配做准备。

访问堆中的数据比访问堆栈中的数据慢，因为必须遵循指针才能到达堆栈。当代处理器如果在内存中跳动较少，速度会更快

* 出于同样的原因，如果处理器处理的数据与其他数据相近(比如它在堆栈上) ，而不是更远(比如它在堆上) ，那么处理器的工作就会更好。在堆上分配大量空间也需要时间。


---

![](/static/2022-02-16-23-17-53.png)

当一个程序执行时，它需要**空间来容纳函数参数、返回地址和局部变量。这些都存储在栈中**。As a program executes, it needs space to hold the function parameters, return addresses, and local variables. These are stored on the stack.

* **栈占据了用户可访问内存的顶部**，为了安全起见，栈**从一个【随机地址】开始，并向下增长**。* The stack occupies the top of user accessible memory, starting at a random address for security, and grows downwards. 
* **每次调用一个函数，从main()开始，该函数的参数、返回地址和一个指向上一个栈帧的指针被推到堆栈上**。它们占据了堆栈前一个栈帧下面的下一个地址。* Each time a function is called, starting with main(), the parameters to that function, the return address, and a pointer to the previous stack frame are pushed onto the stack. The occupy the next addresses below the previous top of the stack. 
  * 而当该函数**开始执行时**，**其局部变量的空间也同样被分配到堆栈上**。* And when the function starts to execute, space for its local variables is similarly allocated on the stack. 
  * **如果该函数调用其他函数，堆栈就会增长，因为新的栈帧被创建。而当一个函数返回时，堆栈会缩小，它在堆栈上使用的内存会被自动回收**。* If that function calls other functions, the stack grows, as the new stack frames are created. And when a function returns, the stack shrinks and the memory it used on the stack is automatically reclaimed. 
* <font color="deeppink">编译器生成了管理堆栈的代码，作为它为每个函数生成的代码的一部分。它知道如何表示返回地址、参数和堆栈指针，以及如何增长和缩小堆栈</font>。* The compiler generates the code to manage the stack, as part of the code it generates for each function. It knows how the return address, parameters, and stack pointer are represented, and how to grow and shrink the stack. 
* 而**操作系统在程序启动时为main()生成了栈帧，其返回地址指向进程清理代码**。对程序员来说，栈是自动管理的。栈内存的所有权跟随函数的调用。* And the operating system generates the stack frame for main() when the program starts, with a return address pointing to the process cleanup code. To the programmer, the stack is managed automatically. Ownership of the stack memory follows function invocation.

# 函数调用规范：Function Calling Conventions

![](/static/2022-02-16-23-31-57.png)

本幻灯片显示了一个简单的C程序的例子。它包括一个main()函数，该函数检查作为命令行参数给出的值，并打印出一个问候语或使用信息。当这个程序开始执行时，main()被调用，堆栈的内容如幻灯片右侧的绿色区域所示。This slide shows an example of a simple C program. It comprises a main() function that inspects the values given as command line arguments, and either prints a greeting or a usage message. When this program starts to execute, and main() is called, the stack contents are as shown in the green region on the right of the slide. 

* 栈中包含了main()的参数，argc和argv，main()完成后要返回的地址，以及main的局部变量。* The stack contains the arguments to main(), argc and argv, the address to return to once main() completes, and the local variables for main. 
* 当执行到printf()行时（红色显示），函数被调用，一个新的栈帧被创建。* When execution reaches the printf() line, shown in red, and the function is called, a new stack frame is created. 
* 这个新的栈帧存放着printf()的参数、printf()调用完成后返回的地址，以及**一个指向上一个栈帧的指针**。* This new stack frame holds the arguments for printf(), the address to return to once the printf() call finishes, and a pointer to the previous stack frame. 
  * **前一个堆栈帧的地址被保存起来，以便于调试，这样可以打印堆栈痕迹，调试器可以跟踪程序的执行**。* The address of the previous stack frame is stored for ease of debugging, so stack traces can be printed and so debuggers can trace program execution. 
  * 当printf()开始执行时，栈上的空间被分配给它所使用的任何局部变量。而且，**如果printf()本身调用任何函数，堆栈将根据需要继续增长**。* As printf() starts to execute, space is allocated on the stack for any local variables it uses. And, if printf() itself calls any functions, the stack will continue to grow as needed.

# 缓冲区溢出攻击：Buffer Overflow Attacks

![](/static/2022-02-16-23-39-31.png)

这表明典型的缓冲区溢出攻击。**如果语言不是类型安全的，并且不检查数组的边界**，那么对printf()的调用可以被安排为写过了存储在**堆栈中的局部变量的边界（越界**）。This suggests the classic buffer overflow attack. If the language is not type safe, and doesn’t check array bounds, then the call to printf() can be arranged so that it writes past the bounds of a local variable stored on the stack.

* 当这种情况发生时，它就**会覆盖堆栈中下一个更高的地址所存储的内容**。* When this happens, it overwrites whatever is stored in the next higher addresses on the stack.
  * 也许是一些**其他的局部变量**，但也有指向**前一个堆栈帧的指针，然后是函数的返回地址。目标是覆盖返回地址，以及下面的一些内存**。* What would that be? Well, maybe some other local variables, but also the pointer to the previous stack frame, then the return address of the function. The goal is to overwrite the return address, and some of the following memory.
* 攻击者试图用他们**想要执行的代码来填充返回地址之后的内存。并重写返回地址，使其指向该代码**。* The attacker tries to fill the memory following the return address with the code they want to execute. And to overwrite the return address so that it points to that code.
  * 当函数随后**返回时，不是返回到正确的地方，而是返回到溢出时写入的返回地址，并执行攻击者的代码**。这是一种被称为栈粉碎的技术。* When the function then returns, rather than return to the correct place, it returns instead to the return address written during the overflows, and executes the attacker’s code. It’s a technique known as stack smashing.
    * 幻灯片上的Phrack文章的链接是这种技术的经典解释。* The link to the Phrack article on the slide is the classic explanation of this technique.

当然，现代系统有变通方法。Modern systems have workarounds, of course.

* **每次程序运行时，他们都会将堆栈的位置随机化，以使其更难知道用什么值来覆盖返回地址**。* They randomise the location of the stack each time a program runs, to make it harder to known what value to overwrite the return address with.
* 他们**安排虚拟内存硬件将堆栈内存标记为不可执行**，因此**如果返回地址被成功覆盖，系统将拒绝执行代码**。* And they arrange for the virtual memory hardware to mark the stack memory as non-executable, so the system will refuse to execute the code if the return address is successfully overwritten.
  * 这些技术有帮助。我所描述的**经典的堆栈攻击**在现代系统上是行不通的。但它们**并不能完全解决这个问题**。* These techniques help. The classic stack smashing attack I’ve described won’t work on a modern system. But they don’t entirely solve the problem.
* 较新的攻击，如**面向返回的编程**，在某些情况下可以击败保护措施。* Newer attacks, such as return oriented programming, can defeat the protections in some cases.
  * 当然，真正的解决办法是**使用一种能够检查数组边界的语言，并首先防止缓冲区溢出**。* The real solution, of course, is to use a language that checks array bounds, and prevents buffer overflows in the first place.

# 堆：The Heap

![](/static/2022-02-17-00-13-37.png)

回到内存管理。除了程序代码和堆栈之外，**堆中还有明确分配的内存**。这是通过调用C语言中的malloc()和calloc()等函数分配的内存；Rust中的盒式内存；以及Java中使用new()分配的对象。Back to memory management. In addition to the program code and the stack, the heap holds explicitly allocated memory. This is memory allocated by calls to functions such as malloc() and calloc() in C; boxed memory in Rust; and objects allocated using new() in Java.

* 堆**从内存中的一个低地址开始，跟随BSS段，并向栈方向增长**。* The heap starts at a low address in memory, following the BSS segment, and grows upwards towards the stack.
  * 正如你现在所料，**为了安全起见，堆分配的确切起始地址是随机的。一般来说，连续的堆分配将占据内存中的连续块，尽管多线程系统会对堆进行分区，使每个线程有自己的空间来进行分配，而不需要与其他线程协调**。* As you might expect by now, the exact starting address for heap allocations is randomised for security. In general, successive heap allocations will occupy consecutive blocks in memory, although multi-threaded systems will partition the heap so that each thread that its own space in which to make allocations, without needed to coordinate with other threads.
  * 而且，**根据处理器的不同，小的分配可能被四舍五入到对齐到32位或64位边界上**。* And, depending on the processor, small allocations may be rounded up in size to align on a 32 bit or a 64 bit boundary.
* 虽然**栈**在函数被调用时被**自动管理**，但**内存管理的挑战主要是如何管理和回收堆内存**。* While the stack is managed automatically as functions are called, the challenge of memory management is primarily about how to manage and reclaim the heap memory.
  * 这可以通过调用**free()函数来手动**完成。它可以通过**引用计数或垃圾收集自动完成**，我们将在下一讲中讨论。也可以**根据区域和寿命分析自动完成（分代**），我将在本讲座的后面部分讨论。* This can be done manually, by calling the free() function. It can be done automatically via reference counting or garbage collection, as we’ll discuss in the next lecture. Or it can be done automatically, based on regions and lifetime analysis, as I’ll discuss in later part of this lecture.

# 内存映射文件和共享库：Memory Mapped Files and Shared Libraries

![](/static/2022-02-17-00-26-01.png)

除了分配堆内存外，大多数操作系统允许**内存映射文件**，允许**磁盘上的数据直接映射到地址空间**。In addition to allocating heap memory, most operating systems allow memory mapped files, allowing data on disk to be directly mapped into the address space.

* 在类似Unix的系统中，这种映射是通过mmap()系统调用创建的。**mmap()调用返回一个指向内存块的指针，作为文件的代理**。从该**内存中读出的文件将被分页到内存的相关部分，并返回其内容**。* On Unix-like systems, such mappings are created using the mmap() system call. The mmap() call returns a pointer to a block of memory that acts as a proxy for the file. Reading from that memory will page into the relevant part of the file into memory, and return its contents.
  * **对该内存块的写入最终会被操作系统分页到磁盘**。* And writes to that block of memory will eventually be paged back out to disk by the operating system.
  * **文件根据需要被分页进出内存，只有被访问的文件部分被加载**。这是一种**提供对文件部分随机访问的有效方法**。* The file is paged in and out of memory as needed, with only the parts of the file being accessed being loaded. It’s an effective way of providing random access to parts of a file.
* 这种**内存映射的文件通常占据了堆和栈之间的空间**。<font color="deeppink">共享库通常使用内存映射的文件来实现，并且也被映射到这个内存空间</font>。* Such memory mapped files generally occupy the space between the heap and the stack. Shared libraries are usually implemented using memory mapped files, and are mapped into this memory space too.

# 内核空间：The Kernel

![](/static/2022-02-17-01-02-43.png)

最后，操作系统的内核位于地址空间的顶部。Finally, the operating system kernel resides at the top of the address space.

* **内核内存不被用户程序直接访问，试图访问该内存将导致分段违反**。* Kernel memory isn’t directly accessible to user programs, and attempts to access that memory will result in a segmentation violation. 
* 硬件提供了一个**特殊的机器码指令**，在64位英特尔处理器上被称为syscall，它**将系统切换到内核模式，并在执行一些权限检查后，在内核内存中执行一个特定的功能**。**内核本身可以读取和写入整个地址空间**。* The hardware provides a special machine code instruction, known as syscall on 64-bit Intel processors, that switches the system to kernel mode and executes a particular function in kernel memory, after performing some permission checks. The kernel itself can read and write to the entire address space.
* **硬件保护操作系统的内核不受用户进程的影响，但操作系统必须能够控制这些进程*** The hardware protects the operating system kernel from the user processes, but the operating system has to be able to control those processes

# ==========

# 2-自动内存管理-引用计数：Automatic Memory Management: Reference Counting

本讲座的第二部分介绍了**自动内存管理的概念**及其在系统程序中的应用。然后，它讨论了最简单的自动内存管理方案之一：**引用计数**。它概述了引用计数的工作原理，并描述了其局限性、成本和好处。The second part of the lecture introduces the concepts of automatic memory management and its use in systems programs. Then it discusses one of the simplest automatic memory management schemes: reference counting. It outlines how reference counting works, and describes its limitations, costs, and benefits.

# 自动内存管理：Automatic Memory Management

![](/static/2022-02-17-01-13-11.png)

**自动内存管理**经常被系统程序员所不信任。**人们普遍认为它的开销很大。它很慢，占用CPU，而且浪费内存。而且，使用自动内存管理会给时间敏感的操作带来不可预知性**。在某种程度上，这种想法是真实的。Automatic memory management is frequently distrusted by systems programmers. There’s a general belief that it has high overheads. That it’s slow, CPU hungry, and wastes memory. And that the use of automatic memory management introduces unpredictability into the timing of time sensitive operations. And to some extent this belief is true.

* 有许多不同类型的自动内存管理。其中一些确实有很高的CPU成本。有些确实会浪费内存。有些确实在时间上引入了不可预测性。* There are many different types of automatic memory management. And some of them do have high CPU costs. Some of them do waste memory. And some do introduce unpredictability into timing.
* 同样地，**手动内存管理也有非常实际的问题**。**手动管理内存有不可预知的开销**。作为一个程序员，你知道你何时调用malloc()和free()，**但你不知道这些调用需要多长时间来执行**。* Equally, though, there are very real problems due to manual memory management. Managing memory manually has unpredictable overheads. As a programmer you known when you call malloc() and free(), but you have no idea how long those calls will take to execute.
* 而且，在某些情况下，它们可能是**相当密集的处理器，并可能需要不可预测的时间**。还有许多众所周知的问题，如内存泄漏、内存损坏、缓冲区溢出、用完即弃、迭代器失效等，所有这些都是由于**手动内存管理造成的**。* And they can be quite processor intensive, and can take unpredictable amounts of time, in some cases. And there are the numerous, and well known, problems due to memory leaks, memory corruption, buffer overflows, use-after-free bugs, and iterator invalidation, all of which are due to manual memory management.

系统程序员把注意力集中在转向**自动内存管理**的问题上，对现状的问题不屑一顾。此外，我们开始看到自动内存管理技术解决了旧方法中的一些问题。Systems programmers have focussed on the problems of moving to automatic memory management, discounting the problems of the status quo. Furthermore, we’re starting to see automatic memory management techniques that solve some of the problems with older approaches. 

* **新的垃圾收集算法具有更低的开销和更多的可预测性**。而且**系统变得更快，使现有算法的开销更容易被接受**。* New garbage collection algorithms have lower overheads and are more predictable. And systems have gotten faster, making the overheads of existing algorithms more acceptable. 
* 不同的方法，如**基于区域的内存管理**，开始被**广泛使用，并提供更多的可预测性和更强的编译时行为保证**。对于许多系统程序来说，现在可能是时候重新考虑自动内存管理的成本-效益权衡了，看看平衡是否已经改变了。* And different approaches, such as region-based memory management, are starting to see widespread use, and offer more predictability and stronger compile-time behaviour guarantees. For many systems programs, it may be time to reconsider the cost-benefit tradeoff for automatic memory management, to see if the balance has shifted.

# 系统程序-内存管理：Memory Management in Systems Programs

![](/static/2022-02-17-01-20-31.png)

**系统程序**传统上**使用手动和自动内存管理的混合方式**。用于**栈的内存是自动管理**的。Systems programs traditionally used a mix of manual and automatic memory management. The memory used for the stack is managed automatically.

* 例如，在幻灯片上的示例代码中，saveDataForKey()函数中的**局部变量di的内存在函数被调用时自动分配，并在函数返回时自动释放**。这是很常见的，我们甚至都没有想到。* In the sample code on the slide, for example, the memory for the local variable, di, in the saveDataForKey() function is automatically allocated when the function is called, and automatically freed when the function returns. This is so common that we don’t even think about it. 
* 基于栈的内存管理，在这种形式下，对于像C和C++这样支持复杂值类型的语言，效果非常好。也就是说，对于那些可以把结构放在栈上并按值传递的语言。* Stack-based memory management, in this form, works extremely well for languages like C and C++ that support complex value types. That is, for languages that can put structs on the stack and pass them by value.
* 对于像Java这样的语言来说，它的效果较差，因为在这些语言中，**对象是堆分配的。在Java中，变量di是对堆分配对象的引用，需要进行垃圾回收。只有对该对象的引用会被保存在栈中**。* It works less well for languages like Java, where objects are heap allocated. In Java, the variable, di, would be a reference to a heap allocated object, which would need to be garbage collected. Only the reference to that object would be stored on the stack. 
* 而**在C和C++中**，**整个对象可以有效地在栈中管理**。C和C++中的栈是一个成功的自动内存管理的例子。* While, in C and C++, the entire object can be efficiently managed on the stack. The stack in C and C++ is an example of successful automatic memory management. 
* 另一方面，**堆一般是手动管理的。分配是通过调用malloc()进行的。如果程序员记得要这样做，则通过明确地调用free()来取消分配**。* The heap, on the other hand, is generally managed manually. Allocation is by a call to malloc(). Deallocation, if the programmer remembers to do so, is by an explicit call to free().

# 堆管理：Managing the Heap

![](/static/2022-02-17-01-25-43.png)

如果有一种有效的、自动的管理堆的方法就好了。像管理堆一样简单、高效、有效的东西。It would be good to have an effective and automatic way of managing the heap. Something that’s as simple, efficient, and effective as managing the stack. 

自动内存管理的目标是管理堆。**找出不再使用的内存，并使这些空间可以重新使用。寻找不再被运行中的程序引用的对象，并释放其内存**。The goal of automatic memory management is to manage the heap. To find memory that’s no longer in use, and make that space available for reuse. To look for objects that are no longer referenced by the running program, and to free their memory. 

* 而且要有效地、**自动**地做到这一点。而且要**安全**地做到这一点。最好是**浪费内存**，并在不应该存在的情况下让对象保持活动状态，**而不是释放可能仍在使用的对象使用的内存**。And to do so efficiently and automatically. And to do so safely. It’s better to waste memory, and to keep an object alive when it shouldn’t be, than to deallocate the memory used by an object that’s potentially still in use. 

有三种方法来自动管理堆。There are three approaches to automatically managing the heap.

* 引用计数 reference counting
* 基于区域的寿命跟踪 region-based lifetime tracking
* 垃圾收集 garbage collection

# 计数引用：Reference Counting

![](/static/2022-02-17-01-33-43.png)

自动内存管理技术中的第一个是引用计数。引用计数很简单，也很容易理解。The first of the automatic memory management techniques is reference counting. Reference counting is simple and easy to understand.

* 当为一个对象分配内存时，分配中包含了额外的空间，用于与对象一起存储的引用计数。也就是说，**每个对象都有一个隐藏的额外字段，大到足以容纳一个整数值，它与对象一起存储，由运行时系统管理**，程序员无法看到。* When allocating memory for an object, the allocation contains additional space for a reference count that’s stored along with the object. That is, every object has a hidden extra field, large enough to hold an integer value, that’s stored alongside the object and managed by the runtime system, invisibly to the programmer.
* 这个**额外的字段包含一个引用计数。它计算了有多少其他对象拥有对这个对象的指针，即引用**。* This extra field contains a reference count. It counts how many other objects have a pointer, a reference, to this object. 
  * 当**一个堆分配的对象被创建时，引用计数被设置为1，并且返回该对象的一个引用**。* When a heap allocated object is created, the reference count is set to one, and a reference to the object is returned. 
  * **当一个新的引用，一个新的指针，指向这个对象时，那么引用计数会增加1。当一个引用被移除或改变，使其不再指向该对象，那么引用计数将减少1**。* When a new reference, a new pointer, to the object is made, then the reference count is increased by one. When a reference is removed or changed, so that it no longer points to the object, then the reference count is decreased by one. 
  * **如果引用计数达到0，那么就没有指向该对象的引用了，它可以被回收，并且它的内存被重新分配了**。**如果一个包含对其他对象的引用的对象被回收，这将删除对这些对象的引用。这样做有可能导致它们的引用计数归零，从而触发进一步的回收**。* If the reference count reaches zero, then there are no references left that point to the object, and it may be reclaimed, and it’s memory deallocated. If an object that contains references to other objects is reclaimed, this removes a reference to those objects. Doing so potentially causes their reference counts to go to zero, triggering further reclamation.
* 引用计数是自动维护的。在**带有引用计数的编译语言**中，例如iPhone中使用的Objective C运行时，**编译器会生成代码来管理引用，并在指针被操作时回收对象**。在**具有引用计数的解释语言**中，如Python或Ruby，**解释器会更新引用并回收对象**。* The reference counts are maintained automatically. In a compiled language with reference counting, such as the Objective C runtime used in iPhones, then the compiler generates the code to manage references and reclaim objects when pointers are manipulated. In an interpreted language with reference counting, such as Python or Ruby, the interpreter updates the references and reclaims the objects.

## 优点：Benefits

![](/static/2022-02-17-01-43-49.png)

参照计数的关键好处是它是**可预测和可理解的**。The key benefit of reference counting is that it’s predictable and understandable.

很容易解释引用计数是如何工作的。很容易理解何时回收内存，以及程序中的哪些行为可能会触发内存回收。很容易理解什么是开销，什么是成本。It’s easy to explain how reference counting works. It’s easy to understand when memory is reclaimed, and what actions in a program might trigger memory to be reclaimed. It’s easy to understand what is the overhead and what is the cost.

每个对象有一个额外的整数；当获取一个对象的指针时，引用计数的增量；当移除一个引用时，引用计数的减量、if语句和对free()的潜在调用。这种行为对程序员来说是很直观的--这一点很重要。It’s one additional integer per object; an increment of a reference count when taking a pointer to an object; and a decrement of a reference count, an if statement, and a potential call to free() when removing a reference. The behaviour is intuitive to programmers – and that counts for a lot.

引用计数也是递增的。内存在小范围内被回收，而发生的成本是指针操作上偶尔出现的少量开销。**很少有长时间的内存管理活动，而且很清楚什么会触发这种突发情况**。Reference counting is also incremental. Memory is reclaimed in small bursts, and the costs that occur are an occasional small overhead on pointer operations. **There are few long bursts of memory management activity, and it’s clear what might trigger such bursts.**

## 开销：Costs

![](/static/2022-02-17-01-49-36.png)

引用计数也有一些代价。Reference counting also has some costs. 

可以产生**包含相互引用的循环数据结构**。Cyclic data structures can be produced that contain mutual references. 

* 也就是说，一组对象可以**在循环中相互引用，这样的对象都可以从其他一些对象中到达，所以引用计数永远不会达到零，但却不能从程序的其他部分到达（仅在循环中**。* That is, a set of objects can reference each other in a loop, such that the objects are all reachable from some other object, so the reference count never reaches zero, but not from the rest of the program.
* 这可能导致一组断开连接的对象，从代码的其余部分无法到达，**因为它们的引用计数不为零，所以没有被回收。也就是说，会泄露内存**。* This can lead to a disconnected set of objects, unreachable from the rest of the code, that aren’t reclaimed because they have non-zero reference counts. That is, it can leak memory.
  * 程序员需要注意到，并**明确地将其中一个引用设置为null，以便在删除对象的最后一个其他指针之前打破这个循环。只有这样，这些对象才能被回收**。 The programmer needs to notice, and explicitly set one of the references to null, to break the cycle before removing the last other pointer to the objects. Only then will the objects be reclaimed.

引用计数在每个对象旁边存储一个引用计数，作为一个额外的隐藏字段。Reference counting stores a reference count alongside each object, as an additional hidden field. 

* 如果对象可以**被同时访问，它可能还需要为每个对象设置一个mutex。这需要额外的内存**。* If the objects can be accessed concurrently, it may also need a mutex for each object. This uses additional memory. 
* 如果**对象很小**的话，这可能是一个**相当高的开销**。* And can be quite a high overhead if the objects are small. 
* 如果程序**经常操作指针，或者对象的寿命不长，那么更新引用的处理器成本就会相当高**。* And the processor cost of updating the references can be moderately high, if the program manipulates pointers a lot, of if the objects don’t live long.

## 适用场景

![](/static/2022-02-17-01-55-00.png)

尽管有这些限制，引用计数被广泛使用。Despite these limitations, reference counting is widely used.

* 它在**脚本语言**中很常见，如Python或Ruby，使用解释语言的开销远远超过了使用引用计数的开销。* It’s common in scripting languages, such as Python or Ruby, where the overhead of using an interpreted language far outweighs the overhead of using reference counting.
* 它也**被用于系统编程的某些方面**。iPhone和Mac的应用程序通常用**Objective C**语言编写。这是一种面向对象的C语言的扩展，使用引用计数来管理分配给对象的内存。**它实际上是高度优化的，而且性能相当高。对于用户界面代码和许多应用逻辑来说，引用计数一直是足够快的**。* It’s also used for some aspects of systems programming. Applications for the iPhone and Mac are typically written in the Objective C language. This is an object oriented extension to C that uses reference counting to manage the memory allocated to objects. And it’s actually highly optimised and reasonably high performance. Reference counting has always been fast enough for user interface code and much application logic.
* 但它**并不用于低级别的、内核内的代码，因为那里的性能是至关重要的**。* It’s not used for low-level, in-kernel, code, where performance is critical, though.

# ==========

# 3-基于区域的内存管理：Region-based Memory Management

本讲座的第三部分介绍了**基于区域的内存管理**的概念。它描述了这种方法背后的概念和原理，以及它如何建立在堆栈的管理方式之上。它还描述了基于区域的内存管理方法的好处和局限性，比如**Rust所采用的方法**。介绍了**所有权跟踪**的概念。The third part of the lecture introduces the concept of region-based memory management. It describes the concepts and rationale behind this approach, and how it builds on the way the stack is managed. And it describes the benefits and limitations of region-based approaches to memory management, such as that employed by Rust. The concept of ownership tracking is introduced.

对基于区域的内存管理的介绍到此结束。关键的见解是，**如果每个值都有一个唯一的所有者，并且编译器跟踪所有权和这些值的，那么每个值都可以在其结束后自动释放。这就是Rust和其他编程语言的关键区别**。Rust编译器知道一个值什么时候被消耗了，什么时候达到了它的的终点，并且会**在编译时强制执行**。其他语言要么不跟踪寿命，比如C语言，并可能允许在空闲bug后使用，悬空引用，等等。或者它们使用某种形式的垃圾收集，在运行时跟踪数据的有效性。它们要么不安全，要么有运行时开销。Rust既安全，又避免了运行时的开销。但为了实现这一点，Rust限制了可以表达的程序集，我们将在本讲座的下一部分看到。That concludes this introduction to region-based memory management. The key insight is that if every value has a unique owner, and the compiler tracks ownership and the lifetime of those values, then every value can be automatically freed at the end of its lifetime. This is the key difference between Rust and other programming languages. The Rust compiler knows when a value has been consumed, when it’s reached the end of its lifetime, and will enforce this at compile time. Other languages either don’t track lifetimes, like C, and potentially allow use after free bugs, dangling references, and so on. Or they use some form of garbage collection, to track liveness of data at run time. They’re either unsafe, or have run time overhead. Rust is both safe, and avoids the run-time overheads. But to achieve this, Rust restricts the set of programs that can be expressed, as we’ll see in the next part of this lecture.

# 基于区域内存管理目标：Rationale

![](/static/2022-02-17-02-02-11.png)

基于区域的内存管理是一种新的内存管理方式，是在对其他方式的失望中发展起来的。Region-based memory management is a new way of managing memory that grew out of frustrations with the alternatives. 

* 正如我们在上一部分所看到的，引用计数简单易懂，但开销相对较高。它需要空间来存储引用计数，也需要时间来更新它们。虽然这种开销对于大多数应用程序来说是可以接受的，但对于性能关键的系统代码来说就太多了。Reference counting, as we saw in the last part, is simple and easy to understand, but has relatively high overhead. It takes space to store the reference counts, and time to update them. And while this overhead is okay for most applications, it’s too much for performance-critical systems code. 
* 垃圾收集，我将在下一讲中详细讨论，它有不可预测的时间和高内存开销。Garbage collection, which I’ll talk about in detail in the next lecture, has unpredictable timing and high memory overheads. 

* 而手动内存管理又太容易出错。And manual memory management is too error prone. 

基于区域的内存管理旨在实现这两者之间的中间地带。**它的目标是安全和提供可预测的时间。而且，与手动内存管理相比，它没有运行时间成本**。但是，为了实现这一点，它迫使代码的编写方式发生一些变化。Region-based memory management aims for the middle ground between these. It aims to be safe and offer predictable timing. And it has no run-time cost, compared to manual memory management. But, to achieve this, it forces some changes in the way code is written.

# 基于栈内存管理：Stack-based Memory Management

![](/static/2022-02-17-02-10-32.png)

那么什么是基于区域的内存管理？让我们首先回顾一下堆栈上的内存管理方式 So what is region-based memory management? Well, to understand that, let’s first recap the way memory is managed on the stack. 

* 幻灯片显示了一个简单的C程序。这包括两个函数：main()和conic_area()，其中conic_area()函数实现了一个数学公式来计算一个直角圆锥的表面积。* The slide shows a simple C program. This comprises two functions: main() and conic_area(), where the conic_area() function implements a mathematical formula to calculate the surface area of a right circular cone. 
* 有一个全局静态变量，持有Pi的值。main()函数不需要任何参数，并持有局部变量宽度、高度和面积。* There’s one global static variable, holding the value of Pi. The main() function takes no parameters, and hold local variables width, height, and area. 
* 而conic_area()函数需要两个参数，w和h，并持有局部变量r和a。* And the conic_area() function takes two parameters, w and h, and hold the local variables r and a. 

右图显示了程序拥有的内存区域，同时conic_area()函数正在执行。我们看到有一个区域存放着全局变量，以及用于main()和conic_area()函数的栈帧的子区域。The diagram on the right shows the memory regions owned by the program, while the conic_area() function is executing. We see there’s a region holding the global variables, and sub-regions for the stack frame for main() and for the conic_area() functions. 

* **这些区域相互嵌套，全局区域持续整个程序的时间，而其他区域则嵌套在其中，持续部分时间。局部变量和函数参数的寿命与容纳它们的函数的栈帧相匹配。内存被自动地、有效地、无缝地分配和删除**。* These nest, one within the other, with the global region lasting for the entire duration of the program, and the other regions nesting within, and lasting for part of the time. The lifetime of the local variables and function parameters matches that of the stack frames of the functions holding them. Memory is allocated and deallocated automatically, efficiently, and seamlessly.

---

![](/static/2022-02-17-02-14-40.png)

从本质上讲，有一个与程序的调用栈相对应的区域层次结构。Essentially, there’s a hierarchy of regions corresponding to the call stack of the program.

* **全局变量的寿命是整个程序的寿命，而局部变量的寿命与它们所在的函数的执行时间相匹配**。* The lifetime of the global variables is that of the entire program, and the lifetime of the local variables matches the execution time of the functions they live within. 
* 而且，在每个函数中，我们可以看到有一些**词义范围内的变量，它们的寿命比包围函数的寿命要短**。* And, within each function, we see there may be lexically scoped variables that have a lifetime less than that of the enclosing function. 
  * 例如，在幻灯片上的代码中，我们看到**变量i，即for循环中的索引变量，只在for循环的时间内存在**。* In the code on the slide, for example, we see that the variable i, the index variable in the for loop, lives only for the duration of that for loop. 
* **这些变量中的每一个都生活在一个区域内，由程序代码决定范围，在进入该区域时自动分配，而在程序离开该区域时则被取消分配**。这样的工作是无缝的。以至于我们在写代码时认为这是理所当然的。* Each of these variables lives within a region, scoped by the program code, and is automatically allocated when entering that region, and deallocated when the program leaves the region. This works seamlessly. So much so that we take it for granted when writing code.

## 局限性

![](/static/2022-02-17-02-18-49.png)

这种基于堆栈的内存管理方法有一个限制。它**要求数据在栈中分配**。There’s one limitation of this stack-based approach to memory management. It requires data to be allocated on the stack.

在本幻灯片的例子中，变量tmp存在于hostname_matches()函数的栈帧中。变量的空间在函数开始执行时被创建，并在函数结束时被释放。In the example on this slide, the variable tmp lives on the stack frame for the hostname_matches() function. Space for the variable is created when the function starts to execute, and freed when the function concludes.

* 但这只是存放tmp的内存。也就是说，**存放指针的局部变量的内存是自动管理的。堆分配的内存，即调用malloc()分配的内存，不会被自动释放**。* But that’s only the memory that holds tmp. That is, the memory for the local variable holding the pointer is managed automatically. The heap allocated memory, the memory allocated by the call to malloc(), is not freed automatically. 
* 当tmp超出范围时，持有指针的空间被释放，但**它指向的值没有被释放**。* When tmp goes out of scope, the space holding the pointer is freed, but the value it points to is not. 
  *** 程序没有调用free()来释放该内存，也没有返回指针，以便其他函数可以这样做。它泄漏了内存。指针消失了，所以没有剩余的对所分配内存的引用，所以没有办法释放该内存**。* The program doesn’t call free() to deallocate that memory, and it doesn’t return the pointer so some other function can do so. It leaks memory. The pointer is gone, so there’s no remaining reference to the allocated memory, so no way to free that memory.

# 从栈内存管理延伸到堆管理：From Stack-to Region-based Memory Management

![](/static/2022-02-17-02-24-31.png)

基于栈的内存管理显然是有效的，但其适用性有限。我们可以扩展它来管理堆吗？可以。Stack-based memory management is clearly effective, but has limited applicability. Can we extend it to manage the heap?

我们可以**安排编译器跟踪数据的寿命**，以它插入代码管理堆栈的同样方式，它可以**插入代码，根据对象的寿命来管理堆内存**。如果我们安排代码，使每个数据值都有一个明确的所有者，那么我们可以安排它，如果一个指针超出范围，那么它所指向的值也会被释放。We can arrange for the compiler to track the lifetime of data, and in the same way that it inserts code to manage the stack, it can insert code to manage heap memory based on object lifetimes. If we arrange the code so that there’s a single clear owner of every data value, then we can arrange it so that if a pointer goes out of scope, then the value it points to is also freed.

* 这就要求我们**跟踪所有数据对象的所有权**，但正如我们在上一节课看到的，Rust会这样做。那么我们的想法是定义Box-of-T类型(智能指针)，这是一个存储在栈中的值，它持有对堆上分配的T类型数据的引用。* This requires us to track ownership of all data objects, but as we saw in the last lecture, Rust does this. The idea then it to define the Box-of-T type, which is a value that’s stored on the stack that holds a reference to data of type T that’s allocated on the heap. 
* **调用Box::new()分配并填充堆内存，并返回一个指向该内存的指针，该指针存储在堆栈的一个局部变量中。由此产生的局部变量是一个普通的变量，其寿命与它所在的栈框架相匹配**。* Calling Box::new() allocates and populates heap memory, and returns a pointer to that memory that’s stored in a local variable on the stack. The resulting local variable is a normal variable, with lifetime matching that of the stack frame in which it resides. 
* 而**堆分配的对象的寿命也与Box的寿命一致。当容纳Box的局部变量超出范围时，编译器会自动调用其析构器。解构器释放了堆分配的内存**。* And the heap allocated object has lifetime matching that of the Box too. When the local variable holding the Box goes out of scope, its destructor is automatically called by the compiler. The destructor frees the heap allocated memory. 

这就是Rust中基于区域的内存管理的基础。它的效率很高。而且它可以安全地管理堆内存。* This is the basis for region based memory management in Rust. It’s highly efficient. And it safety manages heap memory. 

* 但**它失去了通用性，因为它将堆分配的寿命与栈帧的寿命联系在一起**。如果你对C++进行过编程，这种方法就会被称为RAII--资源获取即初始化--设计模式。Python也在其 "With "字句中做了类似的事情。* But it loses generality, since it ties the lifetime of heap allocation to that of stack frames. If you’ve programmed C++, this approach will be familiar as the RAII – Resource Acquisition Is Initialization – design pattern. Python also does something similar in its “with” clauses.

# ======

# 生命周期检查【引用】：Validating References with lifetimes

使用’a的方式，可以显式声明生命周期。生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦他们形成了某种关联，**Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为**。

Rust中的每个引用都是有其 生命周期 (lifetimes)，也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以Rust需要我们使用泛型生命周期参数来注明他们的关系，这样就能**确保运行时实际使用的引用绝对是有效的**。

https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html

![](/static/2022-02-18-03-19-24.png)

## 用生命周期防止悬空引用-Preventing Dangling References with Lifetimes 

![](/static/2022-02-18-03-20-42.png)
![](/static/2022-02-18-03-23-19.png)

## 租借检查器：The Borrow Checker

借用检查器被设计用于安全地处理内存分配和所有权，防止对无效内存的访问，并确保数据竞争自由。这是资源管理的一种形式: 借用检查器跟踪谁负责一块内存，以及谁目前被允许对其进行读写操作

![](/static/2022-02-18-03-27-44.png)
![](/static/2022-02-18-03-29-05.png)

* 在编译时，Rust 比较了两个生命周期的大小，发现 r 的生命周期为‘ a’，但它指的是‘ b’生命周期的内存。这个程序被拒绝了，因为 b 比 a 短: 参考的客体没有引用者的那么长。

## 函数参数-通用生命周期：Generic Lifetimes in Functions

编译器的租借检查器无法检查泛型生命周期。。。但可以为泛型指定生命周期参数

![](/static/2022-02-18-03-30-58.png)
![](/static/2022-02-18-03-32-06.png)
![](/static/2022-02-18-03-32-44.png)

### Lifetime Annotation Syntax 生存期注释语法

![](/static/2022-02-18-03-36-02.png)
![](/static/2022-02-18-03-36-46.png)

---

![](/static/2022-02-18-03-37-40.png)
![](/static/2022-02-18-03-41-02.png)
![](/static/2022-02-18-03-44-33.png)

---

具体例子

![](/static/2022-02-18-03-47-10.png)
![](/static/2022-02-18-03-49-34.png)
![](/static/2022-02-18-03-51-09.png)
![](/static/2022-02-18-03-52-11.png)

* 虽然逻辑会返回str1（更长的生命周期，print那行有效），但是编译器租借检查器不会意识到这点，因为注解了通用生命周期注解，一定会返回较小的那个

## 生命周期注解&悬挂指针

![](/static/2022-02-18-04-04-01.png)
![](/static/2022-02-18-04-06-28.png)

# 结构体:引用字段-生命周期 Lifetime Annotations in Struct Definitions

![](/static/2022-02-18-04-08-41.png)

# 生命周期-省略规则

在 Rust 的参考文献分析中编写的模式被称为生命周期省略规则。这些不是程序员应该遵循的规则; 它们是编译器会考虑的一组特殊情况，如果你的代码符合这些情况，你就不需要明确地编写生命周期。

![](/static/2022-02-18-04-14-23.png)
![](/static/2022-02-18-04-15-23.png)

![](/static/2022-02-18-04-15-55.png)
![](/static/2022-02-18-04-16-22.png)

---

![](/static/2022-02-18-04-17-47.png)

* 报错，编译器无法通过缺省规则计算出生命周期

## 方法定义-生命周期注解（规则1，3）：Lifetime Annotations in Method Definitions

![](/static/2022-02-18-04-22-05.png)
![](/static/2022-02-18-04-23-34.png)

# 静态生命周期：The Static Lifetime

![](/static/2022-02-18-04-25-03.png)

* 字符串字面量文本

# 泛型&traits bounds&生命周期

![](/static/2022-02-18-04-28-05.png)

# ======

# 智能指针

在 Rust 中，使用了所有权和借用的概念，引用和智能指针之间的另一个区别是**引用**是只**借用数据的指针**; 相反，在许多情况下，**智能指针拥有它们所指向的数据**。

![](/static/2022-02-18-04-32-46.png)

* **智能指针区别于普通结构的特征是智能指针实现了 Deref 和 Drop traits**。
  * Deref 特性允许智能指针结构的实例表现得像一个引用，这样你就可以编写可以使用引用或者智能指针的代码。
  * Drop trait 允许您自定义智能指针的实例超出范围时运行的代码。在本章中，我们将讨论这两个特性，并说明为什么它们对智能指针很重要

# ======

# 跟踪对象所有权-Rust有效化栈管理模式

![](/static/2022-02-17-02-33-54.png)

不过Rust将这一模式进一步发展。为了有效，基于区域的内存管理不仅要**将对象的寿命与栈帧联系起来，还要跟踪对象在栈帧之间的传递方式**。Rust takes the pattern further though. To be effective, region-based memory management has to not just tie object lifetimes to stack frames, but also to track how objects are passed between stack frames. 

* 而且这样做的方式要能**保持每个对象的单一所有者不变**。* And do so in a way that maintains the single owner invariant for every object. 
* 在每一点上，**编译器都必须知道哪块代码区域拥有每一块数据**。* At every point, the compiler must know what region of code owns each piece of data. 
* 当数据在函数间传递时，当数据的所有权在函数间传递时，**编译器必须跟踪数据的所有权**。* And as data is passed between functions, as ownership of the data is passed between functions, the compiler must track that data ownership. 
* **而且，当数据项最终超出范围时，在它的所有权在不同的函数之间传递之后，只有在那时，它才应该去分配堆的内存**。* And, when the data item finally goes out of scope, after its ownership has been passed between various functions, only then should it deallocate the heap memory.
  * `*`

# 函数返回数据所有权：Returning Ownership of Data

![](/static/2022-02-17-02-42-00.png)

正如我们在上一节课所看到的，Rust跟踪数据项的所有权，因为它们在函数之间传递。As we saw in the last lecture, Rust tracks ownership of data items as they’re passed between functions. 

* 幻灯片上的代码是我们之前看到的C程序的Rust等价物，用于计算圆锥面积。如果我们看一下函数 area_of_cone() 中变量的寿命，我们会发现**变量 r 的寿命与函数的栈帧相匹配。它在函数开始执行时被分配，在函数结束时超出范围并被释放**。* The code on the slide is the Rust equivalent of the C program we saw earlier, to calculate the conic area. If we look at the lifetimes of the variables in the function area_of_cone(), we see that the variable, r, has lifetime matching that of the function’s stack frame. It’s allocated when the function starts to execute, and goes out of scope and is freed when the function finishes. 
* **变量a是在area_of_cone()中创建的，但随后从该函数返回。该值的所有权从该函数传递给其调用者，即main()函数。在那里，它被作为参数传递给println!()宏，该宏消耗该值**。* The variable, a, though is created within the area_of_cone() but then returned from that function. Ownership of the value is passed from that function to its caller, the main() function. And from there, it’s passed as an argument to the println!() macro, that consumes the value. 
  * 关键的一点是，**最初存储在 area_of_cone() 函数中的局部变量 a 中的值的寿命超过了该函数。编译器会跟踪这个寿命。它知道所有权已经改变。这个值已经从函数中传递到main()中，随后被println!()调用所消耗**。* The key point is that the lifetime of the value initially stored in the local variable, a, in the area_of_cone() function, outlives that function. And the compiler tracks this lifetime. It knows that the ownership has changed. That the value has been passed out of the function into main(), and is later consumed by the println!() call.

---

![](/static/2022-02-17-02-52-42.png)

我们看到，返回值的所有权被转移到了调用函数中。**这个值被移到了调用函数的栈帧中，并被分配给一个局部变量。而原来的值，在被调用函数的栈帧内，在该函数返回时被销毁**。We see that ownership of the return value is moved to the calling function. The value is moved into the stack frame of the calling function, and assigned to a local variable. And the original value, in the called function’s stack frame, is destroyed when that function returns. 

* **如果被移动的值是一个Box，被移动的就是Box本身。也就是说，指向堆分配的内存的智能指针被移到调用者的栈帧中。它所引用的堆上的值是不变的**。* If the value being moved is a Box, what’s moved is the Box itself. That is, the smart pointer to the heap allocated memory is moved into the stack frame of the caller. The value on the heap that it references is unchanged. 
* 同样，**如果一个引用被返回，被移动的是这个引用。被引用的值是不变的**。* Similarly, if a reference is returned, it’s the reference that’s moved. The referenced value is unchanged.

任何【**没有被函数返回的变量】都会超出范围，并在函数返回时被销毁**。 Any variable not returned by a function goes out of scope and is destroyed when the function returns. 

* 这是什么意思？该类型的**析构器，即drop()方法，被调用。然后，存放该对象的内存被解配**。* What does this mean? The destructor for the type, the drop() method, is called. Then the memory holding the object is deallocated. 
* 如果**超出范围的值是一个Box，Box的析构器会调用堆分配的对象的析构器，然后释放堆的内存。由于每个对象最终都会超出范围，当它的结束时，因为确保所有的堆内存被释放**。* If the value going out of scope is a Box, the destructor for the box calls the destructor for the heap allocated object, then frees the heap memory. Since every object goes out of scope eventually, when it reaches the end of its lifetime, since ensures that all heap memory is freed.

# 消除悬挂引用：No Dangling References

![](/static/2022-02-18-03-14-12.png)
![](/static/2022-02-18-03-15-25.png)

---

![](/static/2022-02-17-03-01-43.png)

由于Rust编译器跟踪每个对象的，它可以防止常见的与有关的错误。Since the Rust compiler tracks the lifetime of every object, it can prevent common lifetime-related errors. 

例如，本幻灯片顶部显示的Rust程序是**一个试图返回一个局部变量的引用的函数。这是不可能的，因为一旦函数返回，局部变量就不存在了**。For example, the Rust program shown on the top of this slide is a function that tries to return a reference to a local variable. This isn’t possible, since the local variable ceases to exist once the function returns.

* 编译器注意到了这一点，正如我们所看到的，这段代码没有被编译。**你不能返回一个引用，也就是说，借用一个不再存在的值**。* The compiler notices this, and as we see, the code doesn’t compile. You can’t return a reference to, that is, borrow, a value that doesn’t exist any more. 
* 幻灯片底部显示的等效的C语言程序在编译时没有问题，但在运行时使用返回的指针时会崩溃。好的C语言编译器在像这个例子这样简单的情况下会对此发出警告，但在编译更复杂的代码时不会有任何警告。* The equivalent C program, shown on the bottom of the slide, will compile just fine, but crash at runtime when the returned pointer is used. Good C compilers warn about this, in simple cases like this example, but will compile more complex variants of the code without warnings.

# 消除释放后使用：No Use-After-Free

![](/static/2022-02-17-03-06-43.png)

同样，由于**Rust编译器跟踪对象的，它可以防止你访问已经被释放的内存**。Similarly, because the Rust compiler tracks object lifetimes, it can prevent you from accessing memory once it’s been freed.

幻灯片顶部显示的Rust代码是一个例子。它导入并明确地调用了drop()函数，以强制本地变量x被解锁。The Rust code shown at the top of the slide shows an example. It imports and explicitly calls the drop() function, to force the local variable, x, to be deallocated. 

* 手动调用drop()在Rust中从来没有明确的需要，但也是可能的，其效果与C语言程序中调用free()去分配内存是一样的。。* Calling drop() manually is never explicitly needed in Rust, but is possible, and has the same effect as calling free() to deallocate memory in a C program. 
* 幻灯片上的Rust代码，即**去分配内存，然后试图打印出刚刚分配的内存的内容，未能编译。编译器知道drop()的调用消耗了对象，它的结束了。它知道这个值不能被访问** * The Rust code on the slide, that deallocates memory then tries to print out the contents of the just-deallocated memory, fails to compile. The compiler knows that the drop() call consumes the object and that its lifetime ends. It knows that the value cannot then be accessed.
* 底部显示的等效的C程序在编译时没有警告，但在运行时有未定义的行为，因为它访问了先前释放的内存。* The equivalent C program, shown at the bottom, will compile without warnings, but has undefined behaviour at runtime since it accesses previously freed memory.

# 数据所有权转移给调用者：Taking Ownership of Data

![](/static/2022-02-17-03-13-34.png)

除了返回数据的所有权外，函数还可以取得一个值的所有权。**当一个值被传递给一个函数时，该函数就取得了该值的所有权**。In addition to returning ownership of data, functions can take ownership of a value. When a value is passed to a function, that function takes ownership of that value.

我们在幻灯片上的代码中看到了这一点，consumer()函数从main()函数中以其参数x的形式**取得了局部变量a的所有权。而且，像往常一样，一旦consumer()函数结束，它所拥有的【任何未返回的数据值就会被销毁**】。We see this in the code on the slide, where the consume() function takes ownership of the local variable, a, from the main() function, in the form of its parameter, x. And, as usual, once the consume() function ends, the values of any data it owns that are not returned, as destroyed.

* 当我们试图编译代码时，我们会看到这一点。**main()函数不能访问局部变量a来打印其长度，因为它不再拥有该值。它把所有权给了consumer()函数，而该函数销毁了这个值，并且没有把它传回来。因此，它在main()中不再被访问，代码无法编译**。* We see this when we try to compile the code. The main() function can’t access the local variable, a, to print its length, since it doesn’t own the value anymore. It gave ownership to the consume() function, and that function destroyed the value and didn’t pass it back. Accordingly, it’s no longer accessible in main() and the code won’t compile.

# ==========

# 4-资源管理：Resource Management

本讲座的最后部分讨论了**如何将基于区域的内存管理扩展到包括资源管理**。它进一步扩展了上一部分介绍的所有权跟踪的概念，并展示了Rust如何支持数据的借用，使基于区域的内存管理变得可行。它**概述了基于区域的内存管理的局限性，以及它是如何限制可以编写的程序类别的**，并讨论了这一点带来的权衡。它回顾了**基于区域的管理是如何被用来执行确定性的资源清理的**。The final part of the lecture discusses how region-based memory management can be extended to include resource management. It further expands on the concept of ownership tracking, introduced in the previous part of the lecture, and shows how Rust supports borrowing of data to make region-based memory management feasible. It outlines the limitations of region-based memory management and how it limits the classes of program that can be written, and discusses the trade-off this imposes. And it reviews how region-based management can be used to enforce deterministic resource clean-up.

# 引用租借：Borrowing Data

在本讲座的最后一部分，我将谈论Rust如何用借用的概念来扩展所有权，以及这如何适用于内存以外的资源的管理。In this final part of the lecture, I’ll talk about how Rust extends ownership with the idea of borrowing, and how this can apply to management of resources other than memory. 

![](/static/2022-02-17-03-27-54.png)

* 我们在上一部分中看到，函数可以在它们之间传递数据的所有权。我们看到了函数是如何取得它们所传递的数据的所有权的，以及它们如何将数据的所有权返回给它们的调用者。We saw in the previous part that functions can pass ownership of data between them. We saw how functions take ownership of data they’re passed, and how they can return ownership of data to their caller. 
* 我们讨论了这与内存管理的关系，当一个对象在函数结束时超出范围，内存将被释放。We discussed how this relates to memory management, with memory being freed when an object goes out of scope at the end of a function. 
* 而且，我们展示了在单一所有权规则的帮助下，Rust如何利用这一点来提供一个基于区域的自动内存管理方案。这可以起作用，但反复向函数传递和返回数据的所有权是不方便的。And, we showed how, with the aid of the single ownership rules, Rust can leverage this to provide an automatic region-based memory management scheme. This can work, but repeatedly passing and returning ownership of data to and from functions is inconvenient. 
* 为了使之更容易，Rust用借来的数据的想法来增强所有权规则。Rust中的函数可以把对数据的引用作为参数。To make this easier, Rust augments the ownership rules with the idea of borrowed data. Functions in Rust can take references to data as parameters. 

# 迭代器无效-原生租借问题: Iterator Invalidation - Problems with Naive Borrowing

![](/static/2022-02-17-03-49-55.png)

**在这个例子中，borrow()函数改变了向量的内容。它把一个新元素推到了向量的末端。在这种情况下，它这样做是安全的。但这并不总是安全的**。In this example, the borrow() function changes the contents of the vector. It pushes a new element onto the end of the vector. And in this case, it’s safe for it to do so. But this is not always safe.

* 例如，**如果main()正在对向量的内容进行迭代，并且在迭代过程中向修改向量的函数传递了一个可变的引用，这可能会导致元素被跳过或重复，或者导致用不一致的数据计算结果**。这是一个被称为迭代器无效化的问题。 For example, if main() was iterating over the contents of the vector, and passed a mutable reference to that vector to a function that modified it, while that iteration was in progress, this might lead to elements being skipped or duplicated, or to a result to be calculated with inconsistent data. This is a problem known as iterator invalidation.

# 不同引用-安全租借：Safe Borrowing

![](/static/2022-02-17-03-56-18.png)
![](/static/2022-02-17-03-56-10.png)
![](/static/2022-02-17-03-56-56.png)
![](/static/2022-02-17-03-59-18.png)

为了避免迭代器失效和其他问题，Rust中的引用有两种不同的类型，并且对它们的使用方式有限制。Rust有两种不同类型的指针；两种不同类型的引用。To avoid iterator invalidation, and other problems, references in Rust come in two different types, and have restrictions on how they can be used. Rust has two different types of pointer; two different types of reference. 

* 第一种写法是&T，是对T类型的**不可变对象的共享引用**。* The first is written &T, and is a shared reference to an immutable object of type T. 
* 第二种是写成&mut T，是对T类型的**可变对象的唯一引用**。* The second is written &mut T, and is a unique reference to a mutable object of type T. 

**Rust编译器和运行时系统一起工作，以控制如何使用引用，并跟踪引用的所有权和引用的值**。有三个基本规则。The Rust compiler and runtime system work together to control how references can be used, and to track ownership of references and the referenced values. There are three fundamental rules. 

* 一个T类型的对象可以**被一个或多个&T类型的引用所引用**。但是，**对于同一个对象，不可能同时拥有可变和不可变的引用**。* An object of type T can be referenced by one or more references of type &T. Or it can be referenced by exactly one reference of type &mut T. But it’s not possible to have both mutable and immutable references to the same object. 
* 如果**一个对象被定义为不可变的，那么就不可能对它有一个可变的引用**。* If an object is defined to be immutable, it’s not possible to take a mutable reference to it. 
* 如果**一个对象被定义为可变的，那么对【该对象的不可变的引用就会在不可变的引用期间使其不可变**】。* If an object is defined to be immutable, it’s not possible to take a mutable reference to it. 

这些限制**使指针在Rust中的工作方式变得复杂**。而且**它们限制了可以编写的程序的范围。但是它们允许函数安全地借用对象，而不需要让出所有权**。* These restrictions complicate how pointers work in Rust. And they limits the set of programs it’s possible to write. But they allow functions to safely borrow objects, without needing to give away ownership.

* 在Rust程序中，**1.要想改变一个对象，你必须拥有这个对象，并且它没有被标记为不可变的。2.或者你必须拥有它的唯一&mut引用**。这些规则防止了迭代器的无效化。* In a Rust program, to be able to change an object, you must either own the object, and it not be marked as immutable. Or you must own the only &mut reference to it. These rules prevent iterator invalidation.
* Rust中的**迭代器被设计为对它们所迭代的对象取一个不可变的引用**。这**保证了该对象不会发生变化，也保证了对该对象的可变引用不会存在（因为不允许同时存在**）。如果被迭代的对象不能改变，那么迭代器也就不能被无效化。**编译器会检查并执行这些规则**。* Iterators in Rust are designed to take an immutable reference to the object over which they iterate. This guarantees that the object can’t change, and that no mutable references to the object can exist. If the object being iterated over cannot change, the iterator cannot be invalidated. The compiler checks and enforces these rules.

# 所有权追踪-优点：Benefits

![](/static/2022-02-17-04-11-29.png)

通过跟踪所有权和控制指针的使用方式，**Rust将其他语言中的各种运行时错误变成了编译时错误**。By tracking ownership, and controlling how pointers are used, Rust turns various issues that are run-time bugs in other languages into compile-time errors.

* Rust**防止了 "使用后"（use-after-free）的错误，因为它使返回数据的引用不可能超过被引用数据的寿命**。* Rust prevents use-after-free bugs by making it impossible to return references to data to outlive the data being referenced. 
  * ![](/static/2022-02-18-02-22-34.png)
* Rust**防止迭代器失效**，因为它**不可能在迭代器存在时改变被迭代的对象**。* Rust prevents iterator invalidation, by making it impossible to change the object being iterated over whilst the iterator exists. 
  * 迭代器需要一个对象的不可变引用
* **Rust还防止了多线程之间的竞赛条件，因为关于指针的规则使得两个线程【不可能各自拥有对同一个对象的可变引用**】。* And Rust prevents race conditions between multiple threads, because the rules about pointers make it impossible for two threads to each have a mutable reference to the same object. 
  * 只允许存在一个可变引用

所有这些行为都是在**编译时检查**的。而Rust有高效的运行时行为。Rust编译器生成的分配和释放内存的代码与使用malloc()和free()的正确编写的C程序完全相同。All these behaviours are checked at compile time. And Rust has efficient run-time behaviour. The Rust compiler generates exactly the same code to allocate and free memory as would a correctly written C program using malloc() and free()

* 不同的是，编译器确保malloc()和free()的**调用是在正确的位置**。因此，**Rust代码的时间和内存使用是可以预测的**，就像一个正确编写的C程序一样。Rust在内存分配和释放的时间上都是确定的。* The difference is that the compiler ensures the malloc() and free() calls are in the correct places. As a result the timing and memory usage of Rust code is a predictable as a correctly written C program. Rust is deterministic in when memory is both allocated and freed.

# 局限性-基于区域内存管理：Limitations of Region-based Systems

![](/static/2022-02-17-04-25-43.png)

Rust使用的基于区域的内存管理方法有一些限制。主要的是，Rust通过限制可能编写的程序类型来确保正确性。**关于所有权和借用的规则使得某些数据结构无法在安全的Rust中表达**。The region-based approach to memory management used by Rust has some limitations though. Primarily, Rust ensures correctness by limiting the types of program it’s possible to write. The rules about ownership and borrowing make it impossible to express certain data structures in safe Rust. 

例如，**不可能编写使用包含引用循环的数据结构的代码**。最典型的例子是，在安全Rust中不可能写出**双链表**。For example, it’s not possible to write code that uses data structures that contain reference cycles. The canonical example of this, is that it’s not possible to write a doubly linked list in safe Rust.

* 如果你看一下幻灯片上的例子，你有一个包含元素a、b和c的列表，你会发现不可能在最后添加一个元素d。* If you look at the example of the slide, where you have a list containing elements a, b, and c, you’ll see that it’s not possible to add an element, d, to the end. 
* 你可以取一个对元素c的不可变的引用，然后把它加到元素d上。这可以做到，因为Rust允许对C的两个不可变的引用存在--一个来自元素b，一个来自元素d。* You can take an immutable reference to element c, and add it to element d. This works, since Rust allows two immutable references to C to exist – one from element b and one from element d.
* 但是，您**不能做的是对元素 c 进行可变引用，以便修改它以添加对元素 d 的引用**。这是**因为已经有一个对元素 c 的不可变引用，由元素 b 持有，并且你不能同时拥有对同一个对象的可变引用和不可变引用**。 What you can’t do, though, is take a mutable reference to element c, in order to modify it to add a reference to element d. This is because there’s already an immutable reference to element c, held by element b, and you can’t have both mutable and immutable references to the same object. 

对引用的限制是为了**防止竞赛条件、迭代器无效等等，也是为了防止循环数据结构**。而且，这不仅仅是双链表。它们防止任何包含指针循环的数据结构。The restrictions on references that prevent race conditions, iterator invalidation, and so on, also prevent cyclic data structures. And it’s not just doubly linked lists. They prevent any data structure that contains a loop of pointers. 

* 这是Rust中引用工作方式的一个基本限制。它以**表现力换取安全性**。* It’s a fundamental limitation of the way references work in Rust. It trades expressive power for safety. 
* Rust的设计者认识到了这一点，并添加了一个逃生舱口。* The designers of Rust recognised this, and added an escape hatch. 

Rust也有第三种类型的引用，被称为**原始指针**。Rust also has a third type of reference, known as the raw pointer. 

* 原始指针的工作方式就像C语言中的指针一样。它们**允许你规避Rust对可变和不可变引用的限制，并使你有可能以与C语言完全相同的方式编写循环数据结构**。一个使用原始指针的Rust程序和C程序一样，**都有可能出现内存安全问题**，比如释放后使用的错误，迭代器无效，以及竞赛条件。* Raw pointers work just like pointers in C. They allow you to circumvent the restrictions that Rust imposes on mutable and immutable references, and make it possible to write cyclic data structures in exactly the same way you would do so in C. Of course, by allowing you to circumvent these restrictions, you lose the safety guarantees of Rust. A Rust program that uses raw pointers is as likely to suffer from memory safety issues, such as use after free bugs, iterator invalidation, and race conditions, as is a C program. 
* 为了明确这一点，**Rust要求在代码中明确地将原始指针的使用标记为不安全**。它警告程序员，并使其很容易发现这种使用。* To make this clear, Rust requires use of raw pointers to be explicitly labelled as unsafe in the code. It warns the programmer, and makes it easy to find such uses. 

安全的Rust还有一个限制，那就是它**不能表达可变数据的共享所有权**。There’s a second limitation of safe Rust, which is that it can’t express shared ownership of mutable data. 

* **不可变数据的共享所有权是直截了当的。许多不同的引用都指向一个不能改变的对象，这是可以的**。* Shared ownership of immutable data is straight-forward. It’s okay for many different references to point to an object that cannot change. 
* 但是，**对可变数据的共享所有权是有问题的，因为它有可能导致竞争条件的产生**。这就是为什么Rust**只允许一个值的单一可变引用同时存在**。* Shared ownership of mutable data is problematic, though, because it potentially open up race conditions. This is why Rust only allows a single mutable reference to a value to exist at once. 
* 但是，偶尔，很少，你需要共享易变的状态。如果你需要的话，**Rust有一个RefCell-of-T类型。它包裹了一些T类型的值，并动态地执行了借用规则**。* But, occasionally, rarely, you need shared mutable state. If you do, Rust has a RefCell-of-T type. This wraps some value of type T, and dynamically enforces the borrowing rules. 
  * 也就是说，它**允许调用者借用或可变地借用被包装的值，并在运行时强制规定只能有不可变的借用，或单个可变的借用，但不能同时进行**。* That is, it allows callers to borrow, or mutably borrow, the wrapped value, and enforces at run time that there can only be immutable borrows, or a single mutable borrow, but not both. 
  * RefCell类型提供了与常规Rust借用规则基本相同的保证，**但在运行时而不是在编译时强制执行**。* The RefCell type provides essentially the same guarantees as the regular Rust borrowing rules, but enforced at run time rather than at compile time. 
  * 这意味着试图采取，例如，**对被包装对象的几个可变引用，将导致代码执行时出现警告，而不是编译失败**。RefCell是安全的，因为它不会导致未定义的行为，但它会**导致【运行时】失败**。* This means that attempts to take, for example, several mutable references to the wrapped object, will cause a panic when the code executes, rather than failing to compile. The RefCell is safe, in that it never causes undefined behaviour, but it can cause a run time failure.

---

不过，基于区域的内存管理的最大问题是，它迫使程序员在设计的早期就明确考虑对象的所有权。我认为，这在多大程度上是个问题，取决于你的背景。Possibly the biggest issue with region-based memory management, though, is that it forces the programmer to consider object ownership explicitly, and early in the design. To what extent this is a problem depends, I think, on your background. 

* 迫使人们尽早明确地考虑对象的所有权 Forces consideration of object ownership early and explicitly
* 一般来说是好的做法，**但在设计过程的早期增加了概念性的负担**--可能会阻碍探索性的编程 Generally good practice, but increases conceptual load early in design process – may hinder exploratory programming
  * 如果你有C语言编程的经验，这往往不是一个问题。编写正确的C语言程序还需要仔细考虑数据所有权，知道哪些函数malloc()数据，哪些函数free()数据。* If you’re experienced at programming in C, this tends to be a non-issue. Writing correct C programs also requires careful consideration of data ownership, to know what functions malloc() data and what functions free() that data. 
    * Rust本质上编纂和执行了那些写得很好的C语言程序往往采用的规则。* Rust essentially codifies and enforces the rules that well-written C programs tend to adopt anyway. 
  * 如果你的经验是像Python或Java这样的语言，其中**使用垃圾收集器或引用计数隐藏了很多内存管理的复杂性，那么需要开始考虑所有权是一个更多的负担**。在这种情况下，用Rust进行有效的编程可能**需要改变你的思维**。* If you’re experience is rather with a language like Python or Java, where the use of a garbage collector or reference counting hides a lot of the complexity of memory management, then needing to start thinking about ownership is more of a burden. In this case, programming effectively in Rust may require a shift in your thinking.

# Summary-基于区域内存管理：Region-based Memory Management

![](/static/2022-02-17-04-40-04.png)

我们对基于区域的内存管理的介绍到此结束。这是Rust的一个比较特殊的功能。它提供了一种**高效且可预测的内存管理方式，并提供了强大的正确性保证，可以防止许多常见的错误。但它是通过限制可以编写的程序类型，以及让程序员明确考虑数据所有权来实现的**。 That concludes our introduction to region-based memory management. This is one of the more unusual features of Rust. It provides an efficient and predictable way of managing memory, and offers strong correctness guarantees that can prevent many common bugs. But it does so by constraining the types of program that can be written, and by making the programmer explicitly consider data ownership.

# 资源管理-(析构)确定性回收：Resource Management-Deterministic Cleanup

![](/static/2022-02-17-04-45-38.png)

正如我们所看到的，Rust跟踪数据的所有权，并在对该内存的引用超出范围时确定地释放堆分配的内存。**特定的类型可以使用这种所有权跟踪来实现自定义的析构器，对它们拥有的资源进行确定性的清理**。As we’ve seen, Rust tracks data ownership, and deterministically frees heap allocated memory when references to that memory go out of scope. Particular types can use this ownership tracking to implement custom destructors that provide deterministic clean-up of resources they own. 

* 如果一个类型实现了**Drop特性**，那么运行时将在该类型的实例的结束时，**当它们超出范围时，调用drop()方法。这使得这些实例能够自我清理**。* If a type implements the Drop trait, then the runtime will call the drop() method on instances of that type at the end of their lifetime, when they go out of scope. This allows those instances to clean-up after themselves. 
* 例如，文件类实现了 Drop 特质，当文件对象超出范围时关闭底层文件。Python 对此有特殊的语法，如幻灯片上所示。**在Rust中**，就像在C++中一样，**当对象超出范围时，清理自然发生，不需要明确的语法**。* For example, the File class implements the Drop trait to close the underlying file when file objects go out of scope. Python has special syntax for this, as shown on the slide. In Rust, much like in C++, the cleanup happens naturally when the object goes out of scope, without the explicit syntax.

# 所有权&状态-资源管理：Resource Management-Ownership and States

![](/static/2022-02-17-04-50-56.png)

最后，正如我们在第4讲讨论基于结构的状态机时看到的，**所有权跟踪允许状态转换被强制执行**。Finally, as we saw in the discussion of struct-based state machines in Lecture 4, ownership tracking allows state transitions to be enforced.

* 一个状态机可以用**结构来表示状态**，并**持有任何需要的状态变量**。* A state machine can be defined using structs to represent the state, and to hold any needed state variables.
* **状态转换**可以通过在这些**结构上定义函数来实现，这些函数消耗自身，并返回一个新的状态**。* And state transitions can be implemented by defining functions on those structs that consume self, and return a new state.

幻灯片显示了一个例子，方法 login() 和 disconnect() 是在 UnauthenticatedConnection 结构上实现的。The slide shows an example, where methods login() and disconnect() are implemented on an UnauthenticatedConnection struct.

* 请注意，这两个方法都将**self作为其第一个参数，而不是&self**。也就是说，它们**取得了它们所实现的结构的所有权，而不是借用该结构**。这意味着它们会消耗自我。* Note that both of these take self as their first parameter, not &self. That is, they take ownership of the struct on which they’re implemented, rather than borrow that struct. This means they consume self.
* 它们会销毁被调用的对象。也就是说，**它们强迫代表状态的对象被销毁。并且它们返回一个新对象的所有权，代表系统的新状态**。* They destroy the object on which they’re called. That is, they force the object representing the state to be destroyed. And they return ownership of a new object, representing the new state of the system.
* 这将**强制清理由该状态持有的、没有明确复制到新状态的任何数据**。它强制了一个**干净的状态转换**。链接的博文进一步讨论了这些问题，我鼓励你去读它。* This forces the cleanup of any data held by that state that’s not explicitly copied to the new state. It enforces a clean state transition. The blog post linked talks about these issues further, and I encourage you to read it.

# ==========

# Readings

1. http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/
2. http://phrack.org/issues/49/14.html#article
3. Source: P. Wilson, “Uniprocessor garbage collection techniques”, Proc IWMM’92, DOI:10.1007/BFb0017182
4. https://blog.systems.ethz.ch/blog/2018/a-hammer-you-can-only-hold-by-the-handle.html
   1. 在第4讲中描述的基于结构的管理状态机的方法
5. https://yoric.github.io/post/rust-typestate/