# L2

* [L2](#l2)
* [What is System Programming](#what-is-system-programming)
* [内存管理 & 数据表示：Memory Management and Data Representation](#内存管理--数据表示memory-management-and-data-representation)
* [I/O操作：I/O Operations](#io操作io-operations)
* [共享状态管理:Management of Shared State](#共享状态管理management-of-shared-state)
* [效率：Performance](#效率performance)
* [Sys Programming](#sys-programming)
* [===============](#)
* [The State of the Art](#the-state-of-the-art)
* [Unix and C: Strengths](#unix-and-c-strengths)
* [Unix and C: Weaknesses](#unix-and-c-weaknesses)
* [Overall](#overall)
* [===============](#-1)
* [物理限制-End of Moore's Law: Physical Limitation](#物理限制-end-of-moores-law-physical-limitation)
* [邓纳德缩放: The End of Moore’s Law (2/2): Dennard Scaling](#邓纳德缩放-the-end-of-moores-law-22-dennard-scaling)
* [并发性增加：Increasing Concurrency](#并发性增加increasing-concurrency)
* [安全性需求增加：Increasing Need For Security](#安全性需求增加increasing-need-for-security)
* [移动性和连接性增加:Increasing Mobility and Connectivity](#移动性和连接性增加increasing-mobility-and-connectivity)
* [===============](#-2)
* [如何发展：Next Steps in Systems Programming](#如何发展next-steps-in-systems-programming)
* [现代类型系统：Modern Type System](#现代类型系统modern-type-system)
* [函数式编程：Functional Programming](#函数式编程functional-programming)
* [改进内存管理&安全性：How to improve Memory Management & Safety](#改进内存管理安全性how-to-improve-memory-management--safety)
* [改进安全性：How to improve Security](#改进安全性how-to-improve-security)
* [改进并发性支持：Improve support for concurrency](#改进并发性支持improve-support-for-concurrency)
* [改进正确性：Improve Correctness](#改进正确性improve-correctness)
* [Overall](#overall-1)
* [===============](#-3)
* [Reading](#reading)

# What is System Programming

* 系统程序包括基础设施组件：**操作系统、设备驱动程序、网络协议和服务** Systems programs comprise infrastructure components: operating systems, device drivers, network protocols, and services
  * 那么，什么是系统程序？它们是构成基础设施的程序。它们由操作系统、设备驱动程序、网络协议栈和服务组成，计算生态系统的其他部分就是在这些基础上建立的。 So, what are systems programs? They’re the programs that form the infrastructure. They comprise the operating systems, device drivers, network protocol stacks, and services on which the rest of the computing ecosystem is built.
* 它们往往受制于They tend to be constrained by:
  * 内存管理和数据表示Memory management and data representation
    * 系统程序的特点是有严格的性能限制。它们**必须有效地管理内存，并实现高性能**，同时要**符合外部指定的数据表示的约束**。设备驱动和网络协议实现的作者没有选择自己的数据表示的权利：他们必须与外部指定的格式完全匹配。而且他们必须在实现高性能的同时做到这一点。这令人惊讶地排除了许多编程语言和环境，因为它们不提供这样的控制。例如，用Java或Python**编写高性能的系统程序**是很困难的，因为它们**不能让你控制数据在内存中的布局。像C、C++和Rust这样的语言确实提供了这种控制**。 Systems programs tend to be characterised by strict performance constraints. They must effectively manage memory, and achieve high performance, while matching externally-specified constraints on the data representation. Authors of device drivers and network protocol implementations don’t have the luxury of choosing their own data representation: they must match externally specified formats exactly. And they must do so while achieving high performance. This rules out surprisingly many programming languages and environments, since they don’t provide such control. It’s difficult to write high-performance systems programs in Java or Python, for example, since they don’t give you control over how data is laid out in memory. Languages like C, C++, and Rust do give such control.
  * I/O操作 I/O operations
    * **系统程序需要有效地管理I/O**。在某种程度上，这是上一个关于数据布局的观点的延续。**如果数据的内部和外部表示方式不同，那么格式转换就会损害性能。但这也是系统程序的I/O性能是根本**。如果一个单一的应用程序很慢，那么它可以被替换，对系统的其他部分影响很小。如果底层操作系统很慢，整个系统就会受到影响。 Systems programs need to manage I/O efficiently. In part, this is a continuation of the previous point about data layout. If the internal and external representations of data differ, then the format conversion hurts performance. But it’s also that I/O performance of systems programs is fundamental. If a single application is slow, then it can be replaced with  minimal impact on the rest of the system. If the underlying operating system is slow, the entire system is affected.
  * 共享状态的管理Management of shared state
    * **系统程序也需要有效地管理共享状态**。现代的硬件越来越多的是**多核**的，而现代的应用程序是**并发**的。操作系统资源、设备驱动、网络协议和其他库总是**被多个进程和多个上下文同时访问**。在这个层面上的**竞赛条件、死锁和不良性能**会影响到系统上运行的一切。这对有效利用现有资源至关重要。 Systems programs also need to effectively manage shared state. Modern hardware is increasingly multicore, and modern applications are concurrent. Operating systems resources, device drivers, network protocols, and other libraries are always being accessed by multiple processes, and in multiple contexts, at once. Race conditions, deadlocks, and poor performance at this level affects everything running on the system. It’s critical to making effective use of the available resources.

# 内存管理 & 数据表示：Memory Management and Data Representation

* 可预测性 Predictability:
  * 系统程序的内存管理必须是可预测的。必须有可预测的内存使用界限。**系统所需的内存应该随着它所执行的任务而扩展，而且与数据相比，开销应该很小。应该清楚地知道使用了多少内存，以及何时使用了这些内存，这样就可以理解整个系统**。 Memory management for systems programs must be predictable. There must be predictable bounds on memory usage. The memory needed by the system should scale with the tasks it’s performing, and overheads should be small compared to the data. It should be clear how much memory is used, and when that memory is used, so that the system as a whole can be understood. 
  * 对于实时应用来说，时间必须是有界限的 Timing must be bounded for real-time applications
    * 随着实时应用程序变得越来越普遍，这一点尤其重要，**因为内存管理的不可预测性会扰乱应用程序的计时性能**。This is especially important as real-time applications become more common, since unpredictability in memory management can disrupt application timing performance. 
  * 对内存使用的限制 Bounds on memory usage
    * 不过，一致的和有约束的内存使用总体上是有益的，特别是随着相对有内存限制的设备，如物联网设备、可穿戴设备和智能手机的激增。Consistent and bounded memory usage is beneficial overall though, especially as relatively memory constrained devices, such as IoT devices, wearables, and smartphones, proliferate.
* 数据定位 Data locality:
  * **缓存线共享影响性能** Cache line sharing impacts performance
  * 确保**数据被对齐**并装入高速缓存线以获得高性能 Ensuring data is aligned and packed into cache lines for high performance
* 数据表示 Data representation:
  * 具有固定布局控制寄存器的设备驱动程序 Device drivers with fixed-layout control registers
  * 数据表示和定位对性能很重要。**该图显示了对象的大小和它们的间隔（称为跨距）对一个典型的现代系统的读取性能的影响。我们看到，随着被读取对象的大小增加，读取的吞吐量就会下降。同样，随着跨度的增加，也就是说，随着对象在内存中的间隔越来越大，吞吐量也在下降。吞吐量的下降可以是戏剧性的：最坏的情况下，与峰值相比，会有几个数量级的性能损失。其原因是CPU的缓存**。现代的处理器可以非常快速地访问内存中**相互靠近的小对象**。而将较大的对象取到高速缓存中则比较慢。而从内存中获取间隔较远或不规则的对象则更慢。**有效的系统程序在内存中安排数据，使相关的对象共处一地，以实现高性能**。这需要一种能够精确控制数据布局的编程语言。 Data representation and locality matters for performance. The diagram shows the effects of object sizes and their spacing, known as the stride distance, on read performance for a typical modern system. We see that as the size of the objects being read increases, the read throughput drops. Similarly, as the stride increases, that is, as objects are spaced further apart in memory, throughput drops. This drop in throughput can be dramatic: the worst case shows several orders of magnitude performance loss compared to the peak. The cause is the CPU cache. Modern processors can access small objects, located close to each other in memory, extremely quickly. Fetching larger objects into the cache is slower. And fetching widely, or irregularly, spaced objects from memory is slower still. Effective systems programs arrange data in memory such that related objects are co-located, to achieve high performance. This requires a programming language that gives precise control over data layout.
  * 网络协议的实现必须符合指定的数据包布局 Network protocol implementations must conform to specified packet layout
    * 同样地，设备驱动程序和网络协议的实现必须确认为固定的外部布局。无论是与硬件控制寄存器的结构相匹配，还是与标准网络协议数据单元的格式相匹配，这类系统都必须对数据表示有精确的位级控制。 Similarly, device drivers and network protocol implementation must confirm to fixed external layouts. Whether matching the structure of a hardware control register, or the format of a standard network protocol data unit, such systems must have exact bit-level control over the data representation.
* **系统编程语言**提供**对内存管理和数据表示的控制**--其他语言缺乏这种控制 Systems programming languages offer control of memory management and data representation – others languages lack such controls

# I/O操作：I/O Operations

* 网络性能越来越成为一个瓶颈 Network performance increasingly a bottleneck:
  * 图表显示了以太网比特率随时间的变化 - 无线链接遵循类似的曲线 Chart shows Ethernet bit rate over time – wireless links follow a similar curve
  * 随着时间的推移，密切跟踪指数级的增长--与CPU速度不同，其增长在2000年代中期基本停止 Closely tracking exponential growth over time – unlike CPU speed, where growth mostly stopped mid-2000s
  * MTU保持不变，但数据包速率增加；处理每个数据包的周期减少 MTU remains constant but packet rate increases; fewer cycles to process each packet
  * 系统程序的第二个制约因素往往是I/O性能。该图显示了以太网的传输速率是如何随着时间的推移而增加的，从最初的1Mbps数据速率，到40Gbps的部分，以及随着100Gbps以太网的出现。很明显，以太网的传输率，以比特/秒为单位，仍在以**接近指数的速度增长**。虽然这种情况一直在发生，**但最大的以太网数据包大小，即MTU，一直保持在1500字节左右。其结果是，每秒发送的数据包数量呈指数级增长**。无线链接速度也遵循类似的曲线。这正在成为问题，因为单核CPU的性能在2000年代中期达到了顶峰。十多年来，**每秒必须处理的网络数据包数量一直在增加，而必须处理这些数据包的处理器的性能却没有什么提高。其结果是，数据包的处理效率必须比以前更高。系统用于处理每个数据包的时间更少，因为它必须用大致相同的资源处理更多的数据包**。更糟糕的是，在这种情况发生的同时，我们也看到，为了提高**安全性，几乎所有通过网络的数据都被加密了，而且流媒体和互动视频的使用也越来越多。这两种情况都增加了必须为每个数据包执行的工作量。每个数据包的工作量更大，每秒钟的数据包更多，而处理器的速度并没有提高多少，这些因素的结合使得编写网络设备驱动程序、协议栈实现和网络应用变得越来越困难**。 The second constraint on systems programs tends to be I/O performance. The chart shows how the transmission rate of Ethernet has increased over time, from the initial 1Mbps data rate, to 40 Gbps parts, and with 100 Gbps Ethernet becoming available. It’s clear that the transmission rate of Ethernet, in bits per second, is still growing at something close to an exponential rate. While this has been happening, the maximum Ethernet packet size, the MTU, has remained constant at 1500 bytes. The result is that the number of packets sent per second has increased exponentially. Wireless link speeds follow a similar curve. This is becoming problematic, because single core CPU performance peaked in the mid-2000s. For over a decade now, the number of network packets that must be processed per second has been increasing, while performance of the processors that must handle those packets has improved little. The result is that packets must be processed more efficiently than ever before. The system has less time to spend processing each packet, since it must process more packets with approximately the same amount of resources. To make matters worse, while this has been happening, we’ve also seen the move to encrypt virtually all of the data passing over the network, to improve security, and the increasing use of streaming and interactive video. Both of these increase the amount of work that must be performed for each packet. The combination of more work per packet, more packets per second, and processors the are not getting much faster, make writing network device drivers, protocol stack implementations, and networked applications, increasingly difficult.
* 固态硬盘的性能在文件系统访问方面有类似的趋势 SSD performance on a similar trend for file system access
  * 固态磁盘性能也存在类似趋势。 I/O 堆栈、网络和磁盘正迅速成为整体系统性能的关键瓶颈 Similar trends exist for solid state disk performance. The I/O stack, network and disk, is fast becoming a critical bottleneck in overall system performance.
* 系统软件的I/O性能对整个系统性能至关重要 I/O performance of systems software critical to overall system performance
  * 设备驱动程序、网络协议栈、文件系统 Device drivers, network protocol stack, file system
  * 支持 I/O 的系统软件必须非常高效。Systems software to support I/O has to be highly efficient.

# 共享状态管理:Management of Shared State

* **负责协调共享易变状态**,(系统程序)。Systems programs responsible for coordinating shared mutable state:
  * 跨层共享的状态/在内核和应用程序之间共享的状态 State shared across layers/between kernel and applications
    * 零拷贝网络的数据结构 Data structures for zero-copy networking
    * TCP堆栈的报头处理和状态 Header processing and state for the TCP stack
  * 线程之间共享的状态 State shared between threads
    * 内核的内部状态 Internal state of the kernel
    * 文件系统File systems
    * 网络代码 Network code
  * 对性能要求很高 Highly performance critical
* 系统编程语言允许在各层和/或线程之间共享数据 - 其他语言不允许/不鼓励这种共享 Systems programming languages allow sharing data between layers and/or threads – other languages disallow/discourage such sharing
* 系统程序的最后一个限制是**共享状态的管理**。**系统程序负责协调操作系统和系统上运行的应用程序之间共享资源的使用。它们管理操作系统内核的内部状态、文件系统、网络代码、设备驱动程序等。所有这些都由多个线程同时访问，因为有不同的应用程序访问操作系统资源**。如果[**应用程序**]程序员愿意，应用程序可以以忽略并发的方式编写，并且只使用单个执行线程。支持这些应用程序的**系统程序没有该选项。它们必须支持在多核硬件上同时运行的多个应用程序。并发性和并行性是[系统程序]普遍关注的问题，无法避免** The final constraint on systems programs is management of shared state. Systems programs are responsible for coordinating use of shared resources between the operating system and the applications running on the system. They manage the internal state of the operating system kernel, the file systems, network code, device drivers, etc. All this is accessed concurrently by multiple threads, as different applications access operating system resources. Applications programs can be written in a way that ignores concurrency, and uses only a single thread of execution, if the application programmer so chooses. The systems programs that support those applications don’t have that option. They must support multiple applications running at once, on multicore hardware. Concurrency and parallelism are pervasive concerns for systems programs, and cannot be avoided.

# 效率：Performance

* 系统基础设施的性能从根本上影响到整个系统和应用程序的性能 Systems infrastructure performance fundamentally affects overall system and application performance
  * 移动设备的电池寿命有限 Mobile devices have limited battery life
  * 数据中心的效率和电力消耗 Data centre efficiency and power consumption
  * 所有这些问题的共同点是，构成基础设施的系统程序的性能从根本上影响了整个系统的性能。**系统程序的效率低下将降低性能，并增加整个系统的功耗，而不管它运行的是什么应用程序**。 What is common to all these concerns is that performance of the systems programs comprising the infrastructure fundamentally affects the overall system performance. Inefficiencies in systems programs will reduce performance, and increase power consumption of the entire system, irrespective of the application it’s running.
* 系统组件往往是整体性能和电源效率的瓶颈所 Systems components often the bottleneck in terms of overall performance and power efficiency
  * 仅仅是因为它们是高层组件所依赖的基础 Simply because they’re the basis on which the higher- level components depend
  * 这意味着系统组件往往是瓶颈，仅仅是因为它们是高层组件所依赖的基础。 This means that systems components are often the bottleneck, simply because they’re the basis on which higher-layer components depend.

# Sys Programming

这些趋势推动**系统编程语言提供低级别的控制**。为了达到必要的性能和效率，程序必须能够控制内存中的数据布局，管理数据的访问时间和顺序，并精确控制数据的共享时间和方式。这就是为什么像C和C++这样的低级控制语言，在系统编程中仍然很受欢迎。一个C语言的程序员，如果他们选择的话，可以精确地控制内存中的数据布局，他们可以灵活地选择线程间数据共享的时间和方式。他们不必行使这种控制，但在必要时可以使用。提供这种控制是系统编程语言的一个标志。**它促使语言和它的运行时间在如何编译成机器指令以及各种操作的成本方面更加透明和可预测，并有利于更简单、更可预测的运行环境**。像Java、Python和Go这样不提供这种透明度和控制的语言，并不太适合这种低级别的系统编程。 These trends push systems programming languages to offer low-level control. To achieve the necessary performance and efficiency, it’s essential that the program be able to control the layout of data in memory, to manage when, and in what order,  data is accessed, and to have precise control of when, and how, data is shared. This is why languages, such as C and C++, that give such low-level control, remain popular for systems programming. A C programmer can, if they choose, control precisely the layout of data in memory, and they have the flexibility to choose exactly when and how data is shared between threads. They don’t have to exercise that control, but it’s available if necessary. Providing this control is a hallmark of systems programming languages. It pushes the language, and it’s runtime, to be more transparent and predictable in how it compiles to machine instructions, and about the costs of various operations, and to favour simpler, more predictable, runtime environments. Languages such as Java, Python, and Go, that do not provide such transparency and control, are not well suited to such low-level systems programming.

# ===============

# The State of the Art

![](/static/2022-01-17-01-35-14.png)

# Unix and C: Strengths

![](/static/2022-01-17-01-38-29.png)

* 此外，C编程语言是可移植的，易于使用，并提供了相当高层次的功能--在它的时代。对于用汇编语言编写系统程序的程序员来说，**C语言中指针的抽象化大大简化了编写可移植设备驱动程序和其他低级代码的工作。C语言中指针的概念提供了一个解决许多问题的单一机制。同样的方法可以让你建立复杂的数据结构，操作内存中的数据，并访问硬件控制寄存器--没有其他编程语言为这些用途提供如此简单和成功的抽象概念**。此外，C语言的**类型系统足够强大**，使编写系统程序比编写汇编程序容易得多，但又足够弱，允许别名、铸造和共享数据的方式，这对性能是必要的。例如，一个零拷贝的网络协议栈可以在C语言中干净地实现，当数据包被处理时，将指向数据包内不同偏移量的指针传递给堆栈中的下一层，并将其转换为不同类型。对汇编语言程序员来说，这种别名和类型的灵活性是很自然的，而且可以在C语言中干净地表达出来，但对大多数其他编程语言来说是非常不合适的。 Further, the C programming language was portable, easy to use, and offered features that were quite high-level – for it’s time. To programmers coming from writing systems programs in assembly language, the abstraction of pointers in C greatly simplified writing portable device drivers and other low-level code. The concept of pointers in C provides a single mechanism to solve many problems. The same approach lets you build complex data structures, manipulate data in memory, and access hardware control registers – no other programming language offers such a simple and successful abstraction for such uses. Further, the C type system is strong enough to make writing systems programs significantly easier than writing them in assembly, yet weak enough to allow aliasing, casting, and sharing of data in ways that were necessary for performance. For example, a zero copy network protocol stack can be cleanly implemented in C, passing pointers to different offsets inside a packet, cast to different types, to the next layer in the stack as the packet is processed. Such aliasing and flexibility with types is natural to an assembly language programmer, and can be cleanly expressed in C, but is a very poor fit for most other programming languages.
* 幻灯片上的代码片段给出了一个例子，以展示C语言如何被用来干净地编写可移植设备驱动程序。这其中有两个部分。第一部分是数据类型的定义，即struct ctrl_reg，第二部分是 enable_irq() 函数的定义。该结构定义描述了一些硬件设备的控制寄存器的格式。它使用了C语言的位域语法来指定一个16位控制字的精确布局。enable_irq()函数从位于固定内存地址0x80 00 00 24的控制寄存器r读取数据。它检查忙位，即控制寄存器中的第5位是否清零，如果是，则通过设置irq_enable位并写入控制寄存器来启用中断。这是一个简单的例子，显示了设备驱动程序中常见的那种数据结构和操作，并显示了用C语言编写的设备驱动程序是多么的干净、可移植和可读。 The code fragment on the slide gives an example, to show how C can be used to cleanly write portable device drivers. There are two parts to this. The first is the definition of a data type, struct ctrl_reg, and the second is the definition of the enable_irq() function. The struct definition describes the format of a control register for some hardware device. It uses the bitfield syntax of C to specify the exact layout of a 16 bit control word. The enable_irq() function reads from a control register, r, located at a fixed memory address, 0x80 00 00 24. It checks if the busy bit, the 5th bit in the control register, is clear, and if so, enables interrupts by setting the irq_enable bit and writing to the control register. It’s a simple example, showing the sort of data structure and operation that is common in device drivers, and showing how cleanly, portably, and readably device drivers can be written in C. This sort of clean, low-level, access is one of the key strengths of C.

# Unix and C: Weaknesses

* Unix APIs reflect 1970s/1980s minicomputer architectures - Unix APIs反映了1970/1980年代的微型计算机架构
  * Sockets and file system APIs significant performance bottlenecks套接字和文件系统的API存在明显的性能瓶颈
  * Security architecture insufficiently flexible安全架构不够灵活
  * No portable APIs for mobility, power management, etc. - 没有用于移动性、电源管理等的可移植API。
  * Assumes professional, interactive, systems administration - 假设有专业的、交互式的系统管理
  * 这说明了好处，但Unix和C有什么问题呢？**1.Unix的网络和文件系统API可能是性能瓶颈。它们强调以牺牲额外的系统调用为代价来节省缓冲空间，这种方式在内存容量有限、系统调用不那么昂贵的时候是有意义的，但这并不能反映现代硬件**。2.Unix的安全模型是为了仲裁多个用户对一台昂贵机器的访问，而不是为了控制对单个用户拥有的个人数据的访问。它可以有效地防止我的机器上的其他用户看到我的个人数据，但**不能轻易控制我选择运行的应用程序的访问**。而且，3.**Unix没有可移植的API来解决现代的问题，比如移动性、电源管理等等**。 That explains the benefits, but what’s wrong with Unix and C? The Unix networking and filesystem APIs can be performance bottlenecks. They emphasise saving buffer space at the expense of additional system calls in a way that made sense when memory capacity was limited and system calls were not so expensive, but that doesn’t reflect modern hardware. The Unix security model is designed to arbitrate access by multiple users to a single expensive machine, not to control access to personal data owned by a single user. It can effectively prevent other users on my machine from seeing my personal data, but can’t easily control access for applications I choose to run. And Unix has no portable APIs for modern concerns, such as mobility, power management, and so on.
* C programming language - C编程语言
  * Limited concurrency support → memory model for pthreads poor supported - 有限的并发性支持→对pthreads的内存模型支持不足
  * Undefined behaviour, buffer overflows → security risks - 未定义行为、缓冲区溢出→安全风险
  * Weak type system → difficult to reason about correctness, effectively model problem domain - 薄弱的类型系统→难以推理正确性，难以对问题域进行有效建模
  * C编程语言以指针的形式为内存访问提供了一个强大而灵活的抽象，但这也许过于强大。1.**它太容易造成缓冲区溢出、使用后的错误或逐一错误，或者调用未定义的行为，并导致安全漏洞**。2.**弱类型系统提供了灵活性，但却使系统的正确性难以推理。许多bug的发生是因为类型系统足够灵活，允许一个特定的设计，但却没有足够的能力来检查这个设计的正确性**。3.**而C和Unix对并发的支持是有限的。现代版本的C语言最终确实得到了一个定义明确的模型，即何时跨线程的并发内存访问是可见的，同时还有一个可移植的多线程库，但这些都没有得到很好的支持**。而且，也许更重要的是，不清楚多线程是否是未来正确的并发性抽象。今天，人们经常忘记它，但多线程是C和Unix中极富争议的一个补充。以上好处，提供了更低的开销的并发性。不幸的是，对**竞赛条件和正确性**的担忧也是如此。 The C programming language offers a powerful and flexible abstraction for memory access, in the form of pointers, but this is perhaps too powerful. It’s too easy to enable buffer overflows, use-after-free bugs, or off-by-one errors, or to invoke undefined behaviour, and cause a security vulnerability. The weak type system offers flexibility, but makes it difficult to reason about the correctness of the system. Many bugs happen because the type system is flexible enough to allow a particular design, but not powerful enough to check that design for correctness. And C and Unix have limited support for concurrency. Modern versions of C did, eventually, get a well-defined model for when concurrent memory accesses are visible across threads, along with a portable multi-threading library, but these are not well supported. And, perhaps more importantly, it’s not clear that multi-threading is the right concurrency abstraction going forward. It’s frequently forgotten today, but multi-threading was an extremely controversial addition to C and Unix. The suggested benefits, providing lower-overhead concurrency, were real. Unfortunately, so too were the concerns around race conditions and correctness.

# Overall

* Unix has proven surprisingly resilient and portable – but is it still the right model? Unix已经被证明具有令人惊讶的弹性和可移植性--但它仍然是正确的模式吗？
* Maybe – work-arounds for its limitations exist: 也许吧--存在解决其局限性的工作方法。
  * Kernel bypass networking 内核绕过网络
  * Increasingly baroque package management - 越来越多的巴洛克式软件包管理
  * Containers and sandboxing - 容器和沙箱
  * 总的来说，Unix已经被证明是一个成功。**它有一些局限性，特别是在高性能I/O、电源管理、移动性等方面，但这些大多可以通过扩展来解决，保留旧的API以便向后兼容**--我们将在本课程的后面更多地讨论如何做到这点。更令人担忧的是**安全模型和包管理系统的限制**。越来越多的人【**使用容器、沙盒和虚拟化来解决局限性和提高安全性，这表明底层的安全和共享库机制不能满足当前的需求**】。 Overall, Unix has proven to be a success. It has some limitations, especially around high-performance I/O, power management, mobility, etc., but these can mostly be addressed with extensions, retaining the older APIs for backwards compatibility – and we’ll talk more about how this is done later in the course. More concerning are the limitations of the security model and package management systems. The increasing use of containers, sandboxing, and virtualisation to work around limitations and improve security is a sign that the underlying security and shared library mechanisms are not meeting the current needs.
* The C programming language is increasingly a liability C编程语言越来越成为一种负担
  * Too easy to introduce security vulnerabilities - 太容易引入安全漏洞
  * Too easy to trip over undefined behaviour 太容易被未定义的行为绊倒
  * Insufficient abstractions - 抽象不充分
  * C编程语言正日益成为一种负担。它为内存管理提供了一种灵活的方法，指针抽象也很强大，但事实证明正确使用它太难了。它太容易引入安全漏洞，或者被未定义的行为绊倒。在实践中，似乎没有人能够持续写出正确和安全的C语言程序。这里的答案不能是 "更好的程序员"--他们并不存在。相反，我们需要不那么容易出错的语言。 The C programming language is increasingly becoming a liability. It offers a flexible approach to memory management, and the pointer abstraction is powerful, but it’s proven too difficult to use correctly. It’s too easy to introduce security vulnerabilities, or to trip over undefined behaviour. In practice, no-one seems able to consistently write correct and secure C programs. The answer here cannot be “better programmers” – they don’t exist. Rather, we need less error prone languages. 

# ===============

**影响系统程序的环境变化**。它讨论了摩尔定律的终结和丹纳德定标的崩溃，以及这些**硬件趋势**对微处理器体系结构和**并发性**的影响。它讨论了由于总是开着的连接和互联网的存在，对**安全系统的需求**日益增加，并概述了 c 和 Unix 的一些难以保护的特性。并讨论了移动、电池供电、设备和气候变化对**系统程序中能源效率需求**的影响

# 物理限制-End of Moore's Law: Physical Limitation

![](/static/2022-01-18-20-37-02.png)

摩尔定律是英特尔公司的联合创始人戈登-摩尔在1965年提出的，**由于制造业的改进，可以集成到一个设备上的晶体管的数量大约每两年翻一番**。当在X轴上绘制时间，在Y轴上绘制对数尺度的晶体管数量时，这种指数增长应该显示为一条直线。对于最初的预测，如左图所示，这是真的，但不是很有说服力。它是基于四个数据点，捕捉了1962-1965年。不过，如果我们加入现代数据，这个模式仍然成立。这张图上的橙色点显示了1970年至2018年间发布的处理器的晶体管数量。它们遵循同样的直线关系，至少是近似的。该行业通过英勇的努力，确保了摩尔定律的继续。但是，我们正在迅速接近物理极限。构成现代微处理器的晶体管的特征尺寸是10纳米，一些制造商推出了具有5纳米特征的设备。一个5纳米的特征大约是20个原子宽。摩尔定律的另外四个发生器将导致特征的大小只有一个或两个原子。**事物能小到什么程度是有物理限制的。晶体管将很快停止缩小。摩尔定律将走到尽头**。 Moore’s law is the observation, made by Gordon Moore, the co-founder of Intel, in 1965, that the number of transistors that can be integrated onto a single device doubles roughly every two years, due to improvements in manufacturing. When plotted with time on the x-axis, and number of transistors on a log scale on the y-axis, such exponential growth should appear as a straight line. This is true for the original prediction, shown in the graph on the left, but isn’t very convincing. It was based on four data points, capturing 1962-1965. If we add modern data, though, the pattern still holds up. The orange points on this plot show the number of transistors for processors released between 1970 and 2018. They follow the same straight-line relation, at least approximately. The industry has, through heroic effort, ensured that Moore’s law continues. But, we’re rapidly approaching physical limits. The feature size of the transistors that form modern microprocessors is 10nm, with some manufacturers introducing devices with 5nm features. A 5nm feature is roughly 20 atoms across. Four more generators of Moore’s law would result in features only one or two atoms in size. There is a physical limit in how small things can go. Transistors will stop shrinking soon. Moore’s law will come to an end.

# 邓纳德缩放: The End of Moore’s Law (2/2): Dennard Scaling

![](/static/2022-01-18-20-45-56.png)

一个比摩尔定律有更大影响的问题，尽管它可能不太为人所知，那就是丹纳德缩放法的崩溃。正如我们在右边的方程式中所看到的，**一个晶体管所消耗的功率与开关门的电容、晶体管开关的频率，(即时钟速率)，以及所施加电压的平方成正比**。加上一个常数项，称为漏电流。**而电压和电容又与晶体管的尺寸直接相关**。An issue that’s had greater impact than Moore’s law, although it’s perhaps less well known, is the breakdown of Dennard scaling. As we see in the equation on the right, the power consumed by a transistor is proportional to the capacitance of the switching gate; the frequency at which the transistor switches, that is, the clock rate; and the square of the voltage applied. Plus a constant term, known as the leakage current. The voltage and capacitance, in turn, directly relate to the size of the transistor. 

Dennard缩放关系是这样观察的：**由于摩尔定律，随着晶体管尺寸的缩小，其功耗将减少，因为这降低了电压和电容。这让你可以建造更多的高效计算机。另外，随着电容和电压的降低，你可以提高时钟频率以匹配。这可以让你建立更快的计算机，但使用的功率大致相同**。 The Dennard scaling relation is the observation that, as transistors shrink in size, due to Moore’s law, their power consumption will decrease, since this reduces the voltage and capacitance. This lets you build more power efficient computers. Alternatively,as the capacitance and voltage decrease, you can increase the clock frequency to match. This lets you build faster computers that use roughly the same amount of power. 

从80年代中期的家用电脑到2005年左右，这就是计算机行业的故事。摩尔定律缩小了晶体管的尺寸，并且由于邓纳德缩放，计算机变得更快。在Commodore 64和BBC Micro时代，我们开始时的时钟频率约为1MHz，到了最后，个人电脑的英特尔奔腾四号处理器的运行频率为3.8GHz。**不幸的是，正如我们在该图的绿点中看到的那样，时钟速率在这时停止了增长。原因是漏电流，【当特征尺寸下降到65纳米左右时，漏电流开始呈指数级增长】。随着晶体管尺寸的减小，摩尔定律仍然带来了功率的节省，【但是这些节省必须在保持时钟频率不变的情况下进行】，以平衡由于更大的漏电流而增加的功率消耗**。由于过度耗电产生的热量，要使处理器的速度不被融化，简直是难上加难。由于这个原因，虽然摩尔定律自2000年代中期以来一直在为我们提供更多的晶体管，但时钟速率却一直停滞不前。From the home computers of the mid-1980s, through to around 2005, this was the story of the computer industry. Moore’s law reduced the size of transistors and, due to Dennard scaling, computers got faster. We started with a clock rate of around 1MHz, in the era of the Commodore 64 and BBC Micro, and by the end had with PCs with Intel Pentium IV processors running at 3.8GHz. Unfortunately, as we see in the green points in this figure, the clock rate stopped increasing at that point. The reason is the leakage current, that started to grow exponentially when the feature size dropped below around 65nm. Moore’s law still gave power savings, as the size of transistors decreased, but those savings had to be taken, keeping the clock rate constant, to balance the increased power consumption due to the greater leakage current. It simply became difficult to make processors faster without them melting, due to the heat from the excessive power consumption. For this reason, while Moore’s law has continued to give us more transistors since the mid-2000s, clock rates have remained stalled.

# 并发性增加：Increasing Concurrency

![](/static/2022-01-18-21-19-55.png)

鉴于摩尔定律仍在继续，处理器设计师如何使用这些额外的晶体管？**主要是作为大型缓存的一些组合，并支持多核操作**。从邓纳德定律崩溃后不久开始，当处理器的**时钟速率显然不能再增加了，因为我们已经达到了功耗的极限，我们看到处理器内核的数量开始增加。这在图中显示为黑色的数据点**。有趣的是，核心数量的增加在该图中被绘制成了一条直线。考虑到Y轴上的对数刻度，这意味着【**内核的数量是以指数形式增长的**】。 Given that Moore’s law is continuing, how do processor designers use those additional transistors? Mostly, as some combination of large caches, and to support multicore operation. Starting shortly after the breakdown of Dennard scaling, when it became clear that processor clock rates couldn’t increase anymore, because we’d reached the limit in power consumption, we see the number of processor cores start to increase. This is shown on the figure as the black data points. What’s interesting is that the increasing number of cores plots as a straight line in this figure. Given the log scale on the y-axis, this implies the number of cores is increasing exponentially. 

* 这样做的一个结果是，**并发编程变得越来越重要**。为了从现代处理器中获得良好的性能，需要多个执行线程。A consequence of this, is that concurrent programming is becoming more important. Multiple threads of execution are needed to extract good performance from modern processors. 
* 另一个后果是，**并发性错误变得更加明显**。随着并行量的增加，竞赛条件、死锁和其他与多线程之间的交互问题往往更频繁地表现出来。Another consequence is that concurrency bugs more becoming more visible. Race conditions, deadlocks, and other problems with interactions between multiple threads tend to manifest themselves more often as the amount of parallelism increases. 
* 我们不仅越来越多地看到对并发性的需求，而且还看到编写并发性软件是多么困难。Not only are we increasingly seeing the need for concurrency, we’re also seeing how difficult it is to write concurrent software.

# 安全性需求增加：Increasing Need For Security

![](/static/2022-01-18-21-25-58.png)

除了计算机硬件的变化导致并发性增加外，我们还看到有**更多的设备具有永远在线的互联网连接**。不幸的是，**随着连接性的增加，安全漏洞的数量也在增加**。In addition to the changes in computer hardware, leading to increased concurrency, we’re also seeing far more devices with always-on Internet connectivity. Unfortunately, with this rise in connectivity has come increasing numbers of security vulnerabilities. 

该图显示了自2000年以来每年报告的安全漏洞的数量，并按严重程度进行了着色。The graph shows the number of security vulnerabilities reported  per year, since the year 2000, colour-coded by severity. 

显而易见的是，**Unix和C的组合，以及在这种系统上运行的应用程序，已经被证明不容易保证安全。正如我们稍后所见，这些漏洞大多是由于现代系统中的弱类型系统和缺乏内存安全造成的**。What is clear is that the combination of Unix and C, and the applications that run on such systems, has not proven easy to secure. As we’ll see later, most of these vulnerabilities are due to weak type systems and a lack of memory safety in modern systems. 

* <font color="deeppink">也就是说，这些漏洞中有许多是可以避免的，原则上，只要改变我们实现软件系统的方式</font>That is, many of these vulnerabilities are avoidable, in principle, by changing the way we implement software systems.

# 移动性和连接性增加:Increasing Mobility and Connectivity

![](/static/2022-01-18-21-30-11.png)

我想强调的最后一个趋势是越来越多的移动性和连接性。**设备是移动的，总是处于开启状态，并且总是连接到网络和远程计算资源**。The final trend I want to highlight is that of increasing mobility and connectivity. Devices are mobile, always on, and always connected to the network, and to remote computing resources.

但它们也受到很大的限制。 But they’re also deeply constrained. 

* 它们受到电池电量的限制，They’re constrained by the limitations of battery power, 
* 以及它们所连接的网络的变化无常的制约。and the vagaries of the networks to which they connect.
* 目前还不清楚我们是否有API、工具和编程模型来有效地利用这些设备，或适应环境的变化。 It’s not clear that we have the APIs, tools, and programming models to make effective use of such devices, or to adapt to the variation in the environment.

# ===============

讲座的最后一部分讨论了系统编程可能如何发展（来解决上面部分的难题）。它概述了现代**类型系统、内存安全语言和函数式编程技术如何能够帮助改进系统程序**。特别是，本文重点讨论了如何**提高安全性、支持并发性和系统正确性**。这为本课程其余部分的讨论奠定了基础。

# 如何发展：Next Steps in Systems Programming

Advances in programming language design are starting to provide the necessary tools – and are beginning to be applied to systems languages - 编程语言设计的进步开始提供必要的工具--并开始应用于系统语言中。

* Modern type systems- 现代类型系统
* Functional programming techniques- 功能性编程技术

These can help to:

* Improve memory management and safety – while maintaining control over allocation and data representation 改善内存管理和安全--同时保持对分配和数据表示的控制
* Improve security – eliminates common classes of vulnerability 提高安全性--消除了常见的漏洞类别
* Improve support for concurrency – eliminates race conditions 改善对并发性的支持--消除了竞赛条件
* Improve correctness – eliminates common classes of bug 提高正确性--消除常见的错误类别

---

编程语言设计理论的进步早已提供了可以改善我们编写系统程序的工具。最近，我们终于开始看到新的编程语言被开发出来，将这些思想融入实用的语言和系统。特别是，**函数式编程和现代类型系统**背后的思想，可以帮助**改善内存管理和内存安全，同时保持对分配和数据表示的控制**。Advances in the theory of programming language design have long provided tools that could improve the way we write systems programs. More recently, we’re finally starting to see new programming languages being developed that incorporate these ideas into practical languages and systems. In particular, the ideas behind functional programming, and modern type systems, can help to improve memory management and memory safety, while maintaining control over allocation and data representation.

它们可以通过**消除某些类别的漏洞来帮助提高安全性**。例如，通过防止缓冲区溢出，或帮助跟踪不受信任的数据。They can help to improve security by eliminating certain classes of vulnerability. For example, by preventing buffer overflows, or helping to track untrusted data.

它们可以通过消除**数据竞赛、鼓励不可更改性或跟踪数据所有权**来帮助改善对**并发**的支持。They can help to improve support for concurrency by eliminating data races, by encouraging immutability or tracking data ownership.

而且，一般来说，使用**强类型系统和函数式方法**可以通过改变我们设计程序的方式来帮助消除整个类型的错误，这种方法被称为**类型驱动设计**。 And, in general, the use of strong type systems and functional approaches can help eliminate entire classes of bug, by changing the way we design programs using an approach known as type-driven design.

# 现代类型系统：Modern Type System

![](/static/2022-01-19-19-31-53.png)

为了实现这些好处，我们需要将函数式编程技术和现代类型系统应用于系统编程。我说的现代类型系统是什么意思？好吧，现代类型系统是一个能够提供关于程序行为的有用保证的系统。To achieve these benefits, we’ll need to apply functional programming techniques and modern type systems to systems programming. What do I mean by modern type systems? Well, a modern type system is one that can provide useful guarantees about program behaviour. 

* 我们早就有了可以描述数据基本属性的类型系统。例如，让我们指定一个特定的值是一个可以存储整数而不是浮点数的数组的语言是不足为奇的。We’ve long had type systems that can describe basic properties of data. For example, languages that let us specify that a particular value is an array that can store integers, rather than floating point numbers, are unsurprising. 
* 一个更有趣的类型系统是可以在编译时强制规定对该数组没有越界访问。或者在程序中不存在 "使用后 "的错误。或者没有内存泄漏。线程之间没有竞赛条件。没有迭代器失效。等等。A more interesting type system is one that can enforce, at compile time, that there are no out-of-bounds accesses to that array. Or that there are no use-after-free bugs in a program. Or no memory leaks. No race conditions between threads. No iterator invalidation. And so on. 
* 现代类型系统让我们推理并证明真实系统程序的有趣属性。它们可以帮助确保并发代码的正确性，它们可以帮助避免特定类别的错误和安全漏洞。Modern type systems let us reason about, and prove, interesting properties of real systems programs. They can help ensure concurrent code is correct, and they can help avoid particular classes of bugs and security vulnerabilities. 

现代类型系统还可以帮助我们对问题空间进行建模，并允许我们检测我们解决方案中的不一致和问题。Modern type systems also help us to model the problem space, and allow us to detect inconsistencies and problems in our solutions. 

* 它们支持无成本抽象的概念。也就是说，系统属性的编译时检查没有运行时的成本。这让我们在运行代码之前就可以描述和检查我们的设计，并对可能的程序错误行为进行约束。They support the concept of no cost abstraction. That is, compile-time checks of system properties that have no run-time cost. This lets us describe, and check, our design, and put constraints on possible program misbehaviours, before running the code. 
* 现代类型系统帮助我们描述问题空间及其约束，使我们在阐述设计和实现时能够检查系统的有用属性。本质上，它们允许我们将编译器作为我们设计的调试器。Modern type systems help us to describe the problem space, and its constraints, in a way that allows us to check useful properties of the system as we elaborate on our design and implementation. Essentially they allow us to use the compiler as a debugger for our designs.

---

example

![](/static/2022-01-19-19-49-28.png)

作为一个例子，想想我们如何编写网络代码。在用于用C语言编写网络服务器的伯克利套接字API中，人们在一个套接字上调用accept()函数来接受一个传入的TCP连接。accept()函数把一个正在监听连接的现有套接字作为参数，并返回一个新的套接字，代表新接受的连接。网络代码中的一个常见错误是把这两个套接字混在一起。例如，试图使用正在监听新连接的套接字来发送数据，而不是使用代表先前接受的连接的套接字。这样做可以编译，但在运行时失败。这样的代码可以编译，因为在C语言中，套接字是由简单的整数来识别的，read()、write()和accept()的调用采用int类型的文件描述符来识别套接字。因此，编译器无法区分连接和监听这两种类型的套接字。As an example of this, think about how we write networking code. In the Berkeley Sockets API, used to write network servers in C, one calls the accept() function on a socket to accept an incoming TCP connection. The accept() function takes as its parameter an existing socket that’s listening for connections, and returns a new socket that represents the newly accepted connection. A common bug in networking code is to mix up these two sockets. For example, to attempt to send data using the socket that’s listening for new connections, rather than using a socket that represents a previously accepted connection. This compiles, but fails at runtime. Such code compiles because sockets are identified by simple integers in C. The read(), write(), and accept() calls take file descriptors, with type int, to identify the sockets. As a result, the compiler can’t tell the two types of socket, connected and listening, apart. 

一个更好的API会使用类型系统来区分不同类型的套接字。应该有单独的连接套接字和监听套接字类型。accept()函数应该接受一个监听套接字作为它的第一个参数，并且应该返回一个连接的套接字。而read()和write()函数应该只接受Connected Sockets。A better API would use the type system to distinguish the different types of socket. There should be separate Connected Socket and Listening Socket types. The accept() function should take as its first parameter a Listening Socket, and should return a Connected Socket. And the read() and write() functions should accept only Connected Sockets. 

在网络库以这种方式工作的系统中，试图向监听套接字写()的程序将无法编译，因为编译器可以区分这两种类型的套接字，并检测出不匹配。连接中的套接字和监听中的套接字仍然可以用整数表示，所以生成的代码不会改变，而且可以同样有效。但是，通过使它们成为不同类型的整数，编译器可以帮助我们发现错误。这是一个微不足道的例子，但其原理却很重要。In systems where the networking library works this way, a program that tries to write() to a listening socket will fail to compile, since the compiler can distinguish the two types of socket, and detect the mismatch. Connected sockets and listening sockets can still represented by integers, so the generated code doesn’t change, and can be just as efficient. But, by making them distinct types of integer, the compiler could help us find bugs. This is a trivial example, but the principle is important. 

类型中可以表示的信息越多，编译器就越能帮助检查这些类型的使用是否一致。这意味着我们可以在编译时发现错误，而不是在运行时调试代码。The more information that can be represented in the types, the more the compiler can help check that those types are used consistently. This means we find bugs at compile time, rather than having to debug the code at runtime.

# 函数式编程：Functional Programming

![](/static/2022-01-19-20-04-03.png)

另一个可以帮助系统编程的进步是应用功能编程社区的一些想法。The other advance that can help systems programming is the application of some ideas from the functional programming community. 

* 函数式编程是一种强调避免副作用和共享状态的编程风格，它提倡将代码结构化为参考透明的函数。Functional programming is a programming style that emphasises the avoidance of side effects and shared state, and that promotes structuring code as referentially transparent functions. 
* 命令式语言，尤其是面向对象的语言，倾向于积极鼓励相反的方法，导致程序充满了共享状态、副作用和不纯函数。例如，对象的全部意义在于保持共享状态。而面向对象语言中的方法通常是为了调用修改对象状态的副作用而被调用的。Imperative languages, and especially object-oriented languages, tend to actively encourage the opposite approach, leading to programs full of shared state, side effects, and impure functions. The entire point of objects, for example, is to hold shared state. And methods in object oriented languages are generally called in order to invoke the side effect of modifying the object’s state. 
* 我认为，这种编程风格对系统程序来说是有问题的，最好是避免共享状态，尽可能采用函数式编程。I argue that this style of programming is problematic for systems programs, and it’s much better to avoid shared state and program in a functional style where possible. 
  * 为什么呢？因为，副作用和共享状态使代码难以推理，也更难调试。它们增加了代码中看似不相关的部分之间的耦合性，并使人难以理解程序中的部分行为。Why? Because, side effects and shared state make code difficult to reason about, and harder to debug. They increase coupling between seemingly unrelated sections of code, and make it difficult to understand the behaviour of parts of a program in isolation. 
  * 而且，重要的是，副作用和共享状态的存在使得并发的代码更难编写。对共享状态的并发访问必须要有锁的保护，以避免竞赛条件。经验表明，在任何非琐碎的程序中，都很难把锁的问题解决好。And, importantly, the presence of side effects and shared state makes concurrent code much harder to write. Concurrent accesses to shared state have to be protected by locks, to avoid race conditions. Experience has shown that it’s difficult to get the locking right, in any non-trivial program. 
    * 通过在可能的情况下系统地以函数式写代码，并避免共享状态，可以大大减少需要的锁的数量。如果需要锁定的东西少，就更容易获得正确的锁定，并避免竞赛条件。By systematically writing code in a functional style, where possible, and avoiding shared state, the number of locks that are needed can be greatly reduced. It’s easier to get the locking right, and avoid race conditions, if there are fewer things to lock.

---

![](/static/2022-01-19-20-11-44.png)

用纯函数式写程序的基本好处是，它限制了可能发生的事情。使用参考透明函数编写的代码，没有副作用，更容易测试和调试，因为没有隐藏的状态。The essential benefit of writing programs in a pure functional style is that it constrains what’s possible. Code written using referentially transparent functions, without side effects, is easier to test and debug - because there’s no hidden state. 

* 这样的代码也是线程安全的，因为没有副作用，也没有可在线程间共享的可变状态。通过限制程序的编写方式，某些类别的错误和某些问题可以被避免。Such code is also thread safe, since there are no side effects, and no mutable state to share between threads. By constraining the way programs are written, certain classes of bugs and certain problems can be avoided. 
* 如果我们想编写并发的、安全的、正确的系统程序，避免这些问题是可取的。因此，在可能的情况下，我鼓励你在编写代码时采用函数式风格。不过请注意，我并不是说 "用Haskell写程序"。如果你的目标是发展纯函数式编程的概念，Haskell是一种伟大的语言。它采用了这一理念，并尽可能地将其推向了极致。如果你是一个编程语言的研究者，那真是太好了。Avoiding these problems is desirable, if we want to write concurrent, secure, and correct systems programs. Accordingly, when possible, I encourage you to adopt a functional style when writing code. Note, though, that I’m not saying “write your programs in Haskell”. Haskell is a great language, if your goal is to develop the concept of pure functional programming. It takes this one idea, and pushes it as far as is possible. That’s wonderful, if you’re a programming language researcher. 

而且，从Haskell中产生的许多想法都广泛适用于一般的编程。但是，很明显，并不是所有的东西都可以自然地用函数式表达。有些程序只是更容易用命令式或面向对象的方式来写。这很好。And many of the ideas that came out of Haskell are widely applicable to programming in general. But, it’s clear that not everything can be naturally expressed in the functional style. Some programs are just easier to write in an imperative, or object oriented, way. That’s fine. 

* 在有意义的地方使用函数式编程思想，以防止某些类别的错误。如果另一种方法效果更好，就这么做。但是，一定要考虑如何减少共享状态，减少副作用。Use functional programming ideas where they make sense, to prevent certain classes of bugs. If another approach works better, do that. But, always think about how to reduce shared state, and reduce side effects.

# 改进内存管理&安全性：How to improve Memory Management & Safety

![](/static/2022-01-19-20-30-05.png)

我们可以使用函数式编程技术和现代类型系统来帮助改善内存管理，并使其更加安全和不容易出错。We can use functional programming techniques and modern type systems to help improve memory management, and make it safer and less error prone. 

系统程序员习惯于手动内存管理，如在C语言中实现。Systems programmers are used to manual memory management, as implemented in C. 

* 内存是通过调用malloc()函数分配的，该函数返回一个指向新分配内存的指针。当该内存不再使用时，程序员用该指针调用free()函数来释放该内存。在这些调用之间，系统对内存的使用情况进行了少量检查。Memory is allocated by calling the malloc() function, that returns a pointer to the newly allocated memory. When that memory is no longer used, the programmer calls the free() function with that  pointer, to release the memory. The system performs few checks on what is done with the memory between those calls. 
  * 例如，malloc()返回的值可以被转换为任何类型对象的指针，无论该对象的大小是否与分配的内存大小相匹配，程序可以将同一区域的内存同时解释为不同类型的对象，无论这是否有意义。For example, the value returned by malloc() can be cast to a pointer to any type of object, whether or not the size of that object matches the size of the allocated memory, and the program can interpret the same region of memory as different types of object simultaneously, whether or not that makes sense. 
* 同样，程序访问malloc()返回的区域之外的内存的行为也是未定义的，但系统没有试图阻止这种访问。Similarly, the behaviour of a program that accesses memory outside the region returned by malloc() is undefined, but the system makes no attempt to prevent such accesses. 
* 最后，数组和字符串被表示为指向其第一个元素的指针，并不存储数组的长度，而数组的索引是通过指针运算表示的。Finally, arrays and strings are represented as pointers to their first element, and don’t store the length of the array, and array indexing is represented by pointer arithmetic. 
  * 这种数组定义的一个重要后果是，运行时无法检查数组访问是否在边界内，因为边界没有被记录。An important consequence of this definition of arrays is that the runtime cannot check whether array accesses are within bounds, since the bounds aren’t recorded. 

在设计C语言时，这种行为是有充分理由的。There were good reasons for this behaviour when C was designed. 

* 机器很慢，内存有限。Machines were slow, and memory was limited. 
* 存储分配的大小和分配的对象需要内存，而在开发C语言的机器上，内存是短缺的。Storing the size of the allocation along with the allocated object takes memory, and memory was in short supply on the machines where C was developed. 
* 同样地，检查数组的边界也需要时间，并且需要额外的代码。Similarly, checking array bounds takes time and requires additional code. 
* 这些问题在当时很重要，但在今天却不一定有效。These concerns mattered at the time, but are not necessarily valid today. 
* 在拥有千字节内存和MHz时钟的机器上，内存和运行时的开销很重要。而在现代机器上，内存是原来的几百万倍，处理器速度是原来的几万倍，这些开销就不那么重要了。On machines with kilobytes of memory and MHz clocks, the memory and runtime overheads mattered. On modern machines, that have millions of times more memory, and processors that are tens-of-thousands of times faster, the overheads are less significant. 

编译器技术和程序优化也得到了改善，以至于编译器现在**通常可以确定什么时候不需要边界检查，并从生成的代码中删除它们**。Compiler technology and program optimisations have also improved, to the extent that compilers can often now determine when bounds checks are unnecessary, and remove them from the generated code.

我们当然可以在现代系统中检查数组边界和其他内存访问--但我们需要摆脱C语言作为系统编程语言来做到这一点。We can certainly afford to check array bounds and other memory accesses on modern systems – but we need to move away from C as a systems programming language to do so.

---

![](/static/2022-01-19-21-00-34.png)

现在清楚的是，手动内存管理是一个错误的来源。What is now clear is that manual memory management is a source of bugs. 

* 它导致了自由使用后的错误，即内存在被取消分配后被访问。It leads to use-after-free bugs, where memory is accessed after it has been deallocated. 
* 它导致了内存泄漏，即内存从未被重新分配，甚至在它不再被程序引用之后。It leads to memory leaks, where memory is never deallocated, even after it has ceased to be referenced by the program.
* 它导致了缓冲区溢出，即程序试图访问它所分配区域之外的内存。It leads to buffer overflows, where the program tries to access memory outside the region it has allocated. 
* 它还会导致迭代器失效，即程序在访问列表时，列表的内容可能会发生变化，使以前有效的指针失效，从而导致越界的内存访问。And it leads to iterator invalidation, where the contents of a list can change while a program is accessing it, making a previously valid pointer invalid, and leading to out of bounds memory access.

当使用具有现代类型系统的编程语言时，所有这些问题都可以被消除。All of these problems can be eliminated when using programming languages with modern type systems. 

像Java这样的管理型语言，在虚拟机上运行，多年来一直能够在运行时捕获此类事件。
* 与编译成本地代码的系统语言相比，它们这样做会对性能造成影响，但却能获得安全。Managed languages such as Java, running on virtual machines, have been able to trap such events at run time for many years. They take a performance hit to do so, compared to systems languages that compile to native code, but gain safety. 
* 但最近，我们看到新的编程语言开始出现，可以在编译时跟踪和检测这些问题。Recently, though, we’ve seen new programming languages start to emerge that can track and detect these problems at compile time. 
  * 例如，Rust编程语言可以检测到迭代器无效和使用后的错误，并在程序中出现这些错误时抛出一个编译错误。The Rust programming language, for example, will detect iterator invalidation and use-after-free bugs, and throw a compile time error if they occur in a program.
  * Idris编程语言对缓冲区溢出也能做到这一点。The Idris programming language can do the same with buffer overflows. 

作为程序员，我们在英雄式的调试过程中一次又一次地修复相同类型的问题。另外，我们应该考虑是否有一个更好的解决方案，可以完全防止这种类型的错误。As programmers, we fix the same types of problem, again and again, in heroic debugging sessions. Alternatively, we should consider if there’s a better solution, that can prevent such classes of bug entirely.

# 改进安全性：How to improve Security

![](/static/2022-01-19-21-08-33.png)

当我们研究安全漏洞的原因时，对内存管理的关注变得至关重要。幻灯片上的数字来自微软。它追踪了2006年至2018年期间，在微软开发的软件、Windows、Office、Teams等中发现的漏洞的根本原因。它所显示的是，在这段时间内，微软软件中所有报告的安全漏洞中，约有70%与内存安全有关。The concern about memory management becomes critical when we look at causes of security vulnerabilities. The figure on the slide is from Microsoft. It tracks the root cause of bugs found in software developed by Microsoft, Windows, Office, Teams, etc., for the period from 2006 to 2018. What it shows is that around 70% of all reported security vulnerabilities in Microsoft software, for that time period, relate to memory safety. 

* 70%的报告的安全漏洞是缓冲区溢出，使用后的漏洞，内存损坏，迭代器无效，等等。通过改用内存安全语言，微软可以消除他们系统中三分之二的安全漏洞。现在，显然这很难做到。70% of reported security vulnerabilities are buffer overflows, use-after-free bugs, memory corruption, iterator invalidation, and so on. By switching to a memory safe language, Microsoft could eliminate two-thirds of the security vulnerabilities in their systems. Now, obviously this is difficult to do. 

重写Windows和Office将是一项巨大的工作，而且几乎肯定会引入比它所修复的更多的错误。Rewriting Windows and Office would be an enormous job, and would almost certainly introduce more bugs than it would fix. 

* 但是，对于新的代码来说，肯定有一个可以学习的教训。But surely there’s a lesson that can be learnt for new code? 

一旦我们开始解决围绕内存安全的低级问题，我们就应该开始考虑其他安全漏洞的根本原因。Once we’ve started to address the low-handing fruit around memory safety, we should start to think about the root causes of other security vulnerabilities. 

* 常见的是，漏洞是由不匹配的假设造成的。What is common, is that vulnerabilities are the result of mismatched assumptions. 
  * 代码的一部分假设它处理的数据的某些属性是真实的。其他代码应该验证该属性是否成立，但某处漏掉了一个检查。One part of the code assumes some property is true of data it processes. Other code is supposed to validate that the property holds, but a check is missed somewhere. 
  * 这样的问题很容易被忽略，因为假设和约束往往只在代码周围的注释和文档中可见，所以不能被自动检查。Such problems are easy to miss, because the assumptions and constraints tend to be visible only in the comments and documentation around the code, and so can’t be automatically checked. 
* 减少安全漏洞的一种方法是将尽可能多的这些假设和这些知识编码到类型中。一旦这些知识以机器可读的形式出现，编译器就可以检查代码的一致性，并在它们成为安全漏洞之前突出问题。One approach to reducing security vulnerabilities is to encode as many of these assumptions, and as much of this knowledge as possible, into the types. Once this knowledge is available in a machine readable form, a compiler can check the code for consistency, and highlight problems before they become security vulnerabilities. 
  * 这样做是更多的前期工作。以一种记录的方式来写代码，并能自动检查你的假设，使用类型系统，这是更多的努力。但是，随着时间的推移，这种努力通过减少代码使用时的意外而得到回报。Doing so is more up-front work. It’s more effort to write code in a way that records, and can automatically check your assumptions, using the type system. But, over time, that effort pays off through having fewer surprises when the code is used. 
  * 你用设计时间和编译时间来换取更少的时间来调试系统，并在部署后纠正安全漏洞。You trade-off design time, and compile time, effort, for less time spent debugging the system, and correcting security vulnerabilities, after it’s been deployed.

# 改进并发性支持：Improve support for concurrency

![](/static/2022-01-19-21-23-58.png)

我们看到了围绕并发性的类似的行为。常见的抽象是线程、锁和共享的可变状态。如果你是 c 程序员，这就是 pthreads; 如果你是 Java 程序员，这就是同步方法和对象。We see similar classes of behaviour around concurrency. The common abstraction is that of threads, locks, and shared mutable state. This is pthreads if you’re a C programmer, or synchronised methods and objects if you’re a Java programmer. 

在访问共享资源之前，必须获得适当的锁。然后，在完成资源之后，释放锁。而且，如果同时访问多个资源，则必须记住以正确的顺序获取和释放这些锁，以避免死锁。Before accessing a shared resource, you must acquire the appropriate lock. Then, once you’ve finished the resource, release the lock. And, if you access multiple resources at once, you must remember to acquire and release those locks in the right order to avoid deadlock. 

问题是，任何尝试过这种方法的人都知道，锁很容易出错。持有过多或过少的锁。或者在错误的时间或者错误的顺序获取或者释放锁。 The problem is, as anyone who’s tried this at any scale knows, that it’s easy to get the locking wrong. To hold too many, or too few, locks. Or to acquire or release the locks at the wrong time, or in the wrong order. 

* 更重要的是，很明显锁不是组合的。 如果您从两个正确使用锁定的库开始，并将它们组合在一起，那么结果可能没有正确的锁定量。保护组合数据的锁定要求可能不同于单个组件的锁定要求。More critically, it’s clear that locks don’t compose. If you start with two libraries that use locking correctly, and combine them,  then the result might not have the correct amount of locking. The locking requirements to protect the combined data might differ from those of the individual components. 

这里通常的例子是一个银行程序。这样的程序可能有一个银行账户对象，记录账户余额，并允许存款或取款。这样的对象需要锁定，以避免在存款和提款同时进行的情况下损坏余额。The usual example here is a banking program. Such a program probably has a bank account object, recording the balance of an account, and allowing money to be deposited or withdrawn. Such an object needs locking, to avoid corruption of the balance if deposits and withdrawals are made simultaneously. 

* 不太清楚的是，如果你把钱从一个银行账户转到另一个账户，每个账户都不能正确锁定。如果货币是自动转账的，所以它要么出现在一个账户中，要么出现在另一个账户中，那么锁定个人账户是不够的。在转账过程中会发现系统存在风险，根据转账的实施情况，资金要么不在任何一个账户中，要么两个账户都有。需要额外的锁定来防止这种情况的发生，而不仅仅是个人账户所需要的锁定的组合。What’s less clear is that if you transfer money from one bank account to another, it’s not sufficient for each account to be correctly locked. If the money is to be transferred atomically, so it either appears in one account or the other, then locking the individual accounts is not sufficient. There’s a risk the system is observed during the transfer, and the money either appears in neither account, or in both, depending on how the transfer was implemented. Additional locking is needed to prevent this, over and above the composition of the locking needed on the individual accounts. 

有两种方法可以避免锁定和并发的问题。There are two approaches to avoid problems with locking and concurrency. 

* 一种是应用**函数式编程**的技术。**如果只有不可变的数据被共享，并且程序的结构能够避免共享状态和副作用，那么就不会出现竞赛条件**。One is to apply the techniques of functional programming. Race conditions don’t occur if only immutable data is shared, and if the program is structured to avoid shared state and side effects. 
* 另一个是通过**跟踪数据的所有权**来避免竞赛。结构化的程序使数据的传输是原子性的，每个对象在任何时候都有一个所有者，并且使数据要么是可变的，要么是对其他人可见的，但决不是两者都有。The other is to avoid races by tracking ownership of data. Structure programs so that the transfer of data is atomic and that every object has a single owner at all times, and so that data is either mutable, or visible to others, but never both. 
* 这两种方法是有取舍的，我们将在本课程的后面详细讨论。但有趣的是，这两种方法都**消除了与并发有关的整类错误，并且可以由编译器检查其正确性**。There are trade-offs in the two approaches, that we’ll discuss in detail later in the course. What’s interesting, though, is that both eliminate entire classes of concurrency-related bugs, and can be checked for correctness by a compiler.

# 改进正确性：Improve Correctness

![](/static/2022-01-19-21-57-41.png)

有许多类型的问题经常发生在系统程序中，因为这些系统程序是用C语言编写的。There are many types of problem that frequently occur in systems programs because those systems programs are written in C. 

* C语言程序中常见的问题有：使用后的错误、内存泄漏、缓冲区溢出、迭代器无效、多线程代码中的数据竞赛。Problems such as use-after-free bugs, memory leaks, buffer overflows, iterator invalidation, and data races in multi-threaded code, are common in C programs. 
* 许多人在用高级语言编写的程序中也很常见。但是，有一些新的和正在出现的语言和工具，不仅可以修复这些错误，而且可以消除这些类别的错误，同时保持系统编程所需的控制和效率。Many are also common in programs written in higher-level languages. But, there are new and emerging languages and tools that can not just fix these bugs, but that can eliminate these classes of bug, while maintaining the control and efficiency needed for systems programming. 
* 有一些编程语言可以在编译时标记出某段代码是否存在数据竞赛、迭代器无效、缓冲区溢出、释放后使用等问题。There exist programming languages that can flag, at compile time, whether a given piece of code suffers from data races, iterator invalidation, buffer overflows, use after free bugs, and so on. 

转换到这些语言并不总是容易的，但在可能的情况下，也许我们应该考虑这样做？It’s not always easy to switch to these languages, but where possible, maybe we should consider to do so?

---

how

![](/static/2022-01-19-23-06-32.png)

此外，现代类型系统足够灵活，可以在许多情况下对问题空间进行有效建模。这使得我们可以使用类型来检查我们的设计是否一致。In addition, modern type systems are flexible enough to effectively model the problem space in many case. This allows us to use the types to check our designs for consistency. 

在编写代码时，定义代表问题域的类型。例如，与其使用int，不如定义一个PersonID类型，一个Age，或者一个Temperature，或者类似的。When writing code, define types representing the problem domain. For example, rather than using an int, define a PersonID type, an Age, or a Temperature, or similar. 

在现代语言中，这些编译下来的代码与使用通用原始类型的代码完全相同，但好处是编译器可以检查你是否传递了正确的数据类型。同样地，对一个对象何时可以被使用的约束进行编码，作为其类型的一部分。With modern languages, these compile down to the exact same code as would using the generic primitive type, but with the advantage that the  compiler can check that you’re passing the right type of data around. Similarly, encode constraints on when an object can be used as part of its type. 

* 这里的例子是我们之前讨论的网络代码中ListeningSocket与ConnectedSocket的区别，但这个技术普遍适用。The example here is the ListeningSocket vs ConnectedSocket distinction in networking code we discussed earlier, but the technique is generally applicable. 

现代系统编程语言让你轻松地定义新的类型和抽象，而且没有运行时成本。Modern systems programming languages let you define new types and abstractions easily, and without run-time cost. 

* 利用这种能力：先定义类型和函数签名，让编译器检查你的设计是否一致，然后才写函数的主体。Use this ability: define the types and function signatures first, and let the compiler check your design for consistency, and only then write the body of the functions.
* 我们习惯于在运行时对代码进行调试。我所建议的是，如果你能**在程序的类型中表示出问题域的关键特征，那么编译器也能帮助调试你的设计**。We’re used to debugging code at runtime. What I’m suggesting is that if you can represent the key features of the problem domain in your program’s types, then the compiler can also help debug your design.

# Overall

![](/static/2022-01-19-23-12-16.png)

似乎很清楚的是，系统程序，以及一般的许多软件，已经达到了人们无法管理复杂性的阶段。What seems clear is that systems programs, and much software in general, have reached the stage where people can’t manage the complexity. 

* C编程语言提供了对数据表示、内存管理和状态共享的精确控制。The C programming language gives precise control over data representation, memory management, and sharing of state. 
* 但事实证明，行使这种控制权太难了。软件中的错误和安全漏洞比比皆是，无处不在的连接和并发使问题变得更糟。But exercising that control has proven too difficult. Bugs and security vulnerabilities abound in software, and pervasive connectivity and concurrency are making the problem worse. 

新兴的强类型语言和系统提供了同样程度的控制，并增加了安全性。Emerging, strongly-typed, languages and systems give the same degree of control, with added safety. 

它们允许我们使用类型系统来消除某些类别的常见错误，并通过类型对问题空间进行建模，以帮助我们及早发现逻辑错误。我们可以改进系统编程。在本课程的剩余部分，我们将以Rust编程语言为例，探讨如何改进。They allow us to use the type system to eliminate certain classes of common bugs, and to model the problem space via the types in a way that helps us detect logic errors early. We can improve systems programming. In the remainder of this course, we’ll explore how, using the Rust programming language as an example.

# ===============

# Reading

1. J. Shapiro, “Programming language challenges in systems codes: why systems programmers still use C, and what to do about it”, Workshop on Programming Languages and Operating Systems, San Jose, CA, October 2006. DOI:10.1145/1215995.1216004
2. S. Kell, “Some were meant for C: The endurance of an unmanageable language”, International Symposium on New Ideas, New Paradigms, and Reflections on Programming & Software, Vancouver, BC, Canada, October 2017. ACM. DOI:10.1145/3133850.3133867