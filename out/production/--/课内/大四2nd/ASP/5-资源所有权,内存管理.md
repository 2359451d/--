# Content

本讲座开始讨论现代编程语言中资源所有权和内存管理的各种选择。它讨论了**运行中的程序如何在内存中排列**，并概述了**自动内存管理的必要性**。然后，它讨论了两种内存管理方法：**引用计数和基于区域的内存管理**，考虑了它们的各种成本和好处。**Rust中使用的基于区域的方法**被证明有几个重要的好处，即高效和确定的内存管理，但代价是使某些类别的程序表达更加复杂。This lecture begins to discuss the various options available for resource ownership and memory management in modern programming languages. It discusses how running programs are arranged in memory, and outlines the need for automatic memory management. It then discusses two approaches to memory management: reference counting and region-based memory management, considering their various costs and benefits. The region-based approach used in Rust is shown to have several important benefits, in terms of efficient and deterministic memory management, but at the cost of making certain classes of program more complex to express.

* [Content](#content)
* [1-内存存储结构：Memory](#1-内存存储结构memory)
* [内存中的进程布局: Layout of a Processes in Memory](#内存中的进程布局-layout-of-a-processes-in-memory)
* [程序文本、数据和 BSS：Program Text, Data, and BSS](#程序文本数据和-bssprogram-text-data-and-bss)
* [栈：The Stack](#栈the-stack)
* [函数调用规范：Function Calling Conventions](#函数调用规范function-calling-conventions)
* [缓冲区溢出攻击：Buffer Overflow Attacks](#缓冲区溢出攻击buffer-overflow-attacks)
* [堆：The Heap](#堆the-heap)
* [内存映射文件和共享库：Memory Mapped Files and Shared Libraries](#内存映射文件和共享库memory-mapped-files-and-shared-libraries)
* [内核空间：The Kernel](#内核空间the-kernel)
* [==========](#)
* [2-自动内存管理-引用计数：Automatic Memory Management: Reference Counting](#2-自动内存管理-引用计数automatic-memory-management-reference-counting)
* [自动内存管理：Automatic Memory Management](#自动内存管理automatic-memory-management)
* [系统程序-内存管理：Memory Management in Systems Programs](#系统程序-内存管理memory-management-in-systems-programs)
* [堆管理：Managing the Heap](#堆管理managing-the-heap)
* [计数引用：Reference Counting](#计数引用reference-counting)
  * [优点：Benefits](#优点benefits)
  * [开销：Costs](#开销costs)
  * [适用场景](#适用场景)
* [==========](#-1)
* [3-基于区域的内存管理：Region-based Memory Management](#3-基于区域的内存管理region-based-memory-management)
* [基于区域内存管理目标：Rationale](#基于区域内存管理目标rationale)
* [基于栈内存管理：Stack-based Memory Management](#基于栈内存管理stack-based-memory-management)
  * [局限性](#局限性)
* [从栈内存管理延伸到堆管理：From Stack-to Region-based Memory Management](#从栈内存管理延伸到堆管理from-stack-to-region-based-memory-management)
* [======](#-2)
* [生命周期检查【引用】：Validating References with lifetimes](#生命周期检查引用validating-references-with-lifetimes)
  * [Preventing Dangling References with Lifetimes 用生命周期防止悬空引用](#preventing-dangling-references-with-lifetimes-用生命周期防止悬空引用)
  * [租借检查器：The Borrow Checker](#租借检查器the-borrow-checker)
  * [函数参数-通用生命周期：Generic Lifetimes in Functions](#函数参数-通用生命周期generic-lifetimes-in-functions)
    * [Lifetime Annotation Syntax 生存期注释语法](#lifetime-annotation-syntax-生存期注释语法)
  * [生命周期注解&悬挂指针](#生命周期注解悬挂指针)
* [结构体:引用字段-生命周期 Lifetime Annotations in Struct Definitions](#结构体引用字段-生命周期-lifetime-annotations-in-struct-definitions)
* [生命周期-省略规则](#生命周期-省略规则)
  * [方法定义-生命周期注解（规则1，3）：Lifetime Annotations in Method Definitions](#方法定义-生命周期注解规则13lifetime-annotations-in-method-definitions)
* [静态生命周期：The Static Lifetime](#静态生命周期the-static-lifetime)
* [泛型&traits bounds&生命周期](#泛型traits-bounds生命周期)
* [======](#-3)
* [智能指针](#智能指针)
* [======](#-4)
* [跟踪对象所有权-Rust有效化栈管理模式](#跟踪对象所有权-rust有效化栈管理模式)
* [返回数据所有权：Returning Ownership of Data](#返回数据所有权returning-ownership-of-data)
* [消除悬挂引用：No Dangling References](#消除悬挂引用no-dangling-references)
* [消除释放后使用：No Use-After-Free](#消除释放后使用no-use-after-free)
* [数据所有权转移给调用者：Taking Ownership of Data](#数据所有权转移给调用者taking-ownership-of-data)
* [==========](#-5)
* [4-资源管理：Resource Management](#4-资源管理resource-management)
* [引用租借：Borrowing Data](#引用租借borrowing-data)
* [迭代器无效-原生租借问题: Iterator Invalidation - Problems with Naive Borrowing](#迭代器无效-原生租借问题-iterator-invalidation---problems-with-naive-borrowing)
* [不同引用-安全租借：Safe Borrowing](#不同引用-安全租借safe-borrowing)
* [所有权追踪-优点：Benefits](#所有权追踪-优点benefits)
* [局限性-基于区域内存管理：Limitations of Region-based Systems](#局限性-基于区域内存管理limitations-of-region-based-systems)
* [Summary-基于区域内存管理：Region-based Memory Management](#summary-基于区域内存管理region-based-memory-management)
* [资源管理-(析构)确定性回收：Resource Management-Deterministic Cleanup](#资源管理-析构确定性回收resource-management-deterministic-cleanup)
* [所有权&状态-资源管理：Resource Management-Ownership and States](#所有权状态-资源管理resource-management-ownership-and-states)
* [==========](#-6)
* [Readings](#readings)

# 1-内存存储结构：Memory

本讲座的第一部分回顾了**进程在内存中的存储**，以及**运行中的进程中存在哪些不同类型的内存**，作为讨论自动内存管理的前奏。它还讨论了**内存不安全的行为如何通过缓冲区溢出攻击导致安全漏洞**。 The first part of this lecture reviews of a process is stored in memory, and what different types of memory exist within a running process, as a prelude to the discussion of automatic memory management. It also discusses how memory-unsafe behaviour can lead to security vulnerabilities through buffer overflows attacks.

# 内存中的进程布局: Layout of a Processes in Memory

![](/static/2022-02-16-22-56-07.png)

要了解内存管理，你必须首先了解需要管理的内存是什么。**在所有的现代操作系统中，每个进程都有一个【虚拟地址空间】，它在其中执行**。To understand memory management, you must first understand what memory needs to be managed. In all modern operating systems, every process is given a virtual address space in which it executes.

* **每个进程都认为它是机器上唯一运行的进程，并且可以访问全部的内存地址**。底层硬件将这些**虚拟地址转化为物理地址**，代表真实内存中的特定位置，并**确保不同进程之间相互隔离**。* Each process thinks it’s the only one running on the machine, and has access to the full range of memory addresses. The underlying hardware translates these virtual addresses into physical addresses that represent particular locations in real memory, and makes sure that the different processes are isolated from each other. 
* **一个进程所看到的虚拟地址空间被分为几个不同的部分**。* The virtual address space that a process sees is divided into several different parts. 
  * 在内存的底部，从最低编号的地址开始，坐落着**程序文本本身：代表运行程序的机器运行**。* At the bottom of memory, starting with the lowest numbered address sits the program text itself: the machine runs that represents the running program. 
  * 紧接着是**静态数据和任何全局变量的空间**。* That’s immediately followed by the static data and space for any global variables. 
  * 接下来是**堆**：使用malloc()或类似机制分配的内存。。* Following this in memory is the heap: memory allocated using malloc(), or similar mechanisms.
  * 之后是**用于保存共享库和内存映射文件的内存** Following that is the memory used to hold shared libraries and memory mapped files. 
  * 然后是**栈空间**，从用户可访问内存的顶部开始向下增长。 * Then the stack space, growing down from the top of user accessible memory. 
    * **自顶向下**
  * 然后，最后，**操作系统内核本身占据了地址空间的顶端部分**。* Then, finally, the operating system kernel itself occupies the top part of the address space.

分配给这些**内存的数量**，以及**每个内存位于哪些虚拟地址之间**，取决于你的**机器是32位还是64位，也取决于你运行的是什么操作系统**。但所有的系统都遵循相同的基本方法。How much memory is allocated to each of these, and what virtual addresses each sits between, depend on whether you have a 32-bit or a 64-bit machine, and on what operating system you’re running. But all the systems follow the same basic approach.

# 程序文本、数据和 BSS：Program Text, Data, and BSS

![](/static/2022-02-16-23-07-00.png)

**程序文本、数据和全局变量占据了地址空间的最低部分**。这有四个部分。The program text, data, and global variables occupy the lowest part of the address space. There are four parts to this.

* 最底层的**内存页（保留页**)，通常是从**地址0开始的前4096字节，是保留的**。* The very lowest page of memory, usually the first 4096 bytes starting at address zero, is reserved. 
  * 在C语言中，一个**空指针由地址0代表**，所以**硬件虚拟内存控制器被编程为禁止访问该地址，以及相邻的地址，作为一种捕获空指针解除引用的方式**。* In languages like C, a null pointer is represented by address zero, so the hardware virtual memory controller is programmed to prohibit access to that address, and to adjacent addresses, as a way of trapping null-pointer dereferences.
    * **试图访问这块内存将被操作系统捕获，它将以违反分段的错误杀死该进程**。 Trying to access this memory will trap into the operating system, which will kill the process with a segmentation violation error.
* 在这个保留页之后，是**编译后的程序文本**。也就是说，代表**程序的机器代码**。它占据了**地址空间的最低部分，就在地址0上方开始**。* Following this reserved page, sits the compiled program text. That is, the machine code representing the program. This occupies the lowest part of the address space, starting just above address zero.
* 接下来是**数据段**。这包括**字符串字面和静态全局变量**。* Next comes the data segment. This comprises string literals and static global variables.
  * 数据和全局变量的**值在编译时是已知的**。这些数据和全局变量与可执行的机器代码一起**存储在编译后的二进制文件中，并在程序文本之后加载到内存中**。 Data and global variables where the value is known at compile time. These are stored in the compiled binary, along with the executable machine code, and loaded into memory following the program text. 
* 然后，为**BSS段**分配空间。
  * 这为**程序中定义的未初始化的全局变量提供保留空间**。BSS这个名字代表了 "由符号启动的块"，是一个历史遗留问题。* Then, space is allocated for the BSS segment. This provides reserved space for uninitialised global variables defined in the program. The name BSS stands for “block started by symbol”, and is a historical relic. 
* **程序文本和数据段是固定的。它们包括编译后的程序代码和编译时已知的数据**。同样，**BSS段的大小也是在编译时已知的**。The program text and data segments are fixed. They comprise the compiled program code and data known at compile time. Similarly, the size of the BSS segment is known at compile time.

---

* 在**旧的操作系统**中，程序和数据总是从**内存的起始处的一个固定位置开始**。* In older operating systems, the program and data always start at a fixed location at the start of the memory. 
* 在现代系统中，它们**仍然在内存的【起始位置附近加载**】，但每次**程序运行时实际的起始地址是随机的**。* In modern systems, they’re still loaded near the start of the memory, but the actual starting address is randomised each time the program runs. 
  * 为什么是随机的？这是一种安全措施。这**使得作为缓冲区溢出攻击的一部分执行的代码更难调用程序的其他部分，因为它不知道它们在内存中的位置**。* Why is it randomised? It’s a security measure. It makes it harder for code executed as part of a buffer overflow attack to call into other parts of the program, since it can’t know where they’ll be located in memory.

# 栈：The Stack

存储在堆栈上的所有数据必须具有已知的固定大小。在编译时具有未知大小或可能更改的大小的数据必须存储在堆上。

推入堆栈比在堆上分配更快，**因为分配器从不需要搜索存储新数据的位置; 该位置始终位于堆栈的顶部**。相比之下，在堆上分配空间需要做更多的工作，因为分配器必须首先找到一个足够大的空间来保存数据，然后执行簿记，为下一次分配做准备。

访问堆中的数据比访问堆栈中的数据慢，因为必须遵循指针才能到达堆栈。当代处理器如果在内存中跳动较少，速度会更快

* 出于同样的原因，如果处理器处理的数据与其他数据相近(比如它在堆栈上) ，而不是更远(比如它在堆上) ，那么处理器的工作就会更好。在堆上分配大量空间也需要时间。


---

![](/static/2022-02-16-23-17-53.png)

当一个程序执行时，它需要**空间来容纳函数参数、返回地址和局部变量。这些都存储在栈中**。As a program executes, it needs space to hold the function parameters, return addresses, and local variables. These are stored on the stack.

* **栈占据了用户可访问内存的顶部**，为了安全起见，栈**从一个【随机地址】开始，并向下增长**。* The stack occupies the top of user accessible memory, starting at a random address for security, and grows downwards. 
* **每次调用一个函数，从main()开始，该函数的参数、返回地址和一个指向上一个栈帧的指针被推到堆栈上**。它们占据了堆栈前一个栈帧下面的下一个地址。* Each time a function is called, starting with main(), the parameters to that function, the return address, and a pointer to the previous stack frame are pushed onto the stack. The occupy the next addresses below the previous top of the stack. 
  * 而当该函数**开始执行时**，**其局部变量的空间也同样被分配到堆栈上**。* And when the function starts to execute, space for its local variables is similarly allocated on the stack. 
  * **如果该函数调用其他函数，堆栈就会增长，因为新的栈帧被创建。而当一个函数返回时，堆栈会缩小，它在堆栈上使用的内存会被自动回收**。* If that function calls other functions, the stack grows, as the new stack frames are created. And when a function returns, the stack shrinks and the memory it used on the stack is automatically reclaimed. 
* <font color="deeppink">编译器生成了管理堆栈的代码，作为它为每个函数生成的代码的一部分。它知道如何表示返回地址、参数和堆栈指针，以及如何增长和缩小堆栈</font>。* The compiler generates the code to manage the stack, as part of the code it generates for each function. It knows how the return address, parameters, and stack pointer are represented, and how to grow and shrink the stack. 
* 而**操作系统在程序启动时为main()生成了栈帧，其返回地址指向进程清理代码**。对程序员来说，栈是自动管理的。栈内存的所有权跟随函数的调用。* And the operating system generates the stack frame for main() when the program starts, with a return address pointing to the process cleanup code. To the programmer, the stack is managed automatically. Ownership of the stack memory follows function invocation.

# 函数调用规范：Function Calling Conventions

![](/static/2022-02-16-23-31-57.png)

本幻灯片显示了一个简单的C程序的例子。它包括一个main()函数，该函数检查作为命令行参数给出的值，并打印出一个问候语或使用信息。当这个程序开始执行时，main()被调用，堆栈的内容如幻灯片右侧的绿色区域所示。This slide shows an example of a simple C program. It comprises a main() function that inspects the values given as command line arguments, and either prints a greeting or a usage message. When this program starts to execute, and main() is called, the stack contents are as shown in the green region on the right of the slide. 

* 栈中包含了main()的参数，argc和argv，main()完成后要返回的地址，以及main的局部变量。* The stack contains the arguments to main(), argc and argv, the address to return to once main() completes, and the local variables for main. 
* 当执行到printf()行时（红色显示），函数被调用，一个新的栈帧被创建。* When execution reaches the printf() line, shown in red, and the function is called, a new stack frame is created. 
* 这个新的栈帧存放着printf()的参数、printf()调用完成后返回的地址，以及**一个指向上一个栈帧的指针**。* This new stack frame holds the arguments for printf(), the address to return to once the printf() call finishes, and a pointer to the previous stack frame. 
  * **前一个堆栈帧的地址被保存起来，以便于调试，这样可以打印堆栈痕迹，调试器可以跟踪程序的执行**。* The address of the previous stack frame is stored for ease of debugging, so stack traces can be printed and so debuggers can trace program execution. 
  * 当printf()开始执行时，栈上的空间被分配给它所使用的任何局部变量。而且，**如果printf()本身调用任何函数，堆栈将根据需要继续增长**。* As printf() starts to execute, space is allocated on the stack for any local variables it uses. And, if printf() itself calls any functions, the stack will continue to grow as needed.

# 缓冲区溢出攻击：Buffer Overflow Attacks

![](/static/2022-02-16-23-39-31.png)

这表明典型的缓冲区溢出攻击。**如果语言不是类型安全的，并且不检查数组的边界**，那么对printf()的调用可以被安排为写过了存储在**堆栈中的局部变量的边界（越界**）。This suggests the classic buffer overflow attack. If the language is not type safe, and doesn’t check array bounds, then the call to printf() can be arranged so that it writes past the bounds of a local variable stored on the stack.

* 当这种情况发生时，它就**会覆盖堆栈中下一个更高的地址所存储的内容**。* When this happens, it overwrites whatever is stored in the next higher addresses on the stack.
  * 也许是一些**其他的局部变量**，但也有指向**前一个堆栈帧的指针，然后是函数的返回地址。目标是覆盖返回地址，以及下面的一些内存**。* What would that be? Well, maybe some other local variables, but also the pointer to the previous stack frame, then the return address of the function. The goal is to overwrite the return address, and some of the following memory.
* 攻击者试图用他们**想要执行的代码来填充返回地址之后的内存。并重写返回地址，使其指向该代码**。* The attacker tries to fill the memory following the return address with the code they want to execute. And to overwrite the return address so that it points to that code.
  * 当函数随后**返回时，不是返回到正确的地方，而是返回到溢出时写入的返回地址，并执行攻击者的代码**。这是一种被称为栈粉碎的技术。* When the function then returns, rather than return to the correct place, it returns instead to the return address written during the overflows, and executes the attacker’s code. It’s a technique known as stack smashing.
    * 幻灯片上的Phrack文章的链接是这种技术的经典解释。* The link to the Phrack article on the slide is the classic explanation of this technique.

当然，现代系统有变通方法。Modern systems have workarounds, of course.

* **每次程序运行时，他们都会将堆栈的位置随机化，以使其更难知道用什么值来覆盖返回地址**。* They randomise the location of the stack each time a program runs, to make it harder to known what value to overwrite the return address with.
* 他们**安排虚拟内存硬件将堆栈内存标记为不可执行**，因此**如果返回地址被成功覆盖，系统将拒绝执行代码**。* And they arrange for the virtual memory hardware to mark the stack memory as non-executable, so the system will refuse to execute the code if the return address is successfully overwritten.
  * 这些技术有帮助。我所描述的**经典的堆栈攻击**在现代系统上是行不通的。但它们**并不能完全解决这个问题**。* These techniques help. The classic stack smashing attack I’ve described won’t work on a modern system. But they don’t entirely solve the problem.
* 较新的攻击，如**面向返回的编程**，在某些情况下可以击败保护措施。* Newer attacks, such as return oriented programming, can defeat the protections in some cases.
  * 当然，真正的解决办法是**使用一种能够检查数组边界的语言，并首先防止缓冲区溢出**。* The real solution, of course, is to use a language that checks array bounds, and prevents buffer overflows in the first place.

# 堆：The Heap

![](/static/2022-02-17-00-13-37.png)

回到内存管理。除了程序代码和堆栈之外，**堆中还有明确分配的内存**。这是通过调用C语言中的malloc()和calloc()等函数分配的内存；Rust中的盒式内存；以及Java中使用new()分配的对象。Back to memory management. In addition to the program code and the stack, the heap holds explicitly allocated memory. This is memory allocated by calls to functions such as malloc() and calloc() in C; boxed memory in Rust; and objects allocated using new() in Java.

* 堆**从内存中的一个低地址开始，跟随BSS段，并向栈方向增长**。* The heap starts at a low address in memory, following the BSS segment, and grows upwards towards the stack.
  * 正如你现在所料，**为了安全起见，堆分配的确切起始地址是随机的。一般来说，连续的堆分配将占据内存中的连续块，尽管多线程系统会对堆进行分区，使每个线程有自己的空间来进行分配，而不需要与其他线程协调**。* As you might expect by now, the exact starting address for heap allocations is randomised for security. In general, successive heap allocations will occupy consecutive blocks in memory, although multi-threaded systems will partition the heap so that each thread that its own space in which to make allocations, without needed to coordinate with other threads.
  * 而且，**根据处理器的不同，小的分配可能被四舍五入到对齐到32位或64位边界上**。* And, depending on the processor, small allocations may be rounded up in size to align on a 32 bit or a 64 bit boundary.
* 虽然**栈**在函数被调用时被**自动管理**，但**内存管理的挑战主要是如何管理和回收堆内存**。* While the stack is managed automatically as functions are called, the challenge of memory management is primarily about how to manage and reclaim the heap memory.
  * 这可以通过调用**free()函数来手动**完成。它可以通过**引用计数或垃圾收集自动完成**，我们将在下一讲中讨论。也可以**根据区域和寿命分析自动完成（分代**），我将在本讲座的后面部分讨论。* This can be done manually, by calling the free() function. It can be done automatically via reference counting or garbage collection, as we’ll discuss in the next lecture. Or it can be done automatically, based on regions and lifetime analysis, as I’ll discuss in later part of this lecture.

# 内存映射文件和共享库：Memory Mapped Files and Shared Libraries

![](/static/2022-02-17-00-26-01.png)

除了分配堆内存外，大多数操作系统允许**内存映射文件**，允许**磁盘上的数据直接映射到地址空间**。In addition to allocating heap memory, most operating systems allow memory mapped files, allowing data on disk to be directly mapped into the address space.

* 在类似Unix的系统中，这种映射是通过mmap()系统调用创建的。**mmap()调用返回一个指向内存块的指针，作为文件的代理**。从该**内存中读出的文件将被分页到内存的相关部分，并返回其内容**。* On Unix-like systems, such mappings are created using the mmap() system call. The mmap() call returns a pointer to a block of memory that acts as a proxy for the file. Reading from that memory will page into the relevant part of the file into memory, and return its contents.
  * **对该内存块的写入最终会被操作系统分页到磁盘**。* And writes to that block of memory will eventually be paged back out to disk by the operating system.
  * **文件根据需要被分页进出内存，只有被访问的文件部分被加载**。这是一种**提供对文件部分随机访问的有效方法**。* The file is paged in and out of memory as needed, with only the parts of the file being accessed being loaded. It’s an effective way of providing random access to parts of a file.
* 这种**内存映射的文件通常占据了堆和栈之间的空间**。<font color="deeppink">共享库通常使用内存映射的文件来实现，并且也被映射到这个内存空间</font>。* Such memory mapped files generally occupy the space between the heap and the stack. Shared libraries are usually implemented using memory mapped files, and are mapped into this memory space too.

# 内核空间：The Kernel

![](/static/2022-02-17-01-02-43.png)

最后，操作系统的内核位于地址空间的顶部。Finally, the operating system kernel resides at the top of the address space.

* **内核内存不被用户程序直接访问，试图访问该内存将导致分段违反**。* Kernel memory isn’t directly accessible to user programs, and attempts to access that memory will result in a segmentation violation. 
* 硬件提供了一个**特殊的机器码指令**，在64位英特尔处理器上被称为syscall，它**将系统切换到内核模式，并在执行一些权限检查后，在内核内存中执行一个特定的功能**。**内核本身可以读取和写入整个地址空间**。* The hardware provides a special machine code instruction, known as syscall on 64-bit Intel processors, that switches the system to kernel mode and executes a particular function in kernel memory, after performing some permission checks. The kernel itself can read and write to the entire address space.
* **硬件保护操作系统的内核不受用户进程的影响，但操作系统必须能够控制这些进程*** The hardware protects the operating system kernel from the user processes, but the operating system has to be able to control those processes

# ==========

# 2-自动内存管理-引用计数：Automatic Memory Management: Reference Counting

本讲座的第二部分介绍了**自动内存管理的概念**及其在系统程序中的应用。然后，它讨论了最简单的自动内存管理方案之一：**引用计数**。它概述了引用计数的工作原理，并描述了其局限性、成本和好处。The second part of the lecture introduces the concepts of automatic memory management and its use in systems programs. Then it discusses one of the simplest automatic memory management schemes: reference counting. It outlines how reference counting works, and describes its limitations, costs, and benefits.

# 自动内存管理：Automatic Memory Management

![](/static/2022-02-17-01-13-11.png)

**自动内存管理**经常被系统程序员所不信任。**人们普遍认为它的开销很大。它很慢，占用CPU，而且浪费内存。而且，使用自动内存管理会给时间敏感的操作带来不可预知性**。在某种程度上，这种想法是真实的。Automatic memory management is frequently distrusted by systems programmers. There’s a general belief that it has high overheads. That it’s slow, CPU hungry, and wastes memory. And that the use of automatic memory management introduces unpredictability into the timing of time sensitive operations. And to some extent this belief is true.

* 有许多不同类型的自动内存管理。其中一些确实有很高的CPU成本。有些确实会浪费内存。有些确实在时间上引入了不可预测性。* There are many different types of automatic memory management. And some of them do have high CPU costs. Some of them do waste memory. And some do introduce unpredictability into timing.
* 同样地，**手动内存管理也有非常实际的问题**。**手动管理内存有不可预知的开销**。作为一个程序员，你知道你何时调用malloc()和free()，**但你不知道这些调用需要多长时间来执行**。* Equally, though, there are very real problems due to manual memory management. Managing memory manually has unpredictable overheads. As a programmer you known when you call malloc() and free(), but you have no idea how long those calls will take to execute.
* 而且，在某些情况下，它们可能是**相当密集的处理器，并可能需要不可预测的时间**。还有许多众所周知的问题，如内存泄漏、内存损坏、缓冲区溢出、用完即弃、迭代器失效等，所有这些都是由于**手动内存管理造成的**。* And they can be quite processor intensive, and can take unpredictable amounts of time, in some cases. And there are the numerous, and well known, problems due to memory leaks, memory corruption, buffer overflows, use-after-free bugs, and iterator invalidation, all of which are due to manual memory management.

系统程序员把注意力集中在转向**自动内存管理**的问题上，对现状的问题不屑一顾。此外，我们开始看到自动内存管理技术解决了旧方法中的一些问题。Systems programmers have focussed on the problems of moving to automatic memory management, discounting the problems of the status quo. Furthermore, we’re starting to see automatic memory management techniques that solve some of the problems with older approaches. 

* **新的垃圾收集算法具有更低的开销和更多的可预测性**。而且**系统变得更快，使现有算法的开销更容易被接受**。* New garbage collection algorithms have lower overheads and are more predictable. And systems have gotten faster, making the overheads of existing algorithms more acceptable. 
* 不同的方法，如**基于区域的内存管理**，开始被**广泛使用，并提供更多的可预测性和更强的编译时行为保证**。对于许多系统程序来说，现在可能是时候重新考虑自动内存管理的成本-效益权衡了，看看平衡是否已经改变了。* And different approaches, such as region-based memory management, are starting to see widespread use, and offer more predictability and stronger compile-time behaviour guarantees. For many systems programs, it may be time to reconsider the cost-benefit tradeoff for automatic memory management, to see if the balance has shifted.

# 系统程序-内存管理：Memory Management in Systems Programs

![](/static/2022-02-17-01-20-31.png)

**系统程序**传统上**使用手动和自动内存管理的混合方式**。用于**栈的内存是自动管理**的。Systems programs traditionally used a mix of manual and automatic memory management. The memory used for the stack is managed automatically.

* 例如，在幻灯片上的示例代码中，saveDataForKey()函数中的**局部变量di的内存在函数被调用时自动分配，并在函数返回时自动释放**。这是很常见的，我们甚至都没有想到。* In the sample code on the slide, for example, the memory for the local variable, di, in the saveDataForKey() function is automatically allocated when the function is called, and automatically freed when the function returns. This is so common that we don’t even think about it. 
* 基于栈的内存管理，在这种形式下，对于像C和C++这样支持复杂值类型的语言，效果非常好。也就是说，对于那些可以把结构放在栈上并按值传递的语言。* Stack-based memory management, in this form, works extremely well for languages like C and C++ that support complex value types. That is, for languages that can put structs on the stack and pass them by value.
* 对于像Java这样的语言来说，它的效果较差，因为在这些语言中，**对象是堆分配的。在Java中，变量di是对堆分配对象的引用，需要进行垃圾回收。只有对该对象的引用会被保存在栈中**。* It works less well for languages like Java, where objects are heap allocated. In Java, the variable, di, would be a reference to a heap allocated object, which would need to be garbage collected. Only the reference to that object would be stored on the stack. 
* 而**在C和C++中**，**整个对象可以有效地在栈中管理**。C和C++中的栈是一个成功的自动内存管理的例子。* While, in C and C++, the entire object can be efficiently managed on the stack. The stack in C and C++ is an example of successful automatic memory management. 
* 另一方面，**堆一般是手动管理的。分配是通过调用malloc()进行的。如果程序员记得要这样做，则通过明确地调用free()来取消分配**。* The heap, on the other hand, is generally managed manually. Allocation is by a call to malloc(). Deallocation, if the programmer remembers to do so, is by an explicit call to free().

# 堆管理：Managing the Heap

![](/static/2022-02-17-01-25-43.png)

如果有一种有效的、自动的管理堆的方法就好了。像管理堆一样简单、高效、有效的东西。It would be good to have an effective and automatic way of managing the heap. Something that’s as simple, efficient, and effective as managing the stack. 

自动内存管理的目标是管理堆。**找出不再使用的内存，并使这些空间可以重新使用。寻找不再被运行中的程序引用的对象，并释放其内存**。The goal of automatic memory management is to manage the heap. To find memory that’s no longer in use, and make that space available for reuse. To look for objects that are no longer referenced by the running program, and to free their memory. 

* 而且要有效地、**自动**地做到这一点。而且要**安全**地做到这一点。最好是**浪费内存**，并在不应该存在的情况下让对象保持活动状态，**而不是释放可能仍在使用的对象使用的内存**。And to do so efficiently and automatically. And to do so safely. It’s better to waste memory, and to keep an object alive when it shouldn’t be, than to deallocate the memory used by an object that’s potentially still in use. 

有三种方法来自动管理堆。There are three approaches to automatically managing the heap.

* 引用计数 reference counting
* 基于区域的寿命跟踪 region-based lifetime tracking
* 垃圾收集 garbage collection

# 计数引用：Reference Counting

![](/static/2022-02-17-01-33-43.png)

自动内存管理技术中的第一个是引用计数。引用计数很简单，也很容易理解。The first of the automatic memory management techniques is reference counting. Reference counting is simple and easy to understand.

* 当为一个对象分配内存时，分配中包含了额外的空间，用于与对象一起存储的引用计数。也就是说，**每个对象都有一个隐藏的额外字段，大到足以容纳一个整数值，它与对象一起存储，由运行时系统管理**，程序员无法看到。* When allocating memory for an object, the allocation contains additional space for a reference count that’s stored along with the object. That is, every object has a hidden extra field, large enough to hold an integer value, that’s stored alongside the object and managed by the runtime system, invisibly to the programmer.
* 这个**额外的字段包含一个引用计数。它计算了有多少其他对象拥有对这个对象的指针，即引用**。* This extra field contains a reference count. It counts how many other objects have a pointer, a reference, to this object. 
  * 当**一个堆分配的对象被创建时，引用计数被设置为1，并且返回该对象的一个引用**。* When a heap allocated object is created, the reference count is set to one, and a reference to the object is returned. 
  * **当一个新的引用，一个新的指针，指向这个对象时，那么引用计数会增加1。当一个引用被移除或改变，使其不再指向该对象，那么引用计数将减少1**。* When a new reference, a new pointer, to the object is made, then the reference count is increased by one. When a reference is removed or changed, so that it no longer points to the object, then the reference count is decreased by one. 
  * **如果引用计数达到0，那么就没有指向该对象的引用了，它可以被回收，并且它的内存被重新分配了**。**如果一个包含对其他对象的引用的对象被回收，这将删除对这些对象的引用。这样做有可能导致它们的引用计数归零，从而触发进一步的回收**。* If the reference count reaches zero, then there are no references left that point to the object, and it may be reclaimed, and it’s memory deallocated. If an object that contains references to other objects is reclaimed, this removes a reference to those objects. Doing so potentially causes their reference counts to go to zero, triggering further reclamation.
* 引用计数是自动维护的。在**带有引用计数的编译语言**中，例如iPhone中使用的Objective C运行时，**编译器会生成代码来管理引用，并在指针被操作时回收对象**。在**具有引用计数的解释语言**中，如Python或Ruby，**解释器会更新引用并回收对象**。* The reference counts are maintained automatically. In a compiled language with reference counting, such as the Objective C runtime used in iPhones, then the compiler generates the code to manage references and reclaim objects when pointers are manipulated. In an interpreted language with reference counting, such as Python or Ruby, the interpreter updates the references and reclaims the objects.

## 优点：Benefits

![](/static/2022-02-17-01-43-49.png)

参照计数的关键好处是它是**可预测和可理解的**。The key benefit of reference counting is that it’s predictable and understandable.

很容易解释引用计数是如何工作的。很容易理解何时回收内存，以及程序中的哪些行为可能会触发内存回收。很容易理解什么是开销，什么是成本。It’s easy to explain how reference counting works. It’s easy to understand when memory is reclaimed, and what actions in a program might trigger memory to be reclaimed. It’s easy to understand what is the overhead and what is the cost.

每个对象有一个额外的整数；当获取一个对象的指针时，引用计数的增量；当移除一个引用时，引用计数的减量、if语句和对free()的潜在调用。这种行为对程序员来说是很直观的--这一点很重要。It’s one additional integer per object; an increment of a reference count when taking a pointer to an object; and a decrement of a reference count, an if statement, and a potential call to free() when removing a reference. The behaviour is intuitive to programmers – and that counts for a lot.

引用计数也是递增的。内存在小范围内被回收，而发生的成本是指针操作上偶尔出现的少量开销。**很少有长时间的内存管理活动，而且很清楚什么会触发这种突发情况**。Reference counting is also incremental. Memory is reclaimed in small bursts, and the costs that occur are an occasional small overhead on pointer operations. **There are few long bursts of memory management activity, and it’s clear what might trigger such bursts.**

## 开销：Costs

![](/static/2022-02-17-01-49-36.png)

引用计数也有一些代价。Reference counting also has some costs. 

可以产生**包含相互引用的循环数据结构**。Cyclic data structures can be produced that contain mutual references. 

* 也就是说，一组对象可以**在循环中相互引用，这样的对象都可以从其他一些对象中到达，所以引用计数永远不会达到零，但却不能从程序的其他部分到达（仅在循环中**。* That is, a set of objects can reference each other in a loop, such that the objects are all reachable from some other object, so the reference count never reaches zero, but not from the rest of the program.
* 这可能导致一组断开连接的对象，从代码的其余部分无法到达，**因为它们的引用计数不为零，所以没有被回收。也就是说，会泄露内存**。* This can lead to a disconnected set of objects, unreachable from the rest of the code, that aren’t reclaimed because they have non-zero reference counts. That is, it can leak memory.
  * 程序员需要注意到，并**明确地将其中一个引用设置为null，以便在删除对象的最后一个其他指针之前打破这个循环。只有这样，这些对象才能被回收**。 The programmer needs to notice, and explicitly set one of the references to null, to break the cycle before removing the last other pointer to the objects. Only then will the objects be reclaimed.

引用计数在每个对象旁边存储一个引用计数，作为一个额外的隐藏字段。Reference counting stores a reference count alongside each object, as an additional hidden field. 

* 如果对象可以**被同时访问，它可能还需要为每个对象设置一个mutex。这需要额外的内存**。* If the objects can be accessed concurrently, it may also need a mutex for each object. This uses additional memory. 
* 如果**对象很小**的话，这可能是一个**相当高的开销**。* And can be quite a high overhead if the objects are small. 
* 如果程序**经常操作指针，或者对象的寿命不长，那么更新引用的处理器成本就会相当高**。* And the processor cost of updating the references can be moderately high, if the program manipulates pointers a lot, of if the objects don’t live long.

## 适用场景

![](/static/2022-02-17-01-55-00.png)

尽管有这些限制，引用计数被广泛使用。Despite these limitations, reference counting is widely used.

* 它在**脚本语言**中很常见，如Python或Ruby，使用解释语言的开销远远超过了使用引用计数的开销。* It’s common in scripting languages, such as Python or Ruby, where the overhead of using an interpreted language far outweighs the overhead of using reference counting.
* 它也**被用于系统编程的某些方面**。iPhone和Mac的应用程序通常用**Objective C**语言编写。这是一种面向对象的C语言的扩展，使用引用计数来管理分配给对象的内存。**它实际上是高度优化的，而且性能相当高。对于用户界面代码和许多应用逻辑来说，引用计数一直是足够快的**。* It’s also used for some aspects of systems programming. Applications for the iPhone and Mac are typically written in the Objective C language. This is an object oriented extension to C that uses reference counting to manage the memory allocated to objects. And it’s actually highly optimised and reasonably high performance. Reference counting has always been fast enough for user interface code and much application logic.
* 但它**并不用于低级别的、内核内的代码，因为那里的性能是至关重要的**。* It’s not used for low-level, in-kernel, code, where performance is critical, though.

# ==========

# 3-基于区域的内存管理：Region-based Memory Management

本讲座的第三部分介绍了**基于区域的内存管理**的概念。它描述了这种方法背后的概念和原理，以及它如何建立在堆栈的管理方式之上。它还描述了基于区域的内存管理方法的好处和局限性，比如**Rust所采用的方法**。介绍了**所有权跟踪**的概念。The third part of the lecture introduces the concept of region-based memory management. It describes the concepts and rationale behind this approach, and how it builds on the way the stack is managed. And it describes the benefits and limitations of region-based approaches to memory management, such as that employed by Rust. The concept of ownership tracking is introduced.

对基于区域的内存管理的介绍到此结束。关键的见解是，**如果每个值都有一个唯一的所有者，并且编译器跟踪所有权和这些值的，那么每个值都可以在其结束后自动释放。这就是Rust和其他编程语言的关键区别**。Rust编译器知道一个值什么时候被消耗了，什么时候达到了它的的终点，并且会**在编译时强制执行**。其他语言要么不跟踪寿命，比如C语言，并可能允许在空闲bug后使用，悬空引用，等等。或者它们使用某种形式的垃圾收集，在运行时跟踪数据的有效性。它们要么不安全，要么有运行时开销。Rust既安全，又避免了运行时的开销。但为了实现这一点，Rust限制了可以表达的程序集，我们将在本讲座的下一部分看到。That concludes this introduction to region-based memory management. The key insight is that if every value has a unique owner, and the compiler tracks ownership and the lifetime of those values, then every value can be automatically freed at the end of its lifetime. This is the key difference between Rust and other programming languages. The Rust compiler knows when a value has been consumed, when it’s reached the end of its lifetime, and will enforce this at compile time. Other languages either don’t track lifetimes, like C, and potentially allow use after free bugs, dangling references, and so on. Or they use some form of garbage collection, to track liveness of data at run time. They’re either unsafe, or have run time overhead. Rust is both safe, and avoids the run-time overheads. But to achieve this, Rust restricts the set of programs that can be expressed, as we’ll see in the next part of this lecture.

# 基于区域内存管理目标：Rationale

![](/static/2022-02-17-02-02-11.png)

基于区域的内存管理是一种新的内存管理方式，是在对其他方式的失望中发展起来的。Region-based memory management is a new way of managing memory that grew out of frustrations with the alternatives. 

* 正如我们在上一部分所看到的，引用计数简单易懂，但开销相对较高。它需要空间来存储引用计数，也需要时间来更新它们。虽然这种开销对于大多数应用程序来说是可以接受的，但对于性能关键的系统代码来说就太多了。Reference counting, as we saw in the last part, is simple and easy to understand, but has relatively high overhead. It takes space to store the reference counts, and time to update them. And while this overhead is okay for most applications, it’s too much for performance-critical systems code. 
* 垃圾收集，我将在下一讲中详细讨论，它有不可预测的时间和高内存开销。Garbage collection, which I’ll talk about in detail in the next lecture, has unpredictable timing and high memory overheads. 

* 而手动内存管理又太容易出错。And manual memory management is too error prone. 

基于区域的内存管理旨在实现这两者之间的中间地带。**它的目标是安全和提供可预测的时间。而且，与手动内存管理相比，它没有运行时间成本**。但是，为了实现这一点，它迫使代码的编写方式发生一些变化。Region-based memory management aims for the middle ground between these. It aims to be safe and offer predictable timing. And it has no run-time cost, compared to manual memory management. But, to achieve this, it forces some changes in the way code is written.

# 基于栈内存管理：Stack-based Memory Management

![](/static/2022-02-17-02-10-32.png)

那么什么是基于区域的内存管理？让我们首先回顾一下堆栈上的内存管理方式 So what is region-based memory management? Well, to understand that, let’s first recap the way memory is managed on the stack. 

* 幻灯片显示了一个简单的C程序。这包括两个函数：main()和conic_area()，其中conic_area()函数实现了一个数学公式来计算一个直角圆锥的表面积。* The slide shows a simple C program. This comprises two functions: main() and conic_area(), where the conic_area() function implements a mathematical formula to calculate the surface area of a right circular cone. 
* 有一个全局静态变量，持有Pi的值。main()函数不需要任何参数，并持有局部变量宽度、高度和面积。* There’s one global static variable, holding the value of Pi. The main() function takes no parameters, and hold local variables width, height, and area. 
* 而conic_area()函数需要两个参数，w和h，并持有局部变量r和a。* And the conic_area() function takes two parameters, w and h, and hold the local variables r and a. 

右图显示了程序拥有的内存区域，同时conic_area()函数正在执行。我们看到有一个区域存放着全局变量，以及用于main()和conic_area()函数的栈帧的子区域。The diagram on the right shows the memory regions owned by the program, while the conic_area() function is executing. We see there’s a region holding the global variables, and sub-regions for the stack frame for main() and for the conic_area() functions. 

* **这些区域相互嵌套，全局区域持续整个程序的时间，而其他区域则嵌套在其中，持续部分时间。局部变量和函数参数的寿命与容纳它们的函数的栈帧相匹配。内存被自动地、有效地、无缝地分配和删除**。* These nest, one within the other, with the global region lasting for the entire duration of the program, and the other regions nesting within, and lasting for part of the time. The lifetime of the local variables and function parameters matches that of the stack frames of the functions holding them. Memory is allocated and deallocated automatically, efficiently, and seamlessly.

---

![](/static/2022-02-17-02-14-40.png)

从本质上讲，有一个与程序的调用栈相对应的区域层次结构。Essentially, there’s a hierarchy of regions corresponding to the call stack of the program.

* **全局变量的寿命是整个程序的寿命，而局部变量的寿命与它们所在的函数的执行时间相匹配**。* The lifetime of the global variables is that of the entire program, and the lifetime of the local variables matches the execution time of the functions they live within. 
* 而且，在每个函数中，我们可以看到有一些**词义范围内的变量，它们的寿命比包围函数的寿命要短**。* And, within each function, we see there may be lexically scoped variables that have a lifetime less than that of the enclosing function. 
  * 例如，在幻灯片上的代码中，我们看到**变量i，即for循环中的索引变量，只在for循环的时间内存在**。* In the code on the slide, for example, we see that the variable i, the index variable in the for loop, lives only for the duration of that for loop. 
* **这些变量中的每一个都生活在一个区域内，由程序代码决定范围，在进入该区域时自动分配，而在程序离开该区域时则被取消分配**。这样的工作是无缝的。以至于我们在写代码时认为这是理所当然的。* Each of these variables lives within a region, scoped by the program code, and is automatically allocated when entering that region, and deallocated when the program leaves the region. This works seamlessly. So much so that we take it for granted when writing code.

## 局限性

![](/static/2022-02-17-02-18-49.png)

这种基于堆栈的内存管理方法有一个限制。它**要求数据在栈中分配**。There’s one limitation of this stack-based approach to memory management. It requires data to be allocated on the stack.

在本幻灯片的例子中，变量tmp存在于hostname_matches()函数的栈帧中。变量的空间在函数开始执行时被创建，并在函数结束时被释放。In the example on this slide, the variable tmp lives on the stack frame for the hostname_matches() function. Space for the variable is created when the function starts to execute, and freed when the function concludes.

* 但这只是存放tmp的内存。也就是说，**存放指针的局部变量的内存是自动管理的。堆分配的内存，即调用malloc()分配的内存，不会被自动释放**。* But that’s only the memory that holds tmp. That is, the memory for the local variable holding the pointer is managed automatically. The heap allocated memory, the memory allocated by the call to malloc(), is not freed automatically. 
* 当tmp超出范围时，持有指针的空间被释放，但**它指向的值没有被释放**。* When tmp goes out of scope, the space holding the pointer is freed, but the value it points to is not. 
  *** 程序没有调用free()来释放该内存，也没有返回指针，以便其他函数可以这样做。它泄漏了内存。指针消失了，所以没有剩余的对所分配内存的引用，所以没有办法释放该内存**。* The program doesn’t call free() to deallocate that memory, and it doesn’t return the pointer so some other function can do so. It leaks memory. The pointer is gone, so there’s no remaining reference to the allocated memory, so no way to free that memory.

# 从栈内存管理延伸到堆管理：From Stack-to Region-based Memory Management

![](/static/2022-02-17-02-24-31.png)

基于栈的内存管理显然是有效的，但其适用性有限。我们可以扩展它来管理堆吗？可以。Stack-based memory management is clearly effective, but has limited applicability. Can we extend it to manage the heap?

我们可以**安排编译器跟踪数据的寿命**，以它插入代码管理堆栈的同样方式，它可以**插入代码，根据对象的寿命来管理堆内存**。如果我们安排代码，使每个数据值都有一个明确的所有者，那么我们可以安排它，如果一个指针超出范围，那么它所指向的值也会被释放。We can arrange for the compiler to track the lifetime of data, and in the same way that it inserts code to manage the stack, it can insert code to manage heap memory based on object lifetimes. If we arrange the code so that there’s a single clear owner of every data value, then we can arrange it so that if a pointer goes out of scope, then the value it points to is also freed.

* 这就要求我们**跟踪所有数据对象的所有权**，但正如我们在上一节课看到的，Rust会这样做。那么我们的想法是定义Box-of-T类型(智能指针)，这是一个存储在栈中的值，它持有对堆上分配的T类型数据的引用。* This requires us to track ownership of all data objects, but as we saw in the last lecture, Rust does this. The idea then it to define the Box-of-T type, which is a value that’s stored on the stack that holds a reference to data of type T that’s allocated on the heap. 
* **调用Box::new()分配并填充堆内存，并返回一个指向该内存的指针，该指针存储在堆栈的一个局部变量中。由此产生的局部变量是一个普通的变量，其寿命与它所在的栈框架相匹配**。* Calling Box::new() allocates and populates heap memory, and returns a pointer to that memory that’s stored in a local variable on the stack. The resulting local variable is a normal variable, with lifetime matching that of the stack frame in which it resides. 
* 而**堆分配的对象的寿命也与Box的寿命一致。当容纳Box的局部变量超出范围时，编译器会自动调用其析构器。解构器释放了堆分配的内存**。* And the heap allocated object has lifetime matching that of the Box too. When the local variable holding the Box goes out of scope, its destructor is automatically called by the compiler. The destructor frees the heap allocated memory. 

这就是Rust中基于区域的内存管理的基础。它的效率很高。而且它可以安全地管理堆内存。* This is the basis for region based memory management in Rust. It’s highly efficient. And it safety manages heap memory. 

* 但**它失去了通用性，因为它将堆分配的寿命与栈帧的寿命联系在一起**。如果你对C++进行过编程，这种方法就会被称为RAII--资源获取即初始化--设计模式。Python也在其 "With "字句中做了类似的事情。* But it loses generality, since it ties the lifetime of heap allocation to that of stack frames. If you’ve programmed C++, this approach will be familiar as the RAII – Resource Acquisition Is Initialization – design pattern. Python also does something similar in its “with” clauses.

# ======

# 生命周期检查【引用】：Validating References with lifetimes

使用’a的方式，可以显式声明生命周期。生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦他们形成了某种关联，**Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为**。

Rust中的每个引用都是有其 生命周期 (lifetimes)，也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以Rust需要我们使用泛型生命周期参数来注明他们的关系，这样就能**确保运行时实际使用的引用绝对是有效的**。

https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html

![](/static/2022-02-18-03-19-24.png)

## Preventing Dangling References with Lifetimes 用生命周期防止悬空引用

![](/static/2022-02-18-03-20-42.png)
![](/static/2022-02-18-03-23-19.png)

## 租借检查器：The Borrow Checker

![](/static/2022-02-18-03-27-44.png)
![](/static/2022-02-18-03-29-05.png)

* 在编译时，Rust 比较了两个生命周期的大小，发现 r 的生命周期为‘ a’，但它指的是‘ b’生命周期的内存。这个程序被拒绝了，因为 b 比 a 短: 参考的客体没有引用者的那么长。

## 函数参数-通用生命周期：Generic Lifetimes in Functions

编译器的租借检查器无法检查泛型生命周期。。。但可以为泛型指定生命周期参数

![](/static/2022-02-18-03-30-58.png)
![](/static/2022-02-18-03-32-06.png)
![](/static/2022-02-18-03-32-44.png)

### Lifetime Annotation Syntax 生存期注释语法

![](/static/2022-02-18-03-36-02.png)
![](/static/2022-02-18-03-36-46.png)

---

![](/static/2022-02-18-03-37-40.png)
![](/static/2022-02-18-03-41-02.png)
![](/static/2022-02-18-03-44-33.png)

---

具体例子

![](/static/2022-02-18-03-47-10.png)
![](/static/2022-02-18-03-49-34.png)
![](/static/2022-02-18-03-51-09.png)
![](/static/2022-02-18-03-52-11.png)

* 虽然逻辑会返回str1（更长的生命周期，print那行有效），但是编译器租借检查器不会意识到这点，因为注解了通用生命周期注解，一定会返回较小的那个

## 生命周期注解&悬挂指针

![](/static/2022-02-18-04-04-01.png)
![](/static/2022-02-18-04-06-28.png)

# 结构体:引用字段-生命周期 Lifetime Annotations in Struct Definitions

![](/static/2022-02-18-04-08-41.png)

# 生命周期-省略规则

在 Rust 的参考文献分析中编写的模式被称为生命周期省略规则。这些不是程序员应该遵循的规则; 它们是编译器会考虑的一组特殊情况，如果你的代码符合这些情况，你就不需要明确地编写生命周期。

![](/static/2022-02-18-04-14-23.png)
![](/static/2022-02-18-04-15-23.png)

![](/static/2022-02-18-04-15-55.png)
![](/static/2022-02-18-04-16-22.png)

---

![](/static/2022-02-18-04-17-47.png)

* 报错，编译器无法通过缺省规则计算出生命周期

## 方法定义-生命周期注解（规则1，3）：Lifetime Annotations in Method Definitions

![](/static/2022-02-18-04-22-05.png)
![](/static/2022-02-18-04-23-34.png)

# 静态生命周期：The Static Lifetime

![](/static/2022-02-18-04-25-03.png)

* 字符串字面量文本

# 泛型&traits bounds&生命周期

![](/static/2022-02-18-04-28-05.png)

# ======

# 智能指针

在 Rust 中，使用了所有权和借用的概念，引用和智能指针之间的另一个区别是**引用**是只**借用数据的指针**; 相反，在许多情况下，**智能指针拥有它们所指向的数据**。

![](/static/2022-02-18-04-32-46.png)

* **智能指针区别于普通结构的特征是智能指针实现了 Deref 和 Drop traits**。
  * Deref 特性允许智能指针结构的实例表现得像一个引用，这样你就可以编写可以使用引用或者智能指针的代码。
  * Drop trait 允许您自定义智能指针的实例超出范围时运行的代码。在本章中，我们将讨论这两个特性，并说明为什么它们对智能指针很重要

# ======

# 跟踪对象所有权-Rust有效化栈管理模式

![](/static/2022-02-17-02-33-54.png)

不过Rust将这一模式进一步发展。为了有效，基于区域的内存管理不仅要**将对象的寿命与栈帧联系起来，还要跟踪对象在栈帧之间的传递方式**。Rust takes the pattern further though. To be effective, region-based memory management has to not just tie object lifetimes to stack frames, but also to track how objects are passed between stack frames. 

* 而且这样做的方式要能**保持每个对象的单一所有者不变**。* And do so in a way that maintains the single owner invariant for every object. 
* 在每一点上，**编译器都必须知道哪块代码区域拥有每一块数据**。* At every point, the compiler must know what region of code owns each piece of data. 
* 当数据在函数间传递时，当数据的所有权在函数间传递时，**编译器必须跟踪数据的所有权**。* And as data is passed between functions, as ownership of the data is passed between functions, the compiler must track that data ownership. 
* **而且，当数据项最终超出范围时，在它的所有权在不同的函数之间传递之后，只有在那时，它才应该去分配堆的内存**。* And, when the data item finally goes out of scope, after its ownership has been passed between various functions, only then should it deallocate the heap memory.
  * `*`

# 返回数据所有权：Returning Ownership of Data

![](/static/2022-02-17-02-42-00.png)

正如我们在上一节课所看到的，Rust跟踪数据项的所有权，因为它们在函数之间传递。As we saw in the last lecture, Rust tracks ownership of data items as they’re passed between functions. 

* 幻灯片上的代码是我们之前看到的C程序的Rust等价物，用于计算圆锥面积。如果我们看一下函数 area_of_cone() 中变量的寿命，我们会发现**变量 r 的寿命与函数的栈帧相匹配。它在函数开始执行时被分配，在函数结束时超出范围并被释放**。* The code on the slide is the Rust equivalent of the C program we saw earlier, to calculate the conic area. If we look at the lifetimes of the variables in the function area_of_cone(), we see that the variable, r, has lifetime matching that of the function’s stack frame. It’s allocated when the function starts to execute, and goes out of scope and is freed when the function finishes. 
* **变量a是在area_of_cone()中创建的，但随后从该函数返回。该值的所有权从该函数传递给其调用者，即main()函数。在那里，它被作为参数传递给println!()宏，该宏消耗该值**。* The variable, a, though is created within the area_of_cone() but then returned from that function. Ownership of the value is passed from that function to its caller, the main() function. And from there, it’s passed as an argument to the println!() macro, that consumes the value. 
  * 关键的一点是，**最初存储在 area_of_cone() 函数中的局部变量 a 中的值的寿命超过了该函数。编译器会跟踪这个寿命。它知道所有权已经改变。这个值已经从函数中传递到main()中，随后被println!()调用所消耗**。* The key point is that the lifetime of the value initially stored in the local variable, a, in the area_of_cone() function, outlives that function. And the compiler tracks this lifetime. It knows that the ownership has changed. That the value has been passed out of the function into main(), and is later consumed by the println!() call.

---

![](/static/2022-02-17-02-52-42.png)

我们看到，返回值的所有权被转移到了调用函数中。**这个值被移到了调用函数的栈帧中，并被分配给一个局部变量。而原来的值，在被调用函数的栈帧内，在该函数返回时被销毁**。We see that ownership of the return value is moved to the calling function. The value is moved into the stack frame of the calling function, and assigned to a local variable. And the original value, in the called function’s stack frame, is destroyed when that function returns. 

* **如果被移动的值是一个Box，被移动的就是Box本身。也就是说，指向堆分配的内存的智能指针被移到调用者的栈帧中。它所引用的堆上的值是不变的**。* If the value being moved is a Box, what’s moved is the Box itself. That is, the smart pointer to the heap allocated memory is moved into the stack frame of the caller. The value on the heap that it references is unchanged. 
* 同样，**如果一个引用被返回，被移动的是这个引用。被引用的值是不变的**。* Similarly, if a reference is returned, it’s the reference that’s moved. The referenced value is unchanged.

任何【**没有被函数返回的变量】都会超出范围，并在函数返回时被销毁**。 Any variable not returned by a function goes out of scope and is destroyed when the function returns. 

* 这是什么意思？该类型的**析构器，即drop()方法，被调用。然后，存放该对象的内存被解配**。* What does this mean? The destructor for the type, the drop() method, is called. Then the memory holding the object is deallocated. 
* 如果**超出范围的值是一个Box，Box的析构器会调用堆分配的对象的析构器，然后释放堆的内存。由于每个对象最终都会超出范围，当它的结束时，因为确保所有的堆内存被释放**。* If the value going out of scope is a Box, the destructor for the box calls the destructor for the heap allocated object, then frees the heap memory. Since every object goes out of scope eventually, when it reaches the end of its lifetime, since ensures that all heap memory is freed.

# 消除悬挂引用：No Dangling References

![](/static/2022-02-18-03-14-12.png)
![](/static/2022-02-18-03-15-25.png)

---

![](/static/2022-02-17-03-01-43.png)

由于Rust编译器跟踪每个对象的，它可以防止常见的与有关的错误。Since the Rust compiler tracks the lifetime of every object, it can prevent common lifetime-related errors. 

例如，本幻灯片顶部显示的Rust程序是**一个试图返回一个局部变量的引用的函数。这是不可能的，因为一旦函数返回，局部变量就不存在了**。For example, the Rust program shown on the top of this slide is a function that tries to return a reference to a local variable. This isn’t possible, since the local variable ceases to exist once the function returns.

* 编译器注意到了这一点，正如我们所看到的，这段代码没有被编译。**你不能返回一个引用，也就是说，借用一个不再存在的值**。* The compiler notices this, and as we see, the code doesn’t compile. You can’t return a reference to, that is, borrow, a value that doesn’t exist any more. 
* 幻灯片底部显示的等效的C语言程序在编译时没有问题，但在运行时使用返回的指针时会崩溃。好的C语言编译器在像这个例子这样简单的情况下会对此发出警告，但在编译更复杂的代码时不会有任何警告。* The equivalent C program, shown on the bottom of the slide, will compile just fine, but crash at runtime when the returned pointer is used. Good C compilers warn about this, in simple cases like this example, but will compile more complex variants of the code without warnings.

# 消除释放后使用：No Use-After-Free

![](/static/2022-02-17-03-06-43.png)

同样，由于**Rust编译器跟踪对象的，它可以防止你访问已经被释放的内存**。Similarly, because the Rust compiler tracks object lifetimes, it can prevent you from accessing memory once it’s been freed.

幻灯片顶部显示的Rust代码是一个例子。它导入并明确地调用了drop()函数，以强制本地变量x被解锁。The Rust code shown at the top of the slide shows an example. It imports and explicitly calls the drop() function, to force the local variable, x, to be deallocated. 

* 手动调用drop()在Rust中从来没有明确的需要，但也是可能的，其效果与C语言程序中调用free()去分配内存是一样的。。* Calling drop() manually is never explicitly needed in Rust, but is possible, and has the same effect as calling free() to deallocate memory in a C program. 
* 幻灯片上的Rust代码，即**去分配内存，然后试图打印出刚刚分配的内存的内容，未能编译。编译器知道drop()的调用消耗了对象，它的结束了。它知道这个值不能被访问** * The Rust code on the slide, that deallocates memory then tries to print out the contents of the just-deallocated memory, fails to compile. The compiler knows that the drop() call consumes the object and that its lifetime ends. It knows that the value cannot then be accessed.
* 底部显示的等效的C程序在编译时没有警告，但在运行时有未定义的行为，因为它访问了先前释放的内存。* The equivalent C program, shown at the bottom, will compile without warnings, but has undefined behaviour at runtime since it accesses previously freed memory.

# 数据所有权转移给调用者：Taking Ownership of Data

![](/static/2022-02-17-03-13-34.png)

除了返回数据的所有权外，函数还可以取得一个值的所有权。**当一个值被传递给一个函数时，该函数就取得了该值的所有权**。In addition to returning ownership of data, functions can take ownership of a value. When a value is passed to a function, that function takes ownership of that value.

我们在幻灯片上的代码中看到了这一点，consumer()函数从main()函数中以其参数x的形式**取得了局部变量a的所有权。而且，像往常一样，一旦consumer()函数结束，它所拥有的【任何未返回的数据值就会被销毁**】。We see this in the code on the slide, where the consume() function takes ownership of the local variable, a, from the main() function, in the form of its parameter, x. And, as usual, once the consume() function ends, the values of any data it owns that are not returned, as destroyed.

* 当我们试图编译代码时，我们会看到这一点。**main()函数不能访问局部变量a来打印其长度，因为它不再拥有该值。它把所有权给了consumer()函数，而该函数销毁了这个值，并且没有把它传回来。因此，它在main()中不再被访问，代码无法编译**。* We see this when we try to compile the code. The main() function can’t access the local variable, a, to print its length, since it doesn’t own the value anymore. It gave ownership to the consume() function, and that function destroyed the value and didn’t pass it back. Accordingly, it’s no longer accessible in main() and the code won’t compile.

# ==========

# 4-资源管理：Resource Management

本讲座的最后部分讨论了**如何将基于区域的内存管理扩展到包括资源管理**。它进一步扩展了上一部分介绍的所有权跟踪的概念，并展示了Rust如何支持数据的借用，使基于区域的内存管理变得可行。它**概述了基于区域的内存管理的局限性，以及它是如何限制可以编写的程序类别的**，并讨论了这一点带来的权衡。它回顾了**基于区域的管理是如何被用来执行确定性的资源清理的**。The final part of the lecture discusses how region-based memory management can be extended to include resource management. It further expands on the concept of ownership tracking, introduced in the previous part of the lecture, and shows how Rust supports borrowing of data to make region-based memory management feasible. It outlines the limitations of region-based memory management and how it limits the classes of program that can be written, and discusses the trade-off this imposes. And it reviews how region-based management can be used to enforce deterministic resource clean-up.

# 引用租借：Borrowing Data

在本讲座的最后一部分，我将谈论Rust如何用借用的概念来扩展所有权，以及这如何适用于内存以外的资源的管理。In this final part of the lecture, I’ll talk about how Rust extends ownership with the idea of borrowing, and how this can apply to management of resources other than memory. 

![](/static/2022-02-17-03-27-54.png)

* 我们在上一部分中看到，函数可以在它们之间传递数据的所有权。我们看到了函数是如何取得它们所传递的数据的所有权的，以及它们如何将数据的所有权返回给它们的调用者。We saw in the previous part that functions can pass ownership of data between them. We saw how functions take ownership of data they’re passed, and how they can return ownership of data to their caller. 
* 我们讨论了这与内存管理的关系，当一个对象在函数结束时超出范围，内存将被释放。We discussed how this relates to memory management, with memory being freed when an object goes out of scope at the end of a function. 
* 而且，我们展示了在单一所有权规则的帮助下，Rust如何利用这一点来提供一个基于区域的自动内存管理方案。这可以起作用，但反复向函数传递和返回数据的所有权是不方便的。And, we showed how, with the aid of the single ownership rules, Rust can leverage this to provide an automatic region-based memory management scheme. This can work, but repeatedly passing and returning ownership of data to and from functions is inconvenient. 
* 为了使之更容易，Rust用借来的数据的想法来增强所有权规则。Rust中的函数可以把对数据的引用作为参数。To make this easier, Rust augments the ownership rules with the idea of borrowed data. Functions in Rust can take references to data as parameters. 

# 迭代器无效-原生租借问题: Iterator Invalidation - Problems with Naive Borrowing

![](/static/2022-02-17-03-49-55.png)

**在这个例子中，borrow()函数改变了向量的内容。它把一个新元素推到了向量的末端。在这种情况下，它这样做是安全的。但这并不总是安全的**。In this example, the borrow() function changes the contents of the vector. It pushes a new element onto the end of the vector. And in this case, it’s safe for it to do so. But this is not always safe.

* 例如，**如果main()正在对向量的内容进行迭代，并且在迭代过程中向修改向量的函数传递了一个可变的引用，这可能会导致元素被跳过或重复，或者导致用不一致的数据计算结果**。这是一个被称为迭代器无效化的问题。 For example, if main() was iterating over the contents of the vector, and passed a mutable reference to that vector to a function that modified it, while that iteration was in progress, this might lead to elements being skipped or duplicated, or to a result to be calculated with inconsistent data. This is a problem known as iterator invalidation.

# 不同引用-安全租借：Safe Borrowing

![](/static/2022-02-17-03-56-18.png)
![](/static/2022-02-17-03-56-10.png)
![](/static/2022-02-17-03-56-56.png)
![](/static/2022-02-17-03-59-18.png)

为了避免迭代器失效和其他问题，Rust中的引用有两种不同的类型，并且对它们的使用方式有限制。Rust有两种不同类型的指针；两种不同类型的引用。To avoid iterator invalidation, and other problems, references in Rust come in two different types, and have restrictions on how they can be used. Rust has two different types of pointer; two different types of reference. 

* 第一种写法是&T，是对T类型的**不可变对象的共享引用**。* The first is written &T, and is a shared reference to an immutable object of type T. 
* 第二种是写成&mut T，是对T类型的**可变对象的唯一引用**。* The second is written &mut T, and is a unique reference to a mutable object of type T. 

**Rust编译器和运行时系统一起工作，以控制如何使用引用，并跟踪引用的所有权和引用的值**。有三个基本规则。The Rust compiler and runtime system work together to control how references can be used, and to track ownership of references and the referenced values. There are three fundamental rules. 

* 一个T类型的对象可以**被一个或多个&T类型的引用所引用**。但是，**对于同一个对象，不可能同时拥有可变和不可变的引用**。* An object of type T can be referenced by one or more references of type &T. Or it can be referenced by exactly one reference of type &mut T. But it’s not possible to have both mutable and immutable references to the same object. 
* 如果**一个对象被定义为不可变的，那么就不可能对它有一个可变的引用**。* If an object is defined to be immutable, it’s not possible to take a mutable reference to it. 
* 如果**一个对象被定义为可变的，那么对【该对象的不可变的引用就会在不可变的引用期间使其不可变**】。* If an object is defined to be immutable, it’s not possible to take a mutable reference to it. 

这些限制**使指针在Rust中的工作方式变得复杂**。而且**它们限制了可以编写的程序的范围。但是它们允许函数安全地借用对象，而不需要让出所有权**。* These restrictions complicate how pointers work in Rust. And they limits the set of programs it’s possible to write. But they allow functions to safely borrow objects, without needing to give away ownership.

* 在Rust程序中，**1.要想改变一个对象，你必须拥有这个对象，并且它没有被标记为不可变的。2.或者你必须拥有它的唯一&mut引用**。这些规则防止了迭代器的无效化。* In a Rust program, to be able to change an object, you must either own the object, and it not be marked as immutable. Or you must own the only &mut reference to it. These rules prevent iterator invalidation.
* Rust中的**迭代器被设计为对它们所迭代的对象取一个不可变的引用**。这**保证了该对象不会发生变化，也保证了对该对象的可变引用不会存在（因为不允许同时存在**）。如果被迭代的对象不能改变，那么迭代器也就不能被无效化。**编译器会检查并执行这些规则**。* Iterators in Rust are designed to take an immutable reference to the object over which they iterate. This guarantees that the object can’t change, and that no mutable references to the object can exist. If the object being iterated over cannot change, the iterator cannot be invalidated. The compiler checks and enforces these rules.

# 所有权追踪-优点：Benefits

![](/static/2022-02-17-04-11-29.png)

通过跟踪所有权和控制指针的使用方式，**Rust将其他语言中的各种运行时错误变成了编译时错误**。By tracking ownership, and controlling how pointers are used, Rust turns various issues that are run-time bugs in other languages into compile-time errors.

* Rust**防止了 "使用后"（use-after-free）的错误，因为它使返回数据的引用不可能超过被引用数据的寿命**。* Rust prevents use-after-free bugs by making it impossible to return references to data to outlive the data being referenced. 
  * ![](/static/2022-02-18-02-22-34.png)
* Rust**防止迭代器失效**，因为它**不可能在迭代器存在时改变被迭代的对象**。* Rust prevents iterator invalidation, by making it impossible to change the object being iterated over whilst the iterator exists. 
  * 迭代器需要一个对象的不可变引用
* **Rust还防止了多线程之间的竞赛条件，因为关于指针的规则使得两个线程【不可能各自拥有对同一个对象的可变引用**】。* And Rust prevents race conditions between multiple threads, because the rules about pointers make it impossible for two threads to each have a mutable reference to the same object. 
  * 只允许存在一个可变引用

所有这些行为都是在**编译时检查**的。而Rust有高效的运行时行为。Rust编译器生成的分配和释放内存的代码与使用malloc()和free()的正确编写的C程序完全相同。All these behaviours are checked at compile time. And Rust has efficient run-time behaviour. The Rust compiler generates exactly the same code to allocate and free memory as would a correctly written C program using malloc() and free()

* 不同的是，编译器确保malloc()和free()的**调用是在正确的位置**。因此，**Rust代码的时间和内存使用是可以预测的**，就像一个正确编写的C程序一样。Rust在内存分配和释放的时间上都是确定的。* The difference is that the compiler ensures the malloc() and free() calls are in the correct places. As a result the timing and memory usage of Rust code is a predictable as a correctly written C program. Rust is deterministic in when memory is both allocated and freed.

# 局限性-基于区域内存管理：Limitations of Region-based Systems

![](/static/2022-02-17-04-25-43.png)

Rust使用的基于区域的内存管理方法有一些限制。主要的是，Rust通过限制可能编写的程序类型来确保正确性。**关于所有权和借用的规则使得某些数据结构无法在安全的Rust中表达**。The region-based approach to memory management used by Rust has some limitations though. Primarily, Rust ensures correctness by limiting the types of program it’s possible to write. The rules about ownership and borrowing make it impossible to express certain data structures in safe Rust. 

例如，**不可能编写使用包含引用循环的数据结构的代码**。最典型的例子是，在安全Rust中不可能写出**双链表**。For example, it’s not possible to write code that uses data structures that contain reference cycles. The canonical example of this, is that it’s not possible to write a doubly linked list in safe Rust.

* 如果你看一下幻灯片上的例子，你有一个包含元素a、b和c的列表，你会发现不可能在最后添加一个元素d。* If you look at the example of the slide, where you have a list containing elements a, b, and c, you’ll see that it’s not possible to add an element, d, to the end. 
* 你可以取一个对元素c的不可变的引用，然后把它加到元素d上。这可以做到，因为Rust允许对C的两个不可变的引用存在--一个来自元素b，一个来自元素d。* You can take an immutable reference to element c, and add it to element d. This works, since Rust allows two immutable references to C to exist – one from element b and one from element d.
* 但是，您**不能做的是对元素 c 进行可变引用，以便修改它以添加对元素 d 的引用**。这是**因为已经有一个对元素 c 的不可变引用，由元素 b 持有，并且你不能同时拥有对同一个对象的可变引用和不可变引用**。 What you can’t do, though, is take a mutable reference to element c, in order to modify it to add a reference to element d. This is because there’s already an immutable reference to element c, held by element b, and you can’t have both mutable and immutable references to the same object. 

对引用的限制是为了**防止竞赛条件、迭代器无效等等，也是为了防止循环数据结构**。而且，这不仅仅是双链表。它们防止任何包含指针循环的数据结构。The restrictions on references that prevent race conditions, iterator invalidation, and so on, also prevent cyclic data structures. And it’s not just doubly linked lists. They prevent any data structure that contains a loop of pointers. 

* 这是Rust中引用工作方式的一个基本限制。它以**表现力换取安全性**。* It’s a fundamental limitation of the way references work in Rust. It trades expressive power for safety. 
* Rust的设计者认识到了这一点，并添加了一个逃生舱口。* The designers of Rust recognised this, and added an escape hatch. 

Rust也有第三种类型的引用，被称为**原始指针**。Rust also has a third type of reference, known as the raw pointer. 

* 原始指针的工作方式就像C语言中的指针一样。它们**允许你规避Rust对可变和不可变引用的限制，并使你有可能以与C语言完全相同的方式编写循环数据结构**。一个使用原始指针的Rust程序和C程序一样，**都有可能出现内存安全问题**，比如释放后使用的错误，迭代器无效，以及竞赛条件。* Raw pointers work just like pointers in C. They allow you to circumvent the restrictions that Rust imposes on mutable and immutable references, and make it possible to write cyclic data structures in exactly the same way you would do so in C. Of course, by allowing you to circumvent these restrictions, you lose the safety guarantees of Rust. A Rust program that uses raw pointers is as likely to suffer from memory safety issues, such as use after free bugs, iterator invalidation, and race conditions, as is a C program. 
* 为了明确这一点，**Rust要求在代码中明确地将原始指针的使用标记为不安全**。它警告程序员，并使其很容易发现这种使用。* To make this clear, Rust requires use of raw pointers to be explicitly labelled as unsafe in the code. It warns the programmer, and makes it easy to find such uses. 

安全的Rust还有一个限制，那就是它**不能表达可变数据的共享所有权**。There’s a second limitation of safe Rust, which is that it can’t express shared ownership of mutable data. 

* **不可变数据的共享所有权是直截了当的。许多不同的引用都指向一个不能改变的对象，这是可以的**。* Shared ownership of immutable data is straight-forward. It’s okay for many different references to point to an object that cannot change. 
* 但是，**对可变数据的共享所有权是有问题的，因为它有可能导致竞争条件的产生**。这就是为什么Rust**只允许一个值的单一可变引用同时存在**。* Shared ownership of mutable data is problematic, though, because it potentially open up race conditions. This is why Rust only allows a single mutable reference to a value to exist at once. 
* 但是，偶尔，很少，你需要共享易变的状态。如果你需要的话，**Rust有一个RefCell-of-T类型。它包裹了一些T类型的值，并动态地执行了借用规则**。* But, occasionally, rarely, you need shared mutable state. If you do, Rust has a RefCell-of-T type. This wraps some value of type T, and dynamically enforces the borrowing rules. 
  * 也就是说，它**允许调用者借用或可变地借用被包装的值，并在运行时强制规定只能有不可变的借用，或单个可变的借用，但不能同时进行**。* That is, it allows callers to borrow, or mutably borrow, the wrapped value, and enforces at run time that there can only be immutable borrows, or a single mutable borrow, but not both. 
  * RefCell类型提供了与常规Rust借用规则基本相同的保证，**但在运行时而不是在编译时强制执行**。* The RefCell type provides essentially the same guarantees as the regular Rust borrowing rules, but enforced at run time rather than at compile time. 
  * 这意味着试图采取，例如，**对被包装对象的几个可变引用，将导致代码执行时出现警告，而不是编译失败**。RefCell是安全的，因为它不会导致未定义的行为，但它会**导致【运行时】失败**。* This means that attempts to take, for example, several mutable references to the wrapped object, will cause a panic when the code executes, rather than failing to compile. The RefCell is safe, in that it never causes undefined behaviour, but it can cause a run time failure.

---

不过，基于区域的内存管理的最大问题是，它迫使程序员在设计的早期就明确考虑对象的所有权。我认为，这在多大程度上是个问题，取决于你的背景。Possibly the biggest issue with region-based memory management, though, is that it forces the programmer to consider object ownership explicitly, and early in the design. To what extent this is a problem depends, I think, on your background. 

* 迫使人们尽早明确地考虑对象的所有权 Forces consideration of object ownership early and explicitly
* 一般来说是好的做法，**但在设计过程的早期增加了概念性的负担**--可能会阻碍探索性的编程 Generally good practice, but increases conceptual load early in design process – may hinder exploratory programming
  * 如果你有C语言编程的经验，这往往不是一个问题。编写正确的C语言程序还需要仔细考虑数据所有权，知道哪些函数malloc()数据，哪些函数free()数据。* If you’re experienced at programming in C, this tends to be a non-issue. Writing correct C programs also requires careful consideration of data ownership, to know what functions malloc() data and what functions free() that data. 
    * Rust本质上编纂和执行了那些写得很好的C语言程序往往采用的规则。* Rust essentially codifies and enforces the rules that well-written C programs tend to adopt anyway. 
  * 如果你的经验是像Python或Java这样的语言，其中**使用垃圾收集器或引用计数隐藏了很多内存管理的复杂性，那么需要开始考虑所有权是一个更多的负担**。在这种情况下，用Rust进行有效的编程可能**需要改变你的思维**。* If you’re experience is rather with a language like Python or Java, where the use of a garbage collector or reference counting hides a lot of the complexity of memory management, then needing to start thinking about ownership is more of a burden. In this case, programming effectively in Rust may require a shift in your thinking.

# Summary-基于区域内存管理：Region-based Memory Management

![](/static/2022-02-17-04-40-04.png)

我们对基于区域的内存管理的介绍到此结束。这是Rust的一个比较特殊的功能。它提供了一种**高效且可预测的内存管理方式，并提供了强大的正确性保证，可以防止许多常见的错误。但它是通过限制可以编写的程序类型，以及让程序员明确考虑数据所有权来实现的**。 That concludes our introduction to region-based memory management. This is one of the more unusual features of Rust. It provides an efficient and predictable way of managing memory, and offers strong correctness guarantees that can prevent many common bugs. But it does so by constraining the types of program that can be written, and by making the programmer explicitly consider data ownership.

# 资源管理-(析构)确定性回收：Resource Management-Deterministic Cleanup

![](/static/2022-02-17-04-45-38.png)

正如我们所看到的，Rust跟踪数据的所有权，并在对该内存的引用超出范围时确定地释放堆分配的内存。**特定的类型可以使用这种所有权跟踪来实现自定义的析构器，对它们拥有的资源进行确定性的清理**。As we’ve seen, Rust tracks data ownership, and deterministically frees heap allocated memory when references to that memory go out of scope. Particular types can use this ownership tracking to implement custom destructors that provide deterministic clean-up of resources they own. 

* 如果一个类型实现了**Drop特性**，那么运行时将在该类型的实例的结束时，**当它们超出范围时，调用drop()方法。这使得这些实例能够自我清理**。* If a type implements the Drop trait, then the runtime will call the drop() method on instances of that type at the end of their lifetime, when they go out of scope. This allows those instances to clean-up after themselves. 
* 例如，文件类实现了 Drop 特质，当文件对象超出范围时关闭底层文件。Python 对此有特殊的语法，如幻灯片上所示。**在Rust中**，就像在C++中一样，**当对象超出范围时，清理自然发生，不需要明确的语法**。* For example, the File class implements the Drop trait to close the underlying file when file objects go out of scope. Python has special syntax for this, as shown on the slide. In Rust, much like in C++, the cleanup happens naturally when the object goes out of scope, without the explicit syntax.

# 所有权&状态-资源管理：Resource Management-Ownership and States

![](/static/2022-02-17-04-50-56.png)

最后，正如我们在第4讲讨论基于结构的状态机时看到的，**所有权跟踪允许状态转换被强制执行**。Finally, as we saw in the discussion of struct-based state machines in Lecture 4, ownership tracking allows state transitions to be enforced.

* 一个状态机可以用**结构来表示状态**，并**持有任何需要的状态变量**。* A state machine can be defined using structs to represent the state, and to hold any needed state variables.
* **状态转换**可以通过在这些**结构上定义函数来实现，这些函数消耗自身，并返回一个新的状态**。* And state transitions can be implemented by defining functions on those structs that consume self, and return a new state.

幻灯片显示了一个例子，方法 login() 和 disconnect() 是在 UnauthenticatedConnection 结构上实现的。The slide shows an example, where methods login() and disconnect() are implemented on an UnauthenticatedConnection struct.

* 请注意，这两个方法都将**self作为其第一个参数，而不是&self**。也就是说，它们**取得了它们所实现的结构的所有权，而不是借用该结构**。这意味着它们会消耗自我。* Note that both of these take self as their first parameter, not &self. That is, they take ownership of the struct on which they’re implemented, rather than borrow that struct. This means they consume self.
* 它们会销毁被调用的对象。也就是说，**它们强迫代表状态的对象被销毁。并且它们返回一个新对象的所有权，代表系统的新状态**。* They destroy the object on which they’re called. That is, they force the object representing the state to be destroyed. And they return ownership of a new object, representing the new state of the system.
* 这将**强制清理由该状态持有的、没有明确复制到新状态的任何数据**。它强制了一个**干净的状态转换**。链接的博文进一步讨论了这些问题，我鼓励你去读它。* This forces the cleanup of any data held by that state that’s not explicitly copied to the new state. It enforces a clean state transition. The blog post linked talks about these issues further, and I encourage you to read it.

# ==========

# Readings

1. http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/
2. http://phrack.org/issues/49/14.html#article
3. Source: P. Wilson, “Uniprocessor garbage collection techniques”, Proc IWMM’92, DOI:10.1007/BFb0017182
4. https://blog.systems.ethz.ch/blog/2018/a-hammer-you-can-only-hold-by-the-handle.html