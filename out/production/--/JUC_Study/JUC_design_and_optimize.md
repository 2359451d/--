# Prologue

从面向对象设计角度出发，介绍保障线程安全的设计技术

* <font color="red">可以使得不必借助锁的情况下，保证线程安全</font>
* 避免锁可能导致的问题&开销

- [Prologue](#prologue)
  - [JAVA运行时存储空间](#java运行时存储空间)
  - [Stateless Object: 无状态对象实现线程安全](#stateless-object-无状态对象实现线程安全)
  - [Inmutable Object: 不可变对象](#inmutable-object-不可变对象)
  - [线程特有对象](#线程特有对象)
  - [装饰器模式：实现线程安全](#装饰器模式实现线程安全)
    - [Tool Class: Collections](#tool-class-collections)
  - [锁的优化&注意事项](#锁的优化注意事项)
    - [提高锁性能的5点建议](#提高锁性能的5点建议)
    - [JVM对锁的优化](#jvm对锁的优化)
      - [偏向锁->轻量锁 & 自旋->重量锁](#偏向锁-轻量锁--自旋-重量锁)

## JAVA运行时存储空间

JAVA RUNTIME空间

* 栈
  * 每个线程独立栈空间，固定大小
  * 每调用一个方法，分配一个栈帧
  * 存储，**基本数据类型，引用，局部变量，返回值**，等私有数据
* 堆
  * YG - Copying GC collection algo
    * Eden
    * From(Survivor 0)
    * To(Survivor 1)
  * OG(Tenure Generation) - Mark-Sweep/Mark-Sweep-Compress(Hybrid) GC collection algo
  * 优化调参(`-Xms`默认堆空间，默认1/64，`-Xmx`最大堆空间，默认1/4)
  * 调YG:OG比例`-Xmn`
* 方法区(jdk8元空间)
  * 物理上，看作**NON-HEAP部分**
  * **存常量&类元数据（静态变量，类方法，方法名，参数，返回值等）**
  * 可以动态扩容

## Stateless Object: 无状态对象实现线程安全

对象所包含的**数据**：**对象的状态**

* 实例变量 & 静态变量称为
  * 状态变量

🍊 如果一个资源类的一个实例，**被多个线程共享**，**并不会**使这些线程存储共享状态（**共享资源类的数据**）

* 该资源类实例称为**无状态对象**
* 反之，称为有状态对象

🍬 无状态对象

* 实际上，不包含任何成员变量（无共享数据）

🍬 <font color="red">多线程操作有状态对象，可能产生线程安全问题</font>

* 因此，<font color="blue">使用【无状态对象】可以有效【避免线程安全问题】</font>

## Inmutable Object: 不可变对象

一旦创建，状态不可变

* <font color="red">具有线程安全性</font>
* 当**状态改变**，系统会**创建一个新的不可变对象**，如`String`

🍬 不可变对象满足

* `final`修饰类
  * 防止创建子类来改变它的定义
* `final`修饰所有字段
  * <font color="red">创建时必须显式初始化，不能被修改</font>
  * 否则创建`blank final`对象
* 如果该字段引用了**其他状态可变的对象**(如，集合，数组)
  * 必须用`private`修饰

🍊 应用场景

* 状态变化不频繁【否则造成过多堆对象】
* 同时对一组相关数据进行写操作，
  * <font color="red">可应用不可变对象，保证原子性&避免锁的使用</font>
* 不可变对象作为可靠的MAP键

## 线程特有对象

🍊 <font color="red">不共享对象，每个线程操作各自的资源类对象</font>

* 直接定义
* 或使用`ThreadLocal`实例
  * **为每个访问它的线程，关联一个该线程特有的对象**

## 装饰器模式：实现线程安全

> **为非线程安全对象**，创建一个相应的**线程安全外包装对象**

* 客户端
  * 不直接访问非线程安全对象，**访问它的外包装对象**
* 外包装对象&非线程安全对象，<font color="red">接口相同</font>
  * 即，使用方式相同
  * <font color="blue">外包装对象通常借助锁，以线程安全的方式调用，【非线程安全对象的方法】</font>

🍊 **装饰器模式**优点

* **业务(关注点)分离**
  * 如`HashMap` vs `SynchronizedMap`包装类同步集合
* <font color="red">非线程安全的类版本，设计时</font>
  * 只关注**实现的功能**
* <font color="red">线程安全的类版本，设计时</font>
  * 只关注**线程安全性**

### Tool Class: Collections

🍊 `java.util.Collections`工具类 - 采用装饰器模式

* 提供`synchronizedXXX(xxx)`获取线程安全的集合
  * 返回，指定集合的**外包装对象**
* <font color="red">这类返回的集合，又称为【同步集合】</font>

![](/static/2020-09-09-21-51-45.png)
![](/static/2020-09-09-21-52-48.png)

* 通过锁实现，外包装对象的安全

## 锁的优化&注意事项

### 提高锁性能的5点建议

* **减少锁的持有时间**
  * 如果单个线程持有锁的时间过长，会导致锁的竞争更加激烈，影响系统性能
  * ![](/static/2020-09-09-22-11-28.png)
  * <font color="red">优化：只在必要时进行同步，减少锁的持有时间，提高系统吞吐量</font>
  * ![](/static/2020-09-09-22-13-23.png)
* **减小锁的粒度（granularity）**
  * <font color="blue">一个锁保护的共享数据的数量大小</font>
  * 如果保护的共享数据的数量大 - 该锁粒度粗。否则锁粒度小
  * <font color="blue">如果锁的粒度过粗，会导致线程在申请锁时，需要进行不必要的等待</font>
  * 减小锁粒度 - **削弱多线程锁竞争的一种手段**
  * 如jdk7前，`java.util.concurrent.ConcurrentHashMap`类采用**分段锁(默认16段)**协议，可以提高程序并发性
* **使用读写分离锁，代替独占锁**
  * 使用`ReadWriteLock`读写分离锁可以提高系统性能，也是**减小锁粒度的一种特殊情况**
  * 能**分割数据结构实现减小锁的粒度**，读写锁是对系统功能点的分割
* **延申读写锁思想--锁分离**
  * <font color="blue">读写锁：根据读写操作功能不同进行锁分离</font>
  * 根据应用程序特点，**对独占锁进行分离**
  * 如`java.util.concurrent.LinkedBlockingQueue`类中`take()`从队头取数据&`put()`方法把数据加到队尾。<font color="red">如果采用独占锁，两个操作无法同时并发，可以考虑锁分离。take()有取锁，put()有添加锁</font>。以实现不冲突并发
* **锁粗化**
  * 为了保证有效并发，减少每个线程持有锁的时间。<font color="red">但过度，对同一个锁不断进行请求释放，也会消耗系统资源</font>
  * ![](/static/2020-09-10-16-21-09.png)
  * <font color="green">VM在遇到不断对【同一个锁】进行请求&释放，会整合成对锁的一次请求</font>从而减少对锁的请求次数---**锁的粗化**
  * ![](/static/2020-09-10-16-25-48.png)
  * <font color="blue">开发中，有意识的进行锁粗化。尤其是【循环体】内请求锁</font>
  * ![](/static/2020-09-10-16-30-19.png)

### JVM对锁的优化

1. 锁偏向
   1. 对**加锁操作的优化**
   2. 如果一个线程获得锁，锁**进入偏向模式**。<font color="blue">当这个线程再次请求锁时，无需再做任何同步操作</font>。节省有关锁申请的时间，提高程序性能
   3. 锁偏向在没有锁竞争的场所有较好优化效果。锁竞争激烈场景，每次都是**不同线程请求锁，偏向模式失效**，效果不佳
2. 轻量级锁
   1. 锁偏向失败，VM不会立即挂起线程。**还会使用【轻量级锁】的优化手段**
   2. <font color="blue">将共享对象的头部作为指针，指向持有锁的线程堆栈内部</font>，来【判断一个线程是否持有对象锁】
   3. 如果线程获得轻量级锁成功，进入临界区。<font color="green">否则，表示其他线程抢占了锁。当前线程的锁请求膨胀为重量级锁，并移至阻塞队列</font>

🍊 偏向锁&轻量级锁 - 乐观锁optimistic

🍊 重量级锁 - 悲观锁pessimistic

#### 偏向锁->轻量锁 & 自旋->重量锁

🍬 一个对象刚开始实例化时，没有任何线程访问它

* 为**可偏向的锁**，认为只可能有一个线程来访问他
  * 所以会偏向第一个线程，<font color="blue">这个线程修改对象头(共享对象头指针)称为偏向锁时，使用`CAS`操作，将对象头中`ThreadId`改成自己的`ID`</font>之后再访问共享对象时，只需要对比`ID`
  * 一旦有其他线程访问该对象，<font color="green">偏向锁不会主动释放，所以其他线程可以查看对象的偏向状态</font>。此时产生**对象锁竞争**，<font color="purple">会检查原来持有对象锁的线程是否存活</font>。
    * 如果挂了，则将对象变为无锁状态，<font color="purple">重新偏向新的线程</font>
    * 如果原来对象**依然存活**，则马上执行原来线程的栈，检查对象使用情况。<font color="red">如仍然需要偏向锁，则升级为轻量级锁</font>

🍊 轻量级锁，认为**竞争存在，但程度很轻**

* 一般两个线程并发操作错开，<font color="blue">稍微等待一下（自旋）`blocked`（不需要唤醒），另一个线程就会释放锁</font>
* <font color="red">当自旋超过一定次数，或一个线程持有锁，一个线程自旋，又出现其他线程访问</font>，**轻量级锁膨胀为重量级锁**
  * <font color="green">重量级锁: 除了持有的线程外，其他线程都会阻塞`waiting`（需要唤醒）</font>

🍬 区别在于：状态是`blocked`还是`waiting`，**需不需要额外唤醒挂起**