# Content

* [Content](#content)
* [AOP场景例子](#aop场景例子)
* [动态代理](#动态代理)
  * [改进计算器场景](#改进计算器场景)
  * [局限性](#局限性)
* [AOP专业术语](#aop专业术语)
* [AOP改进计算器](#aop改进计算器)
* [AOP步骤](#aop步骤)
  * [1.导包](#1导包)
  * [2.配置](#2配置)
  * [3.测试](#3测试)
* [cglib为无接口组件创建代理](#cglib为无接口组件创建代理)
* [切入点表达式](#切入点表达式)
* [通知方法执行顺序](#通知方法执行顺序)
* [JoinPoint：连接点细节](#joinpoint连接点细节)
* [returning/throwing属性：接结果/异常](#returningthrowing属性接结果异常)
* [通知方法的参数列表要求](#通知方法的参数列表要求)
* [可重用切入点表达式](#可重用切入点表达式)
* [环绕通知](#环绕通知)
* [环绕&普通通知执行顺序](#环绕普通通知执行顺序)
* [多切面运行顺序 & 切面优先级](#多切面运行顺序--切面优先级)
* [AOP应用 & 使用场景](#aop应用--使用场景)

# AOP场景例子

面向切面 Aspect Oriented Programming

* 基于OOP基础之上
* 程序运行期间，代码动态的切入到指定方法的指定位置进行运行

---

场景例子：计算器计算时添加日志进行记录

* 日志记录：辅助功能
* 业务逻辑：核心功能
* 直接编写在方法内部
  * 耦合，维护麻烦

**希望日志模块能在核心功能运行期间，自己动态的加上**

# 动态代理

代理设计模式的原理：

* 使用一个代理将对象包装起来， 然后用该代理对象取代原始对 象。任何对原始对象的(方法)调用都要通过代理。代理对象决定是否以及何时将方法调用转到 原始对象上
* <font color="deeppink">代理对象为什么能调用目标对象的方法？（不考虑invoke层面），因为创建代理对象传参的时候，传入了类加载器 & 所有实现的接口</font>

![](/static/2021-07-22-14-13-36.png)

## 改进计算器场景

通过j2ee自带的Proxy类给目标对象生成代理对象

* 通过代理对象的方法执行器`InvocationHandler`，帮忙执行目标对象的方法

![](/static/2021-07-22-14-24-02.png)
![](/static/2021-07-22-14-27-59.png)
![](/static/2021-07-22-14-26-41.png)
![](/static/2021-07-22-14-41-51.png)

* 在外面获取代理对象，对代理对象执行方法（内部通过方法执行器，invoke重写**反射调用target目标对象的方法**）

## 局限性

* 写起来太难
* <font color="deeppink">代理对象为什么能调用目标对象的方法？（不考虑invoke层面），因为创建代理对象传参的时候，传入了类加载器 & 所有实现的接口</font>
  * 所以，**如果目标对象没有任何实现接口，无法为他创建代理对象**

spring动态代理难，所以实现了AOP功能（但底层也是动态代理），实现简单，没有强制要求必须实现接口

# AOP专业术语

![](/static/2021-07-22-14-49-34.png)
![](/static/2021-07-22-14-48-42.png)
![](/static/2021-07-22-15-06-00.png)

* **横切关注点**
  * 从每个方法中抽取出来的同一类非核心业务。
* **切面（类）**
  * 封装横切关注点信息的类，每个关注点体现为一个通知方法
* **连接点**
  * 横切关注点在各个目标中的具体体现，对应（**目标对象的可执行方法的）某个特定执行位置**，：某方法（目标对象的）的调用前，调用后，捕捉异常，返回
  * **切入点：特定连接点**
* **切入点表达式**：类似sql，众多连接点中筛选出感兴趣的切入点
* <font color="deeppink">横纵两坐标定位具体连接点：横-特定目标（可执行方法），纵-特定横切关注点</font>
* 在应用 AOP 编程时， 仍然需要定义公共功能， 但可以明确的定义这个功能应用在哪 里， 以什么方式应用， 并且**不必修改受影响的类**。 这样一来**横切关注点**就被模块化到 特殊的类里——这样的类我们通常称之为“切面”

---

4种横切关注点，以通知方法实现。应对目标方法的4类连接点。连接点最终总个数取决于目标方法个数。

一套（4种）通知方法可应用所有目标方法的4种连接点位置

# AOP改进计算器

如何将切面类`LogUtils`的通知方法(横切关注点体现）动态切入目标对象`calculator`的各个可执行方法`add, div, mul, sub`(也就是目标方法)的**各个连接点**位置中

![](/static/2021-07-22-15-10-41.png)
![](/static/2021-07-22-15-11-45.png)

# AOP步骤

## 1.导包

1. 导包
   1. ![](/static/2021-07-22-15-50-42.png)
   2. ![](/static/2021-07-22-15-52-09.png)
   3. 下面3个是加强版面向切面，即使**目标对象没有任何接口也能创建动态代理**

## 2.配置

1.将目标类 & 切面类（封装了通知方法（在目标方法各个连接点、切入点间执行的方法））注入ioc容器中

* 注解 + 扫描

2.告诉spring到底哪个是切面类，用注解 `@Aspect`

* ![](/static/2021-07-22-15-56-44.png)

3.告诉spring，切面类中每个通知方法，都在何时（目标方法的**哪个连接点位置**），何地（目标模块的**哪个目标方法**）运行 --- <font color="deeppink">通知注解</font>

![](/static/2021-07-22-16-14-41.png)

何时 - 目标方法的**哪个连接点位置**

* `@Before`目标方法执行前，**前置通知**
* `@After`目标方法运行结束之后，**后置通知**
* `@AfterReturn`目标方法正常返回之后，**返回通知**
* `@AfterThrowing`目标方法抛出异常之后，**异常通知**
* `@Around`**环绕通知**

何地 - **切入点表达式**（目标模块的**哪个目标方法，`div, add, mul, sub`**）

* 切入点表达式语法 - `execution（访问权限符 返回值类型 方法签名）`
  * 要全类名
* 例子：
  * `@Before("execution(public int xxx.Calc.add(int, int))")`
  * `@Before("execution(public int xxx.Calc.*(int, int))")`
    * 目标模块的所有方法

4.开启基于注解的AOP功能，aop名称空间

![](/static/2021-07-22-16-18-07.png)

* 切入点表达式中涉及的目标bean

## 3.测试

注意从ioc容器中拿到目标对象，**用接口**，不要用本类

![](/static/2021-07-22-16-34-15.png)
![](/static/2021-07-22-16-45-42.png)

* ioc容器中存的是代理对象，当然不能是本类的类型
  * **代理对象跟原目标对象唯一共同就是实现的接口一样**

![](/static/2021-07-22-16-44-02.png)

* 接口一般不放进容器，（放进了也没关系

# cglib为无接口组件创建代理

cglib帮忙创建好的代理对象，类型是本类（无接口）

* **无接口组件原j2EE不支持代理创建，spring中可以通过cglib创建代理**

![](/static/2021-07-22-16-48-19.png)

# 切入点表达式

语法格式

* `execution([ 权限修饰符 ] [ 返回值类型 ] [ 简单类名 / 全类名 ] [ 方法名 ] ( [ 参数列表 ] ) )`

:bulb: 通配符

* `*`
  * **匹配一个或多个字符**
    * `MyMath*.*(..)`
      * 以`MyMath`开头的任意类...
  * **匹配任意一个参数**
  * **匹配一层路径**
  * <font color="deeppink">`*`不能表示任意权限访问符</font>
    * 非要表示任意权限访问符，那个位置可以空着不写
  * **匹配任意返回值**
    * `* com.xxx.Class.*(..)`
* `..`
  * **匹配任意数量，任意类型参数**
  * **匹配任意多层路径**
    * `com.xxx..Class*.*(..)`
      * com.xxx包下的所有包的Class开头的类的所有方法（签名不限制）

操作符

* `||`
* `&&`
* `!`

---

`* *(..)`或 `* *.*(..)` 【知道就行，别这么写】

* 任意包任意类任意方法任意返回值

# 通知方法执行顺序

之前的AspectJ注解的执行顺序有点奇怪，开始结束再返回（before,after再afterreturn），习惯就好

![](/static/2021-07-22-17-12-55.png)

# JoinPoint：连接点细节

切入点表达式通常都会是从宏观上定位一组方法， 和具体某个通知的注解结合 起来就能够确定对应的连接点。那么就一个具体的连接点而言， 我们可能会关心 **这个连接点的一些具体信息， 例如： 当前连接点所在方法的方法名、当前传入的 参数值**等等。

* 这些信息都封装在 `JoinPoint` 接口的实例对象中
* 即，**在通知方法运行的时候，拿到【目标方法】的详细信息**

![](/static/2021-07-22-17-19-44.png)

* 获取签名后还可以进一步获取

---

例子

![](/static/2021-07-22-17-20-58.png)

# returning/throwing属性：接结果/异常

:bulb: **建议这些接收参数的类型往大的写，容错比较好**

**返回通知方法**参数中添加接收参数，之后告诉spring这个参数被指定用来接收返回值

![](/static/2021-07-22-17-25-23.png)

* `@AfterReturning` + `value/pointcut=原切入点表达式` `returning=`属性

**异常通知方法**，同理， 方法加入接收参数后，通过`throwing=`属性告诉spring哪个参数用来接收异常

![](/static/2021-07-22-17-27-30.png)

# 通知方法的参数列表要求

![](/static/2021-07-22-17-31-28.png)

spring对方法权限符，返回值无要求，但参数表中的**参数一定得是spring规定的认识的，不认识的得指明用途**

# 可重用切入点表达式

1. 声明一个没有实现的返回void的空方法 --- **切入点方法**
2. 标注`@PointCut`注解
3. 之后通知方法可以通过**切入点方法**引用切入点（表达式）
   1. `pointcut`属性指定切入点方法

:bulb: 这个切入点方法的访问控制符控制切入点可见性

* <font color="deeppink">如果多个切面类共用，建议切入点方法封装成一个公共类进行管理</font>

![](/static/2021-07-22-18-26-44.png)
![](/static/2021-07-22-18-04-10.png)

# 环绕通知

最强大的通知，相当于一个动态代理

:bulb: 注意，**环绕通知的顺序是正常的，Before，AfterReturn、AfterThrow，After**，普通的是 **Before, After, AfterReturn/Throw**

![](/static/2021-07-22-18-16-38.png)
![](/static/2021-07-22-18-18-09.png)

* =四大通知四合一
* 环绕通知可声明一个**连接点参数** `ProceedingJoinPoint`
  * `proceedingJoinPoint.proceed(args)`方法，**利用反射调用目标方法**，（**必须显示调用，且返回连接点执行结果**）
    * 相当于`method.invoke(args)`

![](/static/2021-07-22-18-11-51.png)
![](/static/2021-07-22-18-13-54.png)

* 可以一套写全了这个环绕通知，针对的是整个目标方法的所有切入点？

# 环绕&普通通知执行顺序

![](/static/2021-07-22-18-34-59.png)

环绕通知优于普通通知执行 （**但前置这一段有时候普通前置在前，这个不重要**）

* 目标方法的执行受控环绕通知的 `ProceedingJoinPoint.proceed()`

:bulb: **为了保证异常可见性，环绕通知里记得把异常抛出去**

![](/static/2021-07-22-18-22-25.png)
![](/static/2021-07-22-18-36-18.png)
![](/static/2021-07-22-18-37-00.png)

# 多切面运行顺序 & 切面优先级

非环绕，多切面

![](/static/2021-07-22-18-44-13.png)
![](/static/2021-07-22-18-44-20.png)
![](/static/2021-07-22-18-51-17.png)

:bulb:可以通过 `@Order(int)`

* 指定切面优先级
* 越小优先级越高

---

环绕例子下的优先级 （切面的环绕只影响当前切面）

![](/static/2021-07-22-18-49-44.png)

# AOP应用 & 使用场景

* 日志，保存到数据库
* 权限验证
  * 安全检查
* **事务控制**