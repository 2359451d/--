# Context

* [Context](#context)
* [注解快速创建组件 - DAO，Service，Controller](#注解快速创建组件---daoservicecontroller)
* [修改注解注册组件的默认行为](#修改注解注册组件的默认行为)
* [context:include-filter](#contextinclude-filter)
* [context:exclude-filter](#contextexclude-filter)
* [@AutoWired：自动装配](#autowired自动装配)
* [@Qualifier - 指定成员变量id](#qualifier---指定成员变量id)
* [方法/形参 - Autowired](#方法形参---autowired)
* [@Resource对比：自动装配](#resource对比自动装配)
* [spring单元测试](#spring单元测试)
* [泛型依赖注入](#泛型依赖注入)
* [带泛型的父类类型确定子类](#带泛型的父类类型确定子类)

# 注解快速创建组件 - DAO，Service，Controller

如果有100个Bean类，那么一个个在配置文件中注册特别麻烦，

* <font color="deeppink">通过给bean加注解快速注册进ioc容器中</font>
* **局限性**：添加别人写的组件还是得靠配置注册，所以建议结合注解 &bean配置

Controller(控制器，控制网站跳转逻辑 ，相当于servlet)

---

步骤：（<font color="blue">一定要导入AOP包</font>)

1. 4个注解,**某类上添加以下注解就能实现快速添加进容器**，注解给开发看的（spring5底层好像会检查？）

* `@Controller`
  * 控制器层组件
* `@Service`
  * 业务逻辑层组件
* `@Repository`
  * 数据库层，持久化层（DAO）
* `@Component`
  * 不属于以上几层的组件，但想要注册

2. 告诉Spring自动扫描添加注解的组件，依赖`context`名称空间

* `context:component-scan`,指定基础包
  * 下面两个扫描额外操作在下一个section
  * `context:include-filter`
  * `context:exclude-filter`
* ![](/static/2021-07-21-18-13-37.png)

3. 验证获取组件 - <font color="deeppink">id默认 - 类名首字母小写</font>

* ![](/static/2021-07-21-18-15-52.png)

# 修改注解注册组件的默认行为

通过注解注册的组件和通过配置注册的默认行为一样，但也可以重新定义

---

改默认id

![](/static/2021-07-21-18-20-04.png)

改作用域（单/多实例）

* `@Scope(value="prototype")`

![](/static/2021-07-21-18-20-57.png)

# context:include-filter

使用context:include-filter指定扫描包时要包含的类，善用结合上层基础包的 `use-default-filters`

* type=
  * **`annotation` 标了指定注解的组件不要扫描**
  * **`assignable` 指定排除某个具体的类**
  * `aspect` aspect表达式
  * `custom` 自定义`TypeFilter`
  * `regex`正则

例子

![](/static/2021-07-21-18-40-36.png)

# context:exclude-filter

使用context:exclude-filter指定扫描包时不包含的类

* type=
  * **`annotation` 标了指定注解的组件不要扫描**
  * **`assignable` 指定排除某个具体的类**
  * `aspect` aspect表达式
  * `custom` 自定义`TypeFilter`
  * `regex`正则

例子

```xml
<context:component-scan base-package="java">
    <context:exclude-filter type="annotation" expression="java.lang.ModuleLayer.Controller"/>
</context:component-scan>
```

# @AutoWired：自动装配

使用@Autowired注解实现根据类型实现自动装配★

* spring自动为某属性赋值，去容器中找到对应的组件

:bulb: 原理

* 先按照**属性类型**去容器中找到组件
  * ioc.getBean(XXX.class)
* 找到就赋值，没找到就抛异常
* **找到多个组件（class下**）
  * 按照**属性标识符**作为id继续匹配
    * 最后还没有，如果`@Autowired(required=true)`（默认）就报错
    * 如果`@Autowired(required=false)`，就赋`null`

![](/static/2021-07-21-22-04-08.png)
![](/static/2021-07-21-22-05-21.png)

# @Qualifier - 指定成员变量id

`@Qualifier`指定一个名作为id，让spring不要用默认标识符作为装配的查找id

![](/static/2021-07-21-22-15-54.png)

# 方法/形参 - Autowired

方法上Autowired，

* 方法上每个形参（引用类型）都会自动注入
  * 先按类型
  * 再按id
* 这个方法回在bean创建的时候运行

![](/static/2021-07-21-22-24-18.png)

**也可以结合使用`@Qualifier`注解**
![](/static/2021-07-21-22-25-13.png)

# @Resource对比：自动装配

`@AutoWired`，`@Resource`，`@Inject`都是自动装配

* `Autowired`最强大，spring定义
* `Resource`，j2ee，java标准
  * 扩展性更强，因为上面的容器框架离开spring就不能用

# spring单元测试

1. 导入test包
2. 使用`@ContextConfiguration(locations="")`指定**spring配置文件路径**
   1. 之前需要自己手动根据配置文件路径new一个`ApplicationContext`ioc容器
3. `@RunWith()`指定用**哪种驱动进行单元测试**，默认是junit
   1. `@RunWith(SpringJunit4ClassRunner.class)`,使用Spring单元测试模块执行 `@Test`测试方法
4. 之后写出来的单元测试类成员就可以支持自动装配
   1. 用junit单元测试还是得ioc中取，`ioc.getBean(xxx)`

![](/static/2021-07-21-22-44-28.png)

# 泛型依赖注入

![](/static/2021-07-21-23-00-51.png)

* Base组件不注册，但是有子类组件继承该base且被注册进容器，它也会被注册

![](/static/2021-07-21-23-01-50.png)
![](/static/2021-07-21-23-03-58.png)
![](/static/2021-07-21-23-03-38.png)
![](/static/2021-07-21-23-04-15.png)

* 子类组件默认继承Base中的方法，就算Base方法默认执行对Base类中成员的操作，最后还是会给子类组件自动注入其相对应的成员？？
* 强调的是 **泛型**

---

原理

![](/static/2021-07-21-23-10-53.png)

# 带泛型的父类类型确定子类

![](/static/2021-07-21-23-13-24.png)