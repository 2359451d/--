# Content

* [Content](#content)
* [虚拟机栈](#虚拟机栈)
  * [栈内存溢出](#栈内存溢出)
  * [线程运行诊断](#线程运行诊断)
* [Native Method Stacks:本地方法栈](#native-method-stacks本地方法栈)
* [堆](#堆)
  * [堆内存溢出](#堆内存溢出)
  * [堆内存诊断](#堆内存诊断)
    * [jps](#jps)
    * [jmap](#jmap)
    * [jconsole:图形化界面](#jconsole图形化界面)
  * [jvisualvm：gc后内存占用仍高](#jvisualvmgc后内存占用仍高)
* [PC](#pc)
* [方法区](#方法区)
  * [hotspot方法区实现例子](#hotspot方法区实现例子)
  * [方法区内存溢出](#方法区内存溢出)
* [运行时常量池](#运行时常量池)
* [串池：StringTable](#串池stringtable)
  * [intern](#intern)
* [直接内存：os](#直接内存os)
* [禁用显式gc](#禁用显式gc)
* [============](#)
* [GC Roots](#gc-roots)
* [垃圾回收：可达性分析算法](#垃圾回收可达性分析算法)
* [jmap抓快照，memoryAnalyzer看内存泄漏](#jmap抓快照memoryanalyzer看内存泄漏)
* [引用](#引用)
  * [软引用](#软引用)
  * [引用队列](#引用队列)
  * [弱引用](#弱引用)
* [垃圾回收算法](#垃圾回收算法)
  * [引用计数](#引用计数)
  * [标记清除：mark sweep](#标记清除mark-sweep)
  * [标记整理:mark compact](#标记整理mark-compact)
  * [复制算法：copy](#复制算法copy)
* [分代垃圾回收](#分代垃圾回收)
* [垃圾回收-VM相关参数](#垃圾回收-vm相关参数)
* [OOM例子](#oom例子)
* [============](#-1)
* [垃圾回收器](#垃圾回收器)
  * [串行](#串行)
  * [吞吐量优先](#吞吐量优先)
  * [CMS：响应时间优先](#cms响应时间优先)
* [G1：TBC](#g1tbc)
* [============](#-2)
* [类文件结构](#类文件结构)
* [============](#-3)

# 虚拟机栈

`-Xss`

* 越大，固定物理内存情况下，线程数越少

![](/static/2022-02-05-14-46-42.png)

* 栈帧 - 每个方法运行时需要的内存

![](/static/2022-02-05-14-57-55.png)

## 栈内存溢出

`StackOverflowError`

* 栈帧过多导致栈内存溢出
* 栈帧过大导致栈内存溢出

## 线程运行诊断

![](/static/2022-02-05-15-09-38.png)

死锁
![](/static/2022-02-05-15-15-47.png)
![](/static/2022-02-05-15-16-12.png)

# Native Method Stacks:本地方法栈

![](/static/2022-02-05-15-17-05.png)

本地方法运行时使用

# 堆

`-Xmx`

* `-Xmx8m`

![](/static/2022-02-05-15-19-06.png)

## 堆内存溢出

`OutOfMemoryError:Java heap space`

![](/static/2022-02-05-15-26-20.png)

## 堆内存诊断

![](/static/2022-02-05-15-36-34.png)

### jps

查看系统中有哪些java进程

### jmap



---

jmap
![](/static/2022-02-05-15-41-27.png)
![](/static/2022-02-05-15-42-11.png)

* 每个时间点检测一遍
* `jmap -heap`
* 1
  * ![](/static/2022-02-05-15-43-42.png)
* 2 - 数组创建
  * ![](/static/2022-02-05-15-44-31.png)
* 3 - gc后
  * ![](/static/2022-02-05-15-45-37.png)

### jconsole:图形化界面

![](/static/2022-02-05-15-46-36.png)

![](/static/2022-02-05-15-46-56.png)

* 分配数组

![](/static/2022-02-05-15-47-20.png)

* gc

## jvisualvm：gc后内存占用仍高

堆快照 `dump`

![](/static/2022-02-05-15-54-44.png)

student不被回收

# PC

![](/static/2022-02-05-14-43-09.png)

# 方法区

`-XX:MaxPermSize=8m`

* 1.8前，永久代

`-XX:MaxMetaspaceSize=8m`

* 默认用的是系统物理内存
* 1.8

![](/static/2022-02-05-15-56-01.png)

## hotspot方法区实现例子

![](/static/2022-02-05-16-00-00.png)

* 移到本地内存（os
* StringTable放在堆里

## 方法区内存溢出

1.8前

永久代溢出

![](/static/2022-02-05-16-04-47.png)
![](/static/2022-02-05-16-08-27.png)

1.8后是元空间，默认是系统内存，，没有设置上限，观查不到方法区溢出

# 运行时常量池

![](/static/2022-02-05-16-27-27.png)

---

![](/static/2022-02-05-16-23-53.png)
![](/static/2022-02-05-16-24-13.png)

* 查常量池表翻译

# 串池：StringTable

`-XX:StringTableSize=桶个数`

* 调优
* 调大减少哈希冲突，，每个桶装的字符串少
* 或者存在大量字符串对象时，考虑让字符串入池，节约堆空间

常量拼接（编译优化），变量拼接

![](/static/2022-02-05-17-08-57.png)
![](/static/2022-02-05-16-31-47.png)
![](/static/2022-02-05-17-02-26.png)

底层哈希表，，Token转为字符串对象时（lazy）先判断串池中存不存在

![](/static/2022-02-05-16-35-45.png)

---

## intern

![](/static/2022-02-05-20-36-07.png)

---

1.8

![](/static/2022-02-05-20-32-38.png)
![](/static/2022-02-05-20-35-23.png)

---

1.6

![](/static/2022-02-05-20-39-35.png)

---

1.8
![](/static/2022-02-05-20-42-06.png)

![](/static/2022-02-05-20-42-50.png)

---

1.6

# 直接内存：os

![](/static/2022-02-05-21-11-21.png)
![](/static/2022-02-05-21-24-02.png)

---

![](/static/2022-02-05-21-12-07.png)
![](/static/2022-02-05-21-13-49.png)

# 禁用显式gc

![](/static/2022-02-05-21-27-28.png)

显式gc是full gc，开销高，

* 注意会影响直接内存的回收

# ============

# GC Roots

一组必须活跃的引用。
基本思路就是通过一系列名为”GCRoots”的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GCRoots没有任何引用链相连时，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的就自然被判定为死亡

![](/static/2022-02-06-17-46-17.png)
![](/static/2022-02-06-17-46-50.png)

* Class - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots，.
* Thread - 活着的线程
* Stack Local - Java方法的local变量或参数
* JNI Local - JNI方法的local变量或参数
* JNI Global - 全局JNI引用
* Monitor Used - 用于同步的监控对象
* Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM并没有为这些对象提供其它的信息，因此就只有留给分析分员去确定哪些是属于"JVM持有"的了。

# 垃圾回收：可达性分析算法

* 根对象GC roots：一定不被回收的
* Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
* **扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以**
* 回收
哪些对象可以作为 GC Root ?

# jmap抓快照，memoryAnalyzer看内存泄漏

常规的处理方法是首先通过该内存映像分析工具堆Dump出来的堆转储快照进行分析。

* 首先应确认内存中导致OOM的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。
* 如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链，找到泄露对象是通过怎样的引用路径、与那些GC Root 相关联，才导致垃圾收集器无法回收它们。如图使用 IDEA 插件 VisualVM Launcher插件链接以Debug 模式启动 可以比较准确的定位到产生内存泄漏的代码具体位置

---

抓快照

![](/static/2022-02-05-21-43-28.png)

![](/static/2022-02-05-21-49-46.png)
![](/static/2022-02-05-21-50-09.png)

* 看gc roots

# 引用

![](/static/2022-02-05-21-58-57.png)

![](/static/2022-02-05-22-00-20.png)

* 一般都是强引用（实线）
* 强引用只有引用全断开时，对象才能被回收
  * ![](/static/2022-02-05-22-13-37.png)

---

![](/static/2022-02-05-22-23-06.png)

* 只存在软引用，gc后内存不充足情况下回收
  * ![](/static/2022-02-05-22-20-17.png)
* 只存在弱引用，只要gc了就回收（不管内存充不充足）
  * 应该表述为：每次gc都可能会导致弱引用的对象被回收，不是一定会被回收的
  * ![](/static/2022-02-05-22-21-13.png)
* **对象回收之后，软弱引用可以进引用队列**
  * 引用自身也占用内存，可以通过引用队列管理

* **虚引用，终结器引用必须进引用队列** 
  * ![](/static/2022-02-05-22-40-23.png)
* 虚引用bytebuffer没有强引用可以被回收，但是直接内存不会被jvm管理
  * ![](/static/2022-02-06-00-03-34.png)
  * 虚引用进引用队列，然后Unsafe.freeMemory回收直接内存
  * 直接内存不在jvm中，没办法被垃圾回收，因此虚引用关联，当ByteBuffer被回收时，虚引用直接进入引用队列，本地方法随即根据引用队列中的相关信息调用unsafe清除本地方法的内存

终结器引用

![](/static/2022-02-06-00-04-13.png)

* 重启finalize()方法，且没有强引用，被回收
* 然后先把终结器引用放进引用队列，再来回收对象（A4）
  * ![](/static/2022-02-06-00-05-17.png)

## 软引用

![](/static/2022-02-06-00-09-42.png)

* 内存敏感情况下，，转为软引用，，不重要的引用空间紧张时可以被回收

## 引用队列

配合软引用例子

当软引用关联的对象被回收，软引用自己会被加到队列中

![](/static/2022-02-06-00-24-20.png)

## 弱引用

![](/static/2022-02-06-00-43-48.png)

* 前4次放进去，gc不收掉引用对象
* 第5次要收掉一个才能新放引用

# 垃圾回收算法

## 引用计数

Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。
因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器，每当有一个地方引用它，计数器值加1，每当有一个引用失效时，计数器值减1。

任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。

那为什么主流的Java虚拟机里面都没有选用这种算法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。

![](/static/2022-02-06-17-45-23.png)

## 标记清除：mark sweep

![](/static/2022-02-06-00-48-51.png)
![](/static/2022-02-06-16-40-54.png)

* 速度快，空间不连续但容易产生空间碎片

## 标记整理:mark compact

![](/static/2022-02-06-16-42-36.png)

* 慢，不会产生空间碎片

## 复制算法：copy

![](/static/2022-02-06-16-45-54.png)

* 双倍空间
* 没有空间碎片

# 分代垃圾回收

![](/static/2022-02-06-16-50-44.png)

* Eden区没有足够空间进行分配时,虚拟机将发起一次Minor GC <<深入理解java虚拟机第二版>>p130
* 对象存活次数高，放进老年代，因为老年代回收频率低
  * **如果内存实在紧张，可能没达到阈值就会提前晋升老年代**
  * **或者新生代看起来gc后也放不下一个大对象，大对象会直接放进老年代，，不会触发gc**
* 在新生代对象准备过来的时候，发现老年代空间已经不足了，就执行一次Minor GC 如果能清理出空间就让他在新生代呆着，目的是尽量减少full gc的发生
* 新生代 - 复制算法
* 老年代 - 标记清除/整理

# 垃圾回收-VM相关参数

![](/static/2022-02-06-17-22-13.png)

# OOM例子

新生代放不下，老年代也放不下，且gc roots（list）有强引用，不能回收掉，，触发堆溢出

![](/static/2022-02-06-17-40-19.png)

* 触发minor, 再full，，还是不够，抛异常

---

![](/static/2022-02-06-17-42-26.png)

# ============

# 垃圾回收器

## 串行

`-XX:+UseSerialGC = Serial + SerialOld`

![](/static/2022-02-06-17-53-49.png)

* Serial - 新生代，复制
* SerialOld - 老年代，标记整理/清除
* **单线程**
  * 其他用户线程要先阻塞等待gc线程完成再恢复
* 堆内存较小，适合个人电脑

## 吞吐量优先

`-XX:+UseParallelGC ~ -XX:+UseParallelOldGC`

`-XX:+UseAdaptiveSizePolicy`

`-XX:GCTimeRatio=ratio` 

* 1/(1+ratio)，一般堆会被调大

`-XX:MaxGCPauseMillis=ms`

* 默认200ms

`-XX:ParallelGCThreads=n`

![](/static/2022-02-06-17-55-53.png)

* **多线程**
  * 线程数默认和cpu核数挂钩
* 堆内存较大，多核 cpu
* **让单位时间内，STW 的时间最短** 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高
  * 一个小时内可能只发生2次gc，吞吐量就上去了

## CMS：响应时间优先

标记清除

`-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld`

* 并发
* ![](/static/2022-02-06-18-27-51.png)

`-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads`

-XX:CMSInitiatingOccupancyFraction=percent

-XX:+CMSScavengeBeforeRemark


* **多线程**
* 堆内存较大，多核 cpu
* 尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5

# G1：TBC

![](/static/2022-02-06-18-35-00.png)

# ============

![](/static/2022-02-06-18-38-31.png)

类加载器把字节码加载到jvm中

解释+编译来运行

# 类文件结构

![](/static/2022-02-06-18-40-06.png)

* u+字节数

魔数

0~3 字节，表示它是否是【class】类型的文件

0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09

版本

![](/static/2022-02-06-21-51-40.png)



# ============
