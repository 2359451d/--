# Content

* [Content](#content)
* [ioc部分](#ioc部分)
* [aop](#aop)
  * [案例 - 手动实现代理（加事务）](#案例---手动实现代理加事务)
  * [AOP术语](#aop术语)
  * [@EnableAspectJAutoProxy - 开启注解AOP支持](#enableaspectjautoproxy---开启注解aop支持)
  * [AspectJAutoProxyRegistrar](#aspectjautoproxyregistrar)
  * [@Aspect - 配置切面](#aspect---配置切面)
  * [两个不同切面的相同通知](#两个不同切面的相同通知)
  * [@Pointcut - 配置切入点表达式](#pointcut---配置切入点表达式)
    * [@Pointcut方法访问修饰符](#pointcut方法访问修饰符)
  * [通知注解的执行顺序](#通知注解的执行顺序)
  * [@Before](#before)
  * [@After](#after)
  * [@AfterReturning](#afterreturning)
  * [@AfterThrowing](#afterthrowing)
  * [同一切面内相同通知执行顺序](#同一切面内相同通知执行顺序)
  * [@Around](#around)
  * [args()](#args)
  * [@DeclareParents - 扩展目标类](#declareparents---扩展目标类)
  * [@EnableLoadTimeWeaving - 开启类加载时期的增强](#enableloadtimeweaving---开启类加载时期的增强)
* [AOP注解执行过程及核心对象的分析](#aop注解执行过程及核心对象的分析)

# ioc部分

。。~~看typora笔记，不放这了~~

ioc部分见pdf，做了点修改

# aop

## 案例 - 手动实现代理（加事务）

如果不用aop，自己实现事务控制

![](/static/2021-08-27-14-41-32.png)
![](/static/2021-08-27-14-39-07.png)
![](/static/2021-08-27-14-38-55.png)

* 明显所有事务方法都需要自己加逻辑，，冗余

---

走手动代理模式加事务控制（代理来执行目标方法）

![](/static/2021-08-27-16-07-27.png)
![](/static/2021-08-27-16-07-59.png)
![](/static/2021-08-27-16-10-22.png)

* 最后把代理对象返回去，然后@Bean注入代理对象

## AOP术语

![](/static/2021-08-27-16-26-50.png)

## @EnableAspectJAutoProxy - 开启注解AOP支持

![](/static/2021-08-28-13-30-23.png)

* 引入切入点自动代理的导入器

作用：

表示开启spring对注解aop的支持。它有两个属性，分别是指定**采用的代理方式和 是否暴露代理对象**，通过AopContext可以进行访问。从定义可以看得出，**它引入 `AspectJAutoProxyRegistrar.class`对象**，该对象是基于注解@EnableAspectJAutoProxy 注册一个AnnotationAwareAspectJAutoProxyCreator，该对象通过调用 AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(regist ry);注册一个aop代理对象生成器。关于AnnotationAwareAspectJAutoProxyCreator请参 考第五章第二小节《AnnotationAwareAspectJAutoProxyCreator对象的分析》

属性：

* `proxyTargetClass`：
  * 指定是否采用cglib进行代理（创建其子类来代理）。**默认值是false，表示使用jdk的代理（目标类最少实现一个接口**）。
* `exposeProxy`：
  * 指定**是否暴露代理对象**，通过AopContext可以进行访问。
  * ![](/static/2021-08-28-13-38-07.png)这种时候走的不是代理
    * ![](/static/2021-08-28-13-39-04.png) 设置暴露代理对象
    * ![](/static/2021-08-28-13-39-52.png)

使用场景：
当我们注解驱动开发时，在需要使用aop实现某些功能的情况下，都需要用到此注
解。

## AspectJAutoProxyRegistrar

这玩意被上面注解@Import，

![](/static/2021-08-28-13-45-03.png)
![](/static/2021-08-28-13-45-41.png)
![](/static/2021-08-28-13-45-49.png)

* 作用：**往ioc里面注册一个bean【名称写死，自动代理创建器AnnotationAwareAspectJAutoProxyCreator**】
  * 目的：后续获取代理对象，为增强方法做准备
* 也就是准备bean定义的时候，走配置类后处理的时候，会把AnnotationAwareAspectJAutoProxyCreator的bean定义注册进来【先把创建器定义加入】
  * 里面再把EnableAspectJAutoProxy注解类给取出来
    * 先取出来注解的属性【是否暴露，是否采用cglib】。然后取出创建器的bean定义，往里面加属性
      * ![](/static/2021-08-28-14-31-32.png)

## @Aspect - 配置切面

![](/static/2021-08-28-14-33-41.png)

作用：

* 声明当前类是一个切面类。

属性：

* `value`:
  * **默认我们的切面类应该为单例的(不指定value**)。但是当切面类为一个多例类时，指定预处理的切入点表达式。
  * 用法是perthis(【预处理】切入点表达式)。
    * 它支持指定切入点表达式，或者是用@Pointcut修饰的方法名称（要求全 限定方法名）
    * bean会按多例处理，每次使用时创建（所以需要一个预处理的切入点表达式，避免每次都要去获取）
      * <font color="deeppink">但通知注解的切入点表达式还是不能省，【但只会走预处理的切入】</font>
      * ![](/static/2021-08-28-14-44-37.png)

使用场景：

* 此注解也是一个注解驱动开发aop的必备注解

## 两个不同切面的相同通知

按切面类名顺序执行【可用@Order改变，越小优先级越高】

![](/static/2021-08-28-15-41-37.png)

## @Pointcut - 配置切入点表达式

![](/static/2021-08-28-15-43-11.png)

作用：

* 此注解是用于指定切入点表达式的。

属性：

* value:
  * 用于指定切入点表达式。表达式的配置详解请参考第五章节第三小节《切 入点表达式的写法》
* argNames:
  * 用于指定切入点表达式的参数。参数可以是execution中的，也可以是 args中的。**通常情况下不使用此属性也可以获得切入点方法参数**。

使用场景：

* 在实际开发中，当我们的多个通知需要执行，同时增强的规则确定的情况下，就可 以把切入点表达式通用化。此注解就是代替xml中的<aop:pointcut>标签，实现切入点表达 式的通用化

---

使用例子

![](/static/2021-08-28-15-46-34.png)

![](/static/2021-08-28-15-49-19.png)
![](/static/2021-08-28-15-50-02.png)

* 指定`argNames`，通知方法能获取到切入方法时形参所传入的值
  * **通常情况下不使用此属性也可以获得切入点方法参数**
    * ![](/static/2021-08-28-15-52-05.png)
    * `args()`里面标识符必须与空方法形参一致

---

### @Pointcut方法访问修饰符

![](/static/2021-08-28-15-57-11.png)

* 改成`public`就能通用引用
* 所以可以直接抽给一个公共切入点表达式类

是  bean工厂，也就是bean本身后处理（BeanFactoryPostProcessor）的时候解析@pointcut

## 通知注解的执行顺序

![](/static/2021-08-28-16-05-48.png)

![](/static/2021-08-28-16-06-30.png)

* 通知方法放进数组，链式顺序调用造成了顺序有点奇怪（前-目标-最终-后置 & 前-目标-最终-异常）

## @Before

被此注解修饰的方法为前置通知。前置通知的执行时间点是在切入点方法执行之 前

用场景：

* 在实际开发中，我们需要对切入点方法执行之前进行增强， 此时就用到了前置通 知。在通知（增强的方法）中需要获取切入点方法中的参数进行处理时，就要配合切入点表达 式参数来使用

![](/static/2021-08-28-16-12-49.png)
![](/static/2021-08-28-16-13-51.png)

* `argNames`属性可以不写

## @After

最终通知

最终通知的执行时机，是在切入点方法执行完成之后执行，无论切入点方法执行是 否产生异常最终通知都会执行。所以被此注解修饰的方法，通常都是做一些清理操作

## @AfterReturning

![](/static/2021-08-28-16-17-24.png)

* 用于配置后置通知。后置通知的执行是在切入点方法正常执行之后执行。
* 需要注意的是，由于基于注解的配置时,**spring创建通知方法的拦截器链时，后置 通知在最终通知之后，所以会先执行@After注解修饰的方法（5.2.7版本已经修复**)。

属性：

* value:
  * 用于指定切入点表达式，可以是表达式，也可以是表达式的引用。
* pointcut:
  * 它的作用和value是一样的。
* returning:
  * 指定切入点方法返回值的变量名称。它必须和切入点方法返回值名称一 致。
* argNames:
  * 用于指定切入点表达式参数的名称。它要求和切入点表达式中的参数名称 一致。通常不指定也可以获取切入点方法的参数内容。

使用场景：

* 此注解是用于配置后置增强切入点方法的。被此注解修饰方法会在切入点方法正常 执行之后执行。在我们实际开发中，像提交事务，记录访问日志，统计方法执行效率等等都可 以利用后置通知实现。

returning的使用（后置通知取到目标方法正常执行后的返回值）

![](/static/2021-08-28-16-23-58.png)
![](/static/2021-08-28-16-25-01.png)

## @AfterThrowing

作用：
用于配置异常通知。

属性：

* value:
  * 用于指定切入点表达式，可以是表达式，也可以是表达式的引用。
* pointcut:
  * 它的作用和value是一样的。
* throwing:
  * 指定切入点方法执行产生异常时的异常对象变量名称。它必须和异常变量 名称一致。
* argNames:
  * 用于指定切入点表达式参数的名称。它要求和切入点表达式中的参数名称 一致。通常不指定也可以获取切入点方法的参数内容。

使用场景：

* 用此注解修饰的方法执行时机是在切入点方法执行产生异常之后执行

throwing使用 - 获取异常

![](/static/2021-08-28-16-29-01.png)

## 同一切面内相同通知执行顺序

![](/static/2021-08-28-16-33-50.png)

* 谁的ascii码小谁先执行，注解驱动开发时，相同切面内同一种通知方法会对比每个字母的ascii码

方法重载时，会继续比较（从括号开始比

![](/static/2021-08-28-16-36-05.png)

## @Around

作用：

用于指定环绕通知。

属性：

* value:
  * 用于指定切入点表达式，可以是表达式，也可以是表达式的引用。
* argNames:
  * 用于指定切入点表达式参数的名称。它要求和切入点表达式中的参数名称 一致。通常不指定也可以获取切入点方法的参数内容。

使用场景：

* 环绕通知有别于前面介绍的四种通知类型。它不是指定增强方法执行时机的，而是 **spring为我们提供的一种可以通过编码的方式手动控制增强方法何时执行的机制**

---

获取目标方法传参 - ProceedingJointPoint

![](/static/2021-08-28-17-14-21.png)

* 如果目标方法有形参，不写任何参数`pjp.getArgs()`直接调用proceed()也可以正常执行

## args()

https://blog.csdn.net/yangshangwei/article/details/77731696

该函数接收一个类名，表示目标类方法入参对象是指定类（包含子类）时，切点匹配。

不指定类型的话，如果通知方法入参制定了类型，就参考

![](/static/2021-08-28-18-00-13.png)

## @DeclareParents - 扩展目标类

![](/static/2021-08-28-17-31-53.png)

作用：

* 用于给被增强的类提供新的方法。（实现新的接口）
  * **动态给目标类添加新方法**

属性：

* value:
  * 用于指定目标类型的表达式。**当在全限定类名后面跟上+时，表示当前类 及其子类**
  * 指定哪些类走注解标注的功能，，（功能还是走代理调用，哪些类会再实现注解的接口）
* defaultImpl:
  * 指定提供方法或者字段的默认实现类。

使用场景：

* 当我们已经完成了一个项目的某个阶段开发，此时需要对已完成的某个类加入一些 新的方法，**我们首先想到的是写一个接口，然后让这些需要方法的类实现此接口，但是如果目 标类非常复杂，牵一发而动全身，改动的话可能非常麻烦**。此时就可以使用此注解，然后建一 个代理类，同时代理该类和目标类。
  * 比如service，想给他的操作添加校验功能。改service接口本身，可能非常麻烦。

---

例子 - 给userservice目标类添加校验功能（校验功能会走代理调用）

![](/static/2021-08-28-17-37-14.png)
![](/static/2021-08-28-17-43-06.png)

触发校验方式1【类似写在控制器里，但是如果我们没办法改控制器的逻辑，就不适用这类场景下触发校验，应采用方式2】
![](/static/2021-08-28-17-47-21.png)

触发校验方式2（通知里做，注意args是切入点的传参，表示目标类方法入参对象是指定类（包含子类）时，切点匹配，，**使用this关键字，引入新目标类对象，调用方法 触发**）
![](/static/2021-08-28-17-56-02.png)

## @EnableLoadTimeWeaving - 开启类加载时期的增强

作用：

* 用于切换不同场景下实现增强。【有选择性的增强】

属性：

* aspectjWeaving：是否开启LTW的支持。
* ENABLED 开启LTW
* DISABLED 不开启LTW
* AUTODETECT 如果类路径下能读取到META‐INF/aop.xml文件,则开启LTW,否则关 闭

使用场景：

* 在Java 语言中，从织入切面的方式上来看，存在三种织入方式：**编译期织入、类 加载期织入和运行期织入**。
  * **编译期织入**是指在Java编译期，采用特殊的编译器，将切面织入 到Java类中；
  * 而**类加载期织入**则指通过特殊的类加载器，在类字节码加载到JVM时，织入切 面；
    * `@EnableLoadTimeWeaving`类加载器时期进行织入，执行目标类方法时增强
  * **运行期织入**则是采用CGLib工具或JDK动态代理进行切面的织入。
    * `@EnableAspectJAutoProxy`
* AspectJ提供了两种切面织入方式，第一种通过特殊编译器，在编译期，将AspectJ 语言编写的切面类织入到Java类中，可以通过一个Ant或Maven任务来完成这个操作；第二种 方式是类加载期织入，也简称为LTW（Load Time Weaving）

---

需要配置文件 `META_INF/aop.xml`

![](/static/2021-08-28-18-13-04.png)

导入新坐标

![](/static/2021-08-28-18-13-23.png)

配置类上开启注解`@EnableLoadTimeWeaving`

运行测试

![](/static/2021-08-28-18-16-50.png)

# AOP注解执行过程及核心对象的分析

@EnableAspectJAutoproxy - 往ioc里注册了个创建器(AnnotationAwareAspectAutoProxyCreator)的定义

refresh()阶段 【AbstractApplicationContext】

* 调用bean工厂后置处理器（处理bean定义，最后修改机会）时 - 会实例化&调用所有BeanFactoryPostProcessor & 其子类BeanDefinitionRegistryPostProcessor 
  * `BeanFactoryPostProcessor` - 允许在实例化任何bean之前读取bean定义，并能修改
  * `BeanDefinitionRegistryPostProcessor` - **优先级更高（我记得@Configuration注解的类，PriorityOrder会在这里处理**）。<font color="deeppink">可以在上面那玩意之前优先注册其他bean定义</font>
    * 所以也可以通过这玩意，来注册一些常规bean定义，因为这玩意比`BeanFactoryPostProcessor`优先执行
* **注意我们@Configuration类上开启了aop，然后@EnableAspectAutoProxy本身又@Import了一个AspectAutoProxyRegistrar**
  * `AspectAutoProxyRegistrar`作用：**往ioc里面注册一个bean【名称写死，自动代理创建器AnnotationAwareAspectJAutoProxyCreator**】
  * 目的：后续获取代理对象，为增强方法做准备
  * 也就是准备bean定义的时候，走配置类（@Configuration，，BeanDefinitionRegistryPostProcessor）后处理的时候，
    * AspectJAutoProxyRegistrar里面的方法`registerBeanDefinitions()`
      * 会先往ioc中，通过`AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);`创建一个创建器`AnnotationAwareAspectJAutoProxyCreator`的bean定义，
      * 然后再把`EnableAspectJAutoProxy`注解类给取出来
        * 先取出来注解的属性值【是否暴露，是否采用cglib】。然后**取出创建器的bean定义**，往里面加属性,也就是对创建器做设置
        * ![](/static/2021-08-28-14-31-32.png)