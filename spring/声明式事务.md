# Content

declaration transaction

* [Content](#content)
* [事务](#事务)
* [声明式事务](#声明式事务)
* [基本DAO & 业务逻辑搭建](#基本dao--业务逻辑搭建)
* [快速为某方法添加事务](#快速为某方法添加事务)
  * [注解添加事务例子](#注解添加事务例子)
* [事务细节：注解传参](#事务细节注解传参)
  * [timeout - 超时设置](#timeout---超时设置)
  * [readOnly - 只读](#readonly---只读)
  * [noRollBackFor - 指定哪些运行时异常可以不回滚](#norollbackfor---指定哪些运行时异常可以不回滚)
  * [rollBackFor - 指定不回滚的异常回滚](#rollbackfor---指定不回滚的异常回滚)
* [isolation - 隔离级别](#isolation---隔离级别)
* [读未提交 - 脏读](#读未提交---脏读)
* [读已提交](#读已提交)
* [可重复读](#可重复读)
* [容器中有事务的组件](#容器中有事务的组件)
* [事务传播行为](#事务传播行为)
  * [例子](#例子)
* [本类事务方法之间的调用看做一个事务](#本类事务方法之间的调用看做一个事务)
* [基于XML配置声明式事务](#基于xml配置声明式事务)

# 事务

![](/static/2021-07-23-15-53-06.png)

# 声明式事务

以前通过复杂编程式事务，现在替换为只需要告诉spring**哪个方法是事务方法即可**。spring自动进行事务控制

事务管理代码的固定模式作为一种 横切 关 注点（通知方法体现，事务整个流程分出来切入点） ， 可以通过 **AOP** 方法模块化，式事务管理。

![](/static/2021-07-23-16-00-52.png)

* spring提供一个事务管理器接口`PlatformTransactionManager`，不用自己写这个切面了
  * 事务管理器可以**在目标方法（DAO操作）前后进行事务控制（事务切面）**

![](/static/2021-07-23-15-46-22.png)

:bulb:AOP环绕通知来实现`@Transaction`

![](/static/2021-07-23-15-49-40.png)

# 基本DAO & 业务逻辑搭建

DAO

![](/static/2021-07-23-15-37-02.png)
![](/static/2021-07-23-15-38-27.png)

---

Service

![](/static/2021-07-23-15-40-44.png)

---

![](/static/2021-07-23-15-45-01.png)

* 无事务情况下，某步骤出错，其他步骤不受影响，操作无法撤销回滚

# 快速为某方法添加事务

1.注入事务管理器，让其进行事务控制（因为是切面，所以记得导入3个切面相关jar）

* 让它控制住数据源

![](/static/2021-07-23-16-03-20.png)

2.开启**基于注解**的事务控制模式，依赖tx名称空间

![](/static/2021-07-23-16-04-53.png)
![](/static/2021-07-23-16-05-19.png)

3.给**事务方法（目标方法）加注解`@Transactional`**

![](/static/2021-07-23-16-14-16.png)

## 注解添加事务例子

DAO
![](/static/2021-07-23-19-25-48.png)

Service
![](/static/2021-07-23-19-25-41.png)

配置数据源（外部配置文件）

![](/static/2021-07-23-19-27-03.png)

& 配置JDBCTemplate操作数据库（通过有参构造器或property标签引用数据源）

![](/static/2021-07-23-19-28-31.png)

& 配置事务管理器`PlatformTransactionManager`接口下实现类（声明式事务，一个切面，依赖aop3个jar包）

* jdbc用 `DataSourceTransactionManager`

![](/static/2021-07-23-19-30-32.png)

开启基于注解的声明式事务，依赖tx名称空间

* `tx:annotation-driven transaction-manager=""`

![](/static/2021-07-23-19-31-24.png)

给目标事务方法添加注解 `@Transactional`

![](/static/2021-07-23-19-32-14.png)

# 事务细节：注解传参

`@Transactional(属性=)`

* isolation - Isolation
  * **隔离界别**
* propagation - Propagation
  * **传播行为**
* 
* noRollbackFor - Class[]
  * **哪些异常事务可以不回滚**
* noRollbackForClassName -String[]
  * String全类名
* rollbackFor - Class[]
  * **哪些异常，事务需要回滚**
* rollbackForClassName - String[]
  * 全类名
* readOnly - boolean
  * **设置事务为只读事务**
* timeout - int
  * **事务超出指定执行时长后自动终止并回滚**
  * 秒

---

:bulb: 异常分类

* **运行时异常（非检查/非受控异常**）
  * 可以不用处理，**默认都回滚**
* **编译时异常（检查/受控异常**）
  * 要么try-catch，要么声明throws，**默认不回滚**

## timeout - 超时设置

![](/static/2021-07-23-19-41-08.png)

超时会自动终止并回滚

## readOnly - 只读

可以事务优化，加快查询速度（省去事务中一堆操作，加锁之类的）

![](/static/2021-07-23-19-43-11.png)

* 只允许查

## noRollBackFor - 指定哪些运行时异常可以不回滚

让原来默认回滚的运行时异常不回滚

`@Transactional(noRollBackFor{NullPointerException.class, ArithmeticException.class})`

![](/static/2021-07-23-19-55-21.png)

* 设置之后不回滚了，，数据库会被影响

---

`noRollbackForClassName`要写全类名，比较麻烦

![](/static/2021-07-23-19-56-18.png)

## rollBackFor - 指定不回滚的异常回滚

**默认编译时异常不回滚**，可以设置让它回滚

![](/static/2021-07-23-19-58-32.png)

# isolation - 隔离级别

![](/static/2021-07-23-20-00-55.png)

隔离，并发运行各个事务的能力

![](/static/2021-07-23-20-01-41.png)

* **脏读**
  * 读到没提交的数据 - 脏数据
* **不可重复读**
  * 可以允许发生
* **幻读**

:bulb:各个隔离级别来应对这些问题

![](/static/2021-07-23-20-04-46.png)

* 读未提交 - 出现脏读
* 读已提交 - 避免脏读
* 可重复读 - 避免不可重复读，mysql的幻读
* 串行化 - 无并发能力

---

可以注解里设置隔离级别，也可以配置中通过tx域名空间调

![](/static/2021-07-23-20-12-14.png)

# 读未提交 - 脏读

![](/static/2021-07-23-20-18-00.png)

# 读已提交

![](/static/2021-07-23-20-24-19.png)

# 可重复读

![](/static/2021-07-23-21-11-54.png)

# 容器中有事务的组件

有事务的业务逻辑，容器中保存的是这个业务逻辑的**代理对象**（cglib创建的）

# 事务传播行为

事务传播 + 事务行为

传播行为

* 如果有**多个事务嵌套运行**，子事务是否要与大事务共用一个事务

当 **事务方法被 另 一个事务方法 调 用时， 必须指定事务应该如 何传播** 。 

* 例 如： 方法可能 继续 在现有事务中运行， 也可能开 启 一个 新 事务， 并在自 己 的事务中运 行。

---

:bulb: spring7种类传播行为

![](/static/2021-07-23-21-24-03.png)
![](/static/2021-07-23-21-41-24.png)
![](/static/2021-07-23-21-41-55.png)

* 前两种最常用
* `REQUIRES_NEW` - 当前事务总是使用一个新事务，如果已经有事务，会将之前事务挂起
* `REUQIRED` - 当前事务和之前大事务共用一个事务
  * 子事务属性来源于大事务

---

## 例子

:bulb: 注意大事务 & 小事务编写位置，

* 不要图方便在小事务类中编写大事务的方法

![](/static/2021-07-23-21-56-55.png)
![](/static/2021-07-23-21-57-58.png)

---

例子 - 大事务里面套了两个小事务方法

![](/static/2021-07-23-21-26-46.png)
![](/static/2021-07-23-21-27-58.png)
![](/static/2021-07-23-21-29-41.png)

* 传播级别改成`REQUIRED` - 运行时需要事务，没有就新建
  * 当前事务和之前大事务共用一个事务
* 上面3个事务相当于一起运行，有一个地方异常就一起异常了，一起回滚（运行时异常默认）

---

![](/static/2021-07-23-21-33-08.png)

下面改成`REQUIRES_NEW`如果出异常不影响上面两个被一起执行的事务

* `REQUIRES_NEW` - 当前事务总是使用一个新事务，如果已经有事务，会将之前事务挂起

# 本类事务方法之间的调用看做一个事务

:bulb: 注意大事务 & 小事务编写位置，

* 不要图方便在小事务类中编写大事务的方法

![](/static/2021-07-23-21-56-55.png)
![](/static/2021-07-23-21-57-58.png)

* 所以如果mulTx出异常，即使另外两个事物方法传播行为为`REQUIRES_NEW`也会一起回滚，因为这几个算作一个事务

# 基于XML配置声明式事务

:bulb: 重要的拿配置，不重要的用注解

之前注入好数据源，JDBCTemplate，事务管理器，开启的是基于注解的声明式事务`tx:annotation-driven transaction-manager=""`

---

基于XML同理，依赖于tx & aop名称空间（因为事务管理器是一个切面，要指定它切入哪些事务方法，**善用切入点表达式 & 可重用切入点**）

1.先**注入**好数据源，JDBCTemplate，事务管理器（这一步只是注入）

2.配置切入点表达式，**表示事务管理器要切入这些方法**（哪些方法要加事务还得后面配）

3.配置事务管理器（，指明到底哪些方法是事务方法，及参数细节，timeout等等），然后作id，被事务建议/增强绑定

4.aop命名空间·绑定好这个事务管理器的配置 & 切入点表达式

![](/static/2021-07-23-23-03-19.png)