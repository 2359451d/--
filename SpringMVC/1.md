# Content

* [Content](#content)
* [简介](#简介)
* [HelloWorld](#helloworld)
  * [配置](#配置)
    * [spring框架自身配置](#spring框架自身配置)
  * [创建controller处理派发请求](#创建controller处理派发请求)
  * [配视图解析器](#配视图解析器)
* [运行流程概述](#运行流程概述)
* [RequestMapping](#requestmapping)
  * [类上注解](#类上注解)
  * [RequestMapping支持Ant路径风格](#requestmapping支持ant路径风格)
  * [@PathVariable - 获取路径占位符](#pathvariable---获取路径占位符)
* [/ & /* 区别](#---区别)
  * [DefaultServlet](#defaultservlet)
* [不指定配置文件位置](#不指定配置文件位置)
* [REST风格](#rest风格)
* [HiddenHttpMethodFilter](#hiddenhttpmethodfilter)
  * [配置Filter](#配置filter)
  * [发起请求](#发起请求)
  * [源码](#源码)
* [请求参数获取](#请求参数获取)
  * [@RequestParam](#requestparam)
  * [@RequestHeader](#requestheader)
  * [@CookieValue](#cookievalue)
* [请求参数处理 - POJO](#请求参数处理---pojo)
* [支持Servlet原生API作为入参](#支持servlet原生api作为入参)
* [请求数据乱码](#请求数据乱码)
* [============](#)
* [响应数据输出](#响应数据输出)
  * [Map，Model，ModelMap](#mapmodelmodelmap)
  * [ModelAndView](#modelandview)
  * [@SessionAttributes](#sessionattributes)
  * [@ModelAttribute](#modelattribute)

# 简介

spring简化web开发

![](/static/2021-07-26-19-13-36.png)
![](/static/2021-07-26-19-15-23.png)

* springweb模块称为SpringMVC

---

以前MVC模式

![](/static/2021-07-26-19-17-30.png)
![](/static/2021-07-26-19-17-37.png)

SpringMVC模式

![](/static/2021-07-26-19-20-50.png)

* 多了个**前端控制器**（请求转给控制器，响应回来时数据模型派发给指定的页面，再进行页面渲染

# HelloWorld

导包，配置，测试

## 配置

**web.xml配置 & 框架本身配置**

配前端控制器拦截所有请求，并实现智能派发

* 前端控制器（spring提供） - 本身servlet，所以在web.xml中完成配置
  * 注意指定**springmvc配置文件路径**（类路径下）

```xml
   <servlet>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <servlet-name>springDispatcherServlet</servlet-name>

        <!-- 初始化时加载配置文件 -->
        <init-param>
            <!-- 指定spring配置文件位置 -->
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc.xml</param-value>
        </init-param>

        <!-- 容器在启动时立即加载Servlet(原本是第一次访问创建对象)
            值越小，优先级越高，越先创建对象
            -->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springDispatcherServlet</servlet-name>
<!--        /* 和 / - 拦截所有请求，
            /* 范围更大：还会拦截到*.jsp页面请求，一旦拦截jsp页面就无法显示
            / - 不会拦jsp
            -->
        <url-pattern>/</url-pattern>
    </servlet-mapping>
```

### spring框架自身配置

spring配置文件

* 包扫描，域名空间

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
<!--    扫描所有组件-->
    <context:component-scan base-package="top.bento"></context:component-scan>

</beans>
```

创建jsp页面

## 创建controller处理派发请求

以前路径的处理要配置servlet路径(urlpattern)，现在可以直接定义Controller组件，加注解实现

* `@Controller`
* `@RequestMapping`

这种未改进方法返回的路径太长了 ，可以配一个视图解析器

```java
/*
 * description: 告诉springmvc这是个处理器，处理请求
 * @ Controller:标识控制器
 * @param null
 * @return
 */
@Controller
public class MyFirstController {
    /**
     * 从当前项目下开始，处理当前项目下的hello请求
     */
    @RequestMapping("/hello")
    public String firstGet() {
        System.out.println("processing...");
        return "/WEB-INF/pages/sources.jsp";
    }
}
```

## 配视图解析器

简化请求处理方法的返回值（长路由路径）

* `InternalResourceViewResolver`
  * `suffix`
  * `preffix`

```xml
<!--    视图解析器，拼接路由-->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/pages/"/>
        <property name="suffix" value=".jsp"/>
    </bean>
```

```java
    @RequestMapping("/hello")
    public String firstGet() {
        System.out.println("processing...");
        //配置视图解析器
        return "sources";
    }
```

# 运行流程概述

![](/static/2021-07-28-21-50-01.png)

1. HTTPGET请求
2. mvc前端控制器收到所有请求（`/`)
3. 来看请求地址和 `@RequestMapping`标注的方法哪个匹配
4. 找到目标处理器&类，反射执行目标方法
5. 方法执行完毕，返回值 - 转发页面路径
6. 获取返回值， 视图解析器拼接url
7. 前端控制器转发请求至页面

# RequestMapping

告诉springmvc，方法用来处理什么请求

* `/`可以省略，即使省略也是从当前项目下开始（webapps下项目名）

:bulb: 属性

* **填写的路径默认是 `value`属性**
  * URL路径上可以有占位符（可变参）
* `method`
  * **限定请求方式，默认所有请求**
  * `RequestMethod`枚举类
    * GET，HEAD，POST，PUT...
* `params`
  * 规定请求参数（**查询参数 query string**)
  * 如`params={"username"}`，请求时必须带username这个参数
  * 如`params={"username=123"}`，请求时必须带username=123（值）这个参数
  * 如`params={"!username"}`，请求时**不能带**username这个参数
  * **支持多规则，用`,`隔开**
* `headers`
  * 规定请求头
  * 如 `User-Agent`客户端访问信息
  * ![](/static/2021-07-28-21-55-19.png)
* `consumes`
  * 只接收内容类型是哪种的请求，相当于请求头的 `Content-Type`
* `produce`
  * 返回的内容类型，响应头 `Content-Type`

---

![](/static/2021-07-28-21-33-21.png)

## 类上注解

为当前控制器类的所有方法的请求地址指定一个基准路径

![](/static/2021-07-28-21-35-44.png)

* 必须在`/haha`下访问到handle01

## RequestMapping支持Ant路径风格

![](/static/2021-07-28-22-07-04.png)

* 模糊匹配
* RequestMapping也支持Ant风格的url

![](/static/2021-07-28-22-16-16.png)

* `?` - 任意一个字符
* `*` - 多个字符 或 单层路径
* `**` - 多层路径

:bulb: 模糊和精确多个匹配情况下，精确优先

## @PathVariable - 获取路径占位符

通过 @PathVariable 可以将 **URL 中占位符参数（value属性中的路径**）绑定到控制器处理方法的**入参（形参**）中

* 占位符只能占一层路径

![](/static/2021-07-29-13-26-41.png)

# / & /* 区别

原本`/`拦截所有请求，**不包括jsp页面**（`*.jsp`)

* 此时 `*.jsp`<font color="blue">因为不被拦截交给tomcat的`JspServlet`处理</font>
* 而其他请求（如`*.html`静态资源），原本交给`DefaultServlet`，<font color="deeppink">但是如果子模块覆写url-pattern为`/`，会禁用掉`DefaultServlet`，转而交给前端控制器来处理</font>
  * 如果不存在方法能处理这个静态资源，那么就返回404

:bulb: 为什么jsp可以访问？

* 因为如果前端控制器配`/`，**首先不会拦截jsp请求**，而是会被tomcat服务器的`JspServlet`拦截到进行处理

---

`/*`**拦截所有请求**（包括`*.jsp`），拦截jsp页面，

* 所以如果前端控制器配`/*`，会把jsp请求也拦截到，而如果找不到对应controller就报错

## DefaultServlet

tomcat中处理静态资源的（除jsp之外）

# 不指定配置文件位置

web.xml中配springmvc前端控制器时，不指定配置文件位置

![](/static/2021-07-28-20-45-12.png)

* 默认找 `WEB-INF/<dispatcher_servlet_name>-servlet.xml`
  * 匹配配置文件中指定的name，`servlet-name`标签

:bulb: 不想指定位置就可以直接在WEB-INF文件夹下创建 `xxx-servlet.xml`配置文件

# REST风格

![](/static/2021-07-29-13-39-20.png)

![](/static/2021-07-29-13-43-06.png)

* 风格统一的设计
* 以简洁url提交请求，以请求方式区分对资源的操作

:bulb: 问题

* 默认form表单只支持GET，POST请求，
* 需要配置spring3.0支持的过滤器`HiddenHttpMethodFilter`，可以将请求转换为标准http方法，使其支持其他HTTP请求

:bulb: 注意高版本tomcat不支持PUT，DELTE这种方法，

* jsp头加 `isErrorPage=True`

# HiddenHttpMethodFilter

:bulb: 问题

* 默认form表单只支持GET，POST请求，
* 需要配置spring3.0支持的过滤器`HiddenHttpMethodFilter`，可以将请求转换为标准http方法，使其支持其他HTTP请求

---

## 配置Filter

web.xml中配置spring提供的filter

```xml
<!--    support RESTful-->
    <filter>
        <filter-name>HiddenHttpMethodFilter</filter-name>
        <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>HiddenHttpMethodFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
```

## 发起请求

发 送 POST 请求 时携带 一个 `name="_method"` 的 隐含域`type=hidden` ， 值 为 PUT 或 DELETE

![](/static/2021-07-29-15-26-07.png)
![](/static/2021-07-29-15-26-16.png)

---

controller指定method

![](/static/2021-07-29-15-27-00.png)

## 源码

![](/static/2021-07-29-15-28-45.png)
![](/static/2021-07-29-15-31-28.png)

# 请求参数获取

默认方式获取请求（查询）参数 `xxx?username=admin`

![](/static/2021-07-29-15-42-58.png)

* 直接给方法入参上写一个和请求参数名`username`相同的变量

---

## @RequestParam

`@RequestParam`

* 显式获取请求参数
* `value`
  * 参数名
* `required`
  * 默认情况下，请求参数必须包含对应参数，不存在将抛出异常
* `defaultValue`
  * 默认值，没有传递参数时使用该值

![](/static/2021-07-29-15-43-45.png)
![](/static/2021-07-29-15-44-49.png)
![](/static/2021-07-29-15-47-51.png)

## @RequestHeader

获取请求头信息

![](/static/2021-07-29-15-50-40.png)
![](/static/2021-07-29-15-50-50.png)
![](/static/2021-07-29-15-54-26.png)

## @CookieValue

以前获取cookie，麻烦

![](/static/2021-07-29-15-57-01.png)

---

获取请求中cookie值

* `value`
* `required`
* `defaultValue`

![](/static/2021-07-29-15-57-54.png)
![](/static/2021-07-29-15-58-10.png)

# 请求参数处理 - POJO

如果请求参数是一个POJO，springmvc支持自动填充

* 将POJO属性，一一与请求参数配对
* **支持级联封装**
  * ![](/static/2021-07-29-16-06-26.png)
  * ![](/static/2021-07-29-16-07-56.png)

---

POJO类 （有参无参）
![](/static/2021-07-29-16-02-55.png)

表单指定的请求参数名要对应的上
![](/static/2021-07-29-16-04-08.png)

实现自动填充
![](/static/2021-07-29-16-03-45.png)

# 支持Servlet原生API作为入参

![](/static/2021-07-29-16-22-34.png)
![](/static/2021-07-29-16-25-43.png)

* 能用的基本前3个

---

例子

![](/static/2021-07-29-16-23-14.png)
![](/static/2021-07-29-16-23-34.png)

* 利用原生API的域对象，在页面中渲染数据

# 请求数据乱码

![](/static/2021-07-29-16-30-16.png)
![](/static/2021-07-29-16-30-24.png)

建议

![](/static/2021-07-29-16-33-20.png)

* 一般配置在任何其他Filter之前

# ============

# 响应数据输出

如何将数据带给页面

* 原本是通过原生API向域对象里添加数据，然后EL表达式在页面中取出数据

---

spirngmvc可以通过以下方式输出数据

![](/static/2021-07-29-19-48-31.png)

## Map，Model，ModelMap

:bone: Map，Model，ModelMap，这些参数中保存的所有数据都会放在**请求域**`RequestScope`中，可以在页面中获取

* 不管用的哪个，最终都是转为`BindingAwareModelMap`，**相当于`BindingAwareModelMap`保存的数据都会放在请求域中**
  * 推荐使用`Map`，**方便框架移植**
* 关系
  * ![](/static/2021-07-29-19-57-04.png)
  * ![](/static/2021-07-29-19-58-32.png)
* 使用
  * ![](/static/2021-07-29-19-59-27.png)
  * ![](/static/2021-07-29-20-02-34.png)

## ModelAndView

方法返回值可以转为ModelAndView类型

![](/static/2021-07-29-20-03-50.png)
![](/static/2021-07-29-20-06-06.png)

* 视图名 - 页面
  * 视图解析器会帮我们最终拼串得到页面真实地址
* 数据放在请求域中`RequestScope`

## @SessionAttributes

给session域添加数据 （推荐不要使用这个注解，可能会引发异常，使用原生API）

* 类（控制器）上注解
* 属性
  * `value`
    * 如果用Map/Model/ModelMap给`BindingAwareModelMap`中指定保存的数据，其`key`符合`value`属性指定的值，同时会给session中保存一份
  * `types`
    * 只要数据符合指定的类型，就也在session域中放一份

![](/static/2021-07-29-20-18-03.png)

## @ModelAttribute

以前没有mybatis会用到

:question: 问题 - 场景，全字段修改演示（一般都不会进行全字段更新，，）

* 一般可以显示不需要修改的字段（但不支持用户输入）
* 而如果为了简单，springmvc中入参直接写一个POJO对象，如果某属性映射不到，会自动注入`null`。**如果之后调用了一个全字段更新的DAO操作，那么这个`null`值会被注入进原本不该修改的字段**
  * ![](/static/2021-07-29-20-57-07.png)

:bone: 解决方案 - 思想

* 如果为`null`，就从数据库中取出的对象值，带了的字段的就改为携带的值，此时全字段更新无问题
  * 即，不应该采用springmvc自己new出来的对象，而应该用数据库中取出来的对象，再进行封装

---

`@ModelAttribute`

* 注解位置
  * 方法 - 在执行方法之前运行
    * 可以提前查出数据库中对象信息。**然后在更新方法中指明使用这个查出来的对象，而不是自己new的**
    * ![](/static/2021-07-29-21-28-41.png)
    * ![](/static/2021-07-29-21-28-30.png)
  * 入参前
    * 获取域对象中存储的数据
* 原理
  * ![](/static/2021-07-29-21-36-19.png)
  * ![](/static/2021-07-29-21-36-26.png)
  * `BindingAwareModelMap`request域数据共享容器
