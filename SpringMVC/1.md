# Content

源码部分跳过了，，0经验没能力看 :face_with_head_bandage:

* [Content](#content)
* [简介](#简介)
* [HelloWorld](#helloworld)
  * [配置](#配置)
    * [spring框架自身配置](#spring框架自身配置)
  * [创建controller处理派发请求](#创建controller处理派发请求)
  * [配视图解析器](#配视图解析器)
* [运行流程概述](#运行流程概述)
* [RequestMapping](#requestmapping)
  * [类上注解](#类上注解)
  * [RequestMapping支持Ant路径风格](#requestmapping支持ant路径风格)
  * [@PathVariable - 获取路径占位符](#pathvariable---获取路径占位符)
* [/ & /* 区别](#---区别)
  * [DefaultServlet](#defaultservlet)
* [不指定配置文件位置](#不指定配置文件位置)
* [REST风格](#rest风格)
* [HiddenHttpMethodFilter](#hiddenhttpmethodfilter)
  * [配置Filter](#配置filter)
  * [发起请求](#发起请求)
  * [源码](#源码)
* [请求参数获取](#请求参数获取)
  * [@RequestParam](#requestparam)
  * [@RequestHeader](#requestheader)
  * [@CookieValue](#cookievalue)
* [请求参数处理 - POJO](#请求参数处理---pojo)
* [支持Servlet原生API作为入参](#支持servlet原生api作为入参)
* [请求数据乱码](#请求数据乱码)
* [============](#)
* [响应数据输出](#响应数据输出)
  * [Map，Model，ModelMap](#mapmodelmodelmap)
  * [ModelAndView](#modelandview)
  * [@SessionAttributes](#sessionattributes)
  * [@ModelAttribute](#modelattribute)
    * [POJO](#pojo)
    * [与SessionAttribute产生的异常](#与sessionattribute产生的异常)
    * [源码](#源码-1)
* [底层 - DispatcherServlet](#底层---dispatcherservlet)
* [源码 - 请求大致流程](#源码---请求大致流程)
  * [getHandler（）](#gethandler)
  * [HandlerAdapter](#handleradapter)
* [9大组件](#9大组件)
  * [目标方法执行](#目标方法执行)
* [视图解析](#视图解析)
  * [forward:/](#forward)
  * [redirect:/](#redirect)
  * [（源码）原理](#源码原理)
  * [JstlView - 国际化](#jstlview---国际化)
    * [坑](#坑)
  * [mvc:view-controller](#mvcview-controller)
  * [自定义视图解析器 & 视图](#自定义视图解析器--视图)

# 简介

spring简化web开发

![](/static/2021-07-26-19-13-36.png)
![](/static/2021-07-26-19-15-23.png)

* springweb模块称为SpringMVC

---

以前MVC模式

![](/static/2021-07-26-19-17-30.png)
![](/static/2021-07-26-19-17-37.png)

SpringMVC模式

![](/static/2021-07-26-19-20-50.png)

* 多了个**前端控制器**（请求转给控制器，响应回来时数据模型派发给指定的页面，再进行页面渲染

# HelloWorld

导包，配置，测试

## 配置

**web.xml配置 & 框架本身配置**

配前端控制器拦截所有请求，并实现智能派发

* 前端控制器（spring提供） - 本身servlet，所以在web.xml中完成配置
  * 注意指定**springmvc配置文件路径**（类路径下）

```xml
   <servlet>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <servlet-name>springDispatcherServlet</servlet-name>

        <!-- 初始化时加载配置文件 -->
        <init-param>
            <!-- 指定spring配置文件位置 -->
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc.xml</param-value>
        </init-param>

        <!-- 容器在启动时立即加载Servlet(原本是第一次访问创建对象)
            值越小，优先级越高，越先创建对象
            -->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springDispatcherServlet</servlet-name>
<!--        /* 和 / - 拦截所有请求，
            /* 范围更大：还会拦截到*.jsp页面请求，一旦拦截jsp页面就无法显示
            / - 不会拦jsp
            -->
        <url-pattern>/</url-pattern>
    </servlet-mapping>
```

### spring框架自身配置

spring配置文件

* 包扫描，域名空间

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
<!--    扫描所有组件-->
    <context:component-scan base-package="top.bento"></context:component-scan>

</beans>
```

创建jsp页面

## 创建controller处理派发请求

以前路径的处理要配置servlet路径(urlpattern)，现在可以直接定义Controller组件，加注解实现

* `@Controller`
* `@RequestMapping`

这种未改进方法返回的路径太长了 ，可以配一个视图解析器

```java
/*
 * description: 告诉springmvc这是个处理器，处理请求
 * @ Controller:标识控制器
 * @param null
 * @return
 */
@Controller
public class MyFirstController {
    /**
     * 从当前项目下开始，处理当前项目下的hello请求
     */
    @RequestMapping("/hello")
    public String firstGet() {
        System.out.println("processing...");
        return "/WEB-INF/pages/sources.jsp";
    }
}
```

## 配视图解析器

简化请求处理方法的返回值（长路由路径）

* `InternalResourceViewResolver`
  * `suffix`
  * `preffix`

```xml
<!--    视图解析器，拼接路由-->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/pages/"/>
        <property name="suffix" value=".jsp"/>
    </bean>
```

```java
    @RequestMapping("/hello")
    public String firstGet() {
        System.out.println("processing...");
        //配置视图解析器
        return "sources";
    }
```

# 运行流程概述

![](/static/2021-07-28-21-50-01.png)

1. HTTPGET请求
2. mvc前端控制器收到所有请求（`/`)
3. 来看请求地址和 `@RequestMapping`标注的方法哪个匹配
4. 找到目标处理器&类，反射执行目标方法
5. 方法执行完毕，返回值 - 转发页面路径
6. 获取返回值， 视图解析器拼接url
7. 前端控制器转发请求至页面

# RequestMapping

告诉springmvc，方法用来处理什么请求

* `/`可以省略，即使省略也是从当前项目下开始（webapps下项目名）

:bulb: 属性

* **填写的路径默认是 `value`属性**
  * URL路径上可以有占位符（可变参）
* `method`
  * **限定请求方式，默认所有请求**
  * `RequestMethod`枚举类
    * GET，HEAD，POST，PUT...
* `params`
  * 规定请求参数（**查询参数 query string**)
  * 如`params={"username"}`，请求时必须带username这个参数
  * 如`params={"username=123"}`，请求时必须带username=123（值）这个参数
  * 如`params={"!username"}`，请求时**不能带**username这个参数
  * **支持多规则，用`,`隔开**
* `headers`
  * 规定请求头
  * 如 `User-Agent`客户端访问信息
  * ![](/static/2021-07-28-21-55-19.png)
* `consumes`
  * 只接收内容类型是哪种的请求，相当于请求头的 `Content-Type`
* `produce`
  * 返回的内容类型，响应头 `Content-Type`

---

![](/static/2021-07-28-21-33-21.png)

## 类上注解

为当前控制器类的所有方法的请求地址指定一个基准路径

![](/static/2021-07-28-21-35-44.png)

* 必须在`/haha`下访问到handle01

## RequestMapping支持Ant路径风格

![](/static/2021-07-28-22-07-04.png)

* 模糊匹配
* RequestMapping也支持Ant风格的url

![](/static/2021-07-28-22-16-16.png)

* `?` - 任意一个字符
* `*` - 多个字符 或 单层路径
* `**` - 多层路径

:bulb: 模糊和精确多个匹配情况下，精确优先

## @PathVariable - 获取路径占位符

通过 @PathVariable 可以将 **URL 中占位符参数（value属性中的路径**）绑定到控制器处理方法的**入参（形参**）中

* 占位符只能占一层路径

![](/static/2021-07-29-13-26-41.png)

# / & /* 区别

原本`/`拦截所有请求，**不包括jsp页面**（`*.jsp`)

* 此时 `*.jsp`<font color="blue">因为不被拦截交给tomcat的`JspServlet`处理</font>
* 而其他请求（如`*.html`静态资源），原本交给`DefaultServlet`，<font color="deeppink">但是如果子模块覆写url-pattern为`/`，会禁用掉`DefaultServlet`，转而交给前端控制器来处理</font>
  * 如果不存在方法能处理这个静态资源，那么就返回404

:bulb: 为什么jsp可以访问？

* 因为如果前端控制器配`/`，**首先不会拦截jsp请求**，而是会被tomcat服务器的`JspServlet`拦截到进行处理

---

`/*`**拦截所有请求**（包括`*.jsp`），拦截jsp页面，

* 所以如果前端控制器配`/*`，会把jsp请求也拦截到，而如果找不到对应controller就报错

## DefaultServlet

tomcat中处理静态资源的（除jsp之外）

# 不指定配置文件位置

web.xml中配springmvc前端控制器时，不指定配置文件位置

![](/static/2021-07-28-20-45-12.png)

* 默认找 `WEB-INF/<dispatcher_servlet_name>-servlet.xml`
  * 匹配配置文件中指定的name，`servlet-name`标签

:bulb: 不想指定位置就可以直接在WEB-INF文件夹下创建 `xxx-servlet.xml`配置文件

# REST风格

![](/static/2021-07-29-13-39-20.png)

![](/static/2021-07-29-13-43-06.png)

* 风格统一的设计
* 以简洁url提交请求，以请求方式区分对资源的操作

:bulb: 问题

* 默认form表单只支持GET，POST请求，
* 需要配置spring3.0支持的过滤器`HiddenHttpMethodFilter`，可以将请求转换为标准http方法，使其支持其他HTTP请求

:bulb: 注意高版本tomcat不支持PUT，DELTE这种方法，

* jsp头加 `isErrorPage=True`

# HiddenHttpMethodFilter

:bulb: 问题

* 默认form表单只支持GET，POST请求，
* 需要配置spring3.0支持的过滤器`HiddenHttpMethodFilter`，可以将请求转换为标准http方法，使其支持其他HTTP请求

---

## 配置Filter

web.xml中配置spring提供的filter

```xml
<!--    support RESTful-->
    <filter>
        <filter-name>HiddenHttpMethodFilter</filter-name>
        <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>HiddenHttpMethodFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
```

## 发起请求

发 送 POST 请求 时携带 一个 `name="_method"` 的 隐含域`type=hidden` ， 值 为 PUT 或 DELETE

![](/static/2021-07-29-15-26-07.png)
![](/static/2021-07-29-15-26-16.png)

---

controller指定method

![](/static/2021-07-29-15-27-00.png)

## 源码

![](/static/2021-07-29-15-28-45.png)
![](/static/2021-07-29-15-31-28.png)

# 请求参数获取

默认方式获取请求（查询）参数 `xxx?username=admin`

![](/static/2021-07-29-15-42-58.png)

* 直接给方法入参上写一个和请求参数名`username`相同的变量

---

## @RequestParam

`@RequestParam`

* 显式获取请求参数
* `value`
  * 参数名
* `required`
  * 默认情况下，请求参数必须包含对应参数，不存在将抛出异常
* `defaultValue`
  * 默认值，没有传递参数时使用该值

![](/static/2021-07-29-15-43-45.png)
![](/static/2021-07-29-15-44-49.png)
![](/static/2021-07-29-15-47-51.png)

## @RequestHeader

获取请求头信息

![](/static/2021-07-29-15-50-40.png)
![](/static/2021-07-29-15-50-50.png)
![](/static/2021-07-29-15-54-26.png)

## @CookieValue

以前获取cookie，麻烦

![](/static/2021-07-29-15-57-01.png)

---

获取请求中cookie值

* `value`
* `required`
* `defaultValue`

![](/static/2021-07-29-15-57-54.png)
![](/static/2021-07-29-15-58-10.png)

# 请求参数处理 - POJO

如果请求参数是一个POJO，springmvc支持自动填充

* 将POJO属性，一一与请求参数配对
* **支持级联封装**
  * ![](/static/2021-07-29-16-06-26.png)
  * ![](/static/2021-07-29-16-07-56.png)

---

POJO类 （有参无参）
![](/static/2021-07-29-16-02-55.png)

表单指定的请求参数名要对应的上
![](/static/2021-07-29-16-04-08.png)

实现自动填充
![](/static/2021-07-29-16-03-45.png)

# 支持Servlet原生API作为入参

![](/static/2021-07-29-16-22-34.png)
![](/static/2021-07-29-16-25-43.png)

* 能用的基本前3个

---

例子

![](/static/2021-07-29-16-23-14.png)
![](/static/2021-07-29-16-23-34.png)

* 利用原生API的域对象，在页面中渲染数据

# 请求数据乱码

![](/static/2021-07-29-16-30-16.png)
![](/static/2021-07-29-16-30-24.png)

建议

![](/static/2021-07-29-16-33-20.png)

* 一般配置在任何其他Filter之前

# ============

# 响应数据输出

如何将数据带给页面

* 原本是通过原生API向域对象里添加数据，然后EL表达式在页面中取出数据

---

spirngmvc可以通过以下方式输出数据

![](/static/2021-07-29-19-48-31.png)

## Map，Model，ModelMap

:bone: Map，Model，ModelMap，这些参数中保存的所有数据都会放在**请求域**`RequestScope`中，可以在页面中获取

* 不管用的哪个，最终都是转为`BindingAwareModelMap`，**相当于`BindingAwareModelMap`保存的数据都会放在请求域中**
  * 推荐使用`Map`，**方便框架移植**
* 关系
  * ![](/static/2021-07-29-19-57-04.png)
  * ![](/static/2021-07-29-19-58-32.png)
* 使用
  * ![](/static/2021-07-29-19-59-27.png)
  * ![](/static/2021-07-29-20-02-34.png)

## ModelAndView

方法返回值可以转为ModelAndView类型

![](/static/2021-07-29-20-03-50.png)
![](/static/2021-07-29-20-06-06.png)

* 视图名 - 页面
  * 视图解析器会帮我们最终拼串得到页面真实地址
* 数据放在请求域中`RequestScope`

## @SessionAttributes

给session域添加数据 （推荐不要使用这个注解，可能会引发异常（结合ModelAttribute使用下），使用原生API就够了）

* 类（控制器）上注解
* 属性
  * `value`
    * 如果用Map/Model/ModelMap给`BindingAwareModelMap`中指定保存的数据，其`key`符合`value`属性指定的值，同时会给session中保存一份
  * `types`
    * 只要数据符合指定的类型，就也在session域中放一份

![](/static/2021-07-29-20-18-03.png)

## @ModelAttribute

以前没有mybatis会用到

:question: 问题 - 场景，全字段修改演示（一般都不会进行全字段更新，，）

* 一般可以显示不需要修改的字段（但不支持用户输入）
* 而如果为了简单，springmvc中入参直接写一个POJO对象，如果某属性映射不到，会自动注入`null`。**如果之后调用了一个全字段更新的DAO操作，那么这个`null`值会被注入进原本不该修改的字段**
  * ![](/static/2021-07-29-20-57-07.png)

:bone: 解决方案 - 思想

* 如果为`null`，就从数据库中取出的对象值，带了的字段的就改为携带的值，此时全字段更新无问题
  * 即，不应该采用springmvc自己new出来的对象，而应该用数据库中取出来的对象，再进行封装

---

`@ModelAttribute`

* 注解位置
  * 方法 - 在执行方法之前运行
    * 可以提前查出数据库中对象信息。**然后在更新方法中指明使用这个查出来的对象，而不是自己new的（这样解决了之前POJO封装在全字段更新场景下产生的问题，因为之前的不用ModelAttribute，会自己封装new的一个对象，有值的带值，没值的为null**）
    * ![](/static/2021-07-29-21-28-41.png)
    * ![](/static/2021-07-29-21-28-30.png)
  * 入参前
    * 获取域对象中存储的数据
* 原理
  * ![](/static/2021-07-29-21-36-19.png)
  * ![](/static/2021-07-29-21-36-26.png)
  * `BindingAwareModelMap`request域数据共享容器

### POJO

![](/static/2021-07-30-17-25-46.png)

可以提前查出数据库中对象信息。**然后在更新方法中指明使用这个查出来的对象，而不是自己new的（这样解决了之前POJO封装在全字段更新场景下产生的问题，因为之前的不用ModelAttribute，会自己封装new的一个对象，有值的带值，没值的为null**）

先MOdelAttribute方法上，提前执行，取数据，然后通过入参ModelAttribute封装POJO，数据根据key（ModelAttribute注解指定）-value(POJO对象)存入请求域对象

---

其他用法 （**推荐只用map**）

![](/static/2021-07-30-17-37-32.png)
![](/static/2021-07-30-17-37-01.png)

* **不写入参前ModelAttribute注解也可以，但是请求域中key名称要对应的上入参变量名**

将数据return也会放在请求域，默认key为返回类型名小写

![](/static/2021-07-30-17-41-57.png)

最后还取不到就会自己新建一个对象，可能会出现null值

### 与SessionAttribute产生的异常

注意，如果入参前标了ModelAttribute且类上标了SessionAttribute会尝试在会话域中查询，不存在会抛异常

:bulb:

* 要么隐含模型中有SessionAttribute标注的属性
* 如果没有，session说有就必须有，不然会抛异常 - 建议不用SessionAttribute

### 源码

现阶段没能力看

![](/static/2021-07-30-17-35-04.png)

# 底层 - DispatcherServlet

前端控制器

![](/static/2021-07-30-15-25-25.png) 

# 源码 - 请求大致流程

DispatcherServlet的doDispatch方法，[参考](https://blog.csdn.net/qq_40353040/article/details/109445941)

* ![](/static/2021-07-30-16-15-14.png)

![](/static/2021-07-30-15-34-33.png)
![](/static/2021-07-30-15-41-45.png)
![](/static/2021-07-30-15-43-18.png)
![](/static/2021-07-30-15-44-36.png)

## getHandler（）

怎么根据当前请求找到能处理的目标处理器类

`getHandler()`

* 返回目标处理器类的执行链

![](/static/2021-07-30-15-56-25.png)

## HandlerAdapter

如何找到目标处理器的目标方法  ---适配器

![](/static/2021-07-30-16-11-30.png)

# 9大组件

DispatcherServlet中9个属性 --- Springmvc9大组件（全是接口）

* ![](/static/2021-07-30-16-20-22.png)
* ![](/static/2021-07-30-16-22-17.png)
* ![](/static/2021-07-30-16-23-06.png)

---

初始化细节

![](/static/2021-07-30-16-26-03.png)

* 9大组件何时有值？
* 初始化
  * 去容器中找组件，如果没有找到就用默认配置
  * 有些组件在容器中使用ID找，有的按类型找

## 目标方法执行

关键：如何确定目标方法每一个参数的值

![](/static/2021-07-30-16-53-16.png)

# 视图解析

## forward:/

表示转发到**当前项目**下一个页面，不会走视图解析器进行拼串

* 一定要加上`/`不然很容易出问题
* 有前缀的转发&重定向操作，配置的视图解析器不会进行拼串

![](/static/2021-07-31-16-44-22.png)

## redirect:/

![](/static/2021-07-31-16-46-50.png)

* 一定要加上`/`不然很容易出问题
* 有前缀的转发&重定向操作，配置的视图解析器不会进行拼串

## （源码）原理

![](/static/2021-07-31-17-19-38.png)
![](/static/2021-07-31-17-23-04.png)

* 视图解析器根据方法返回值得到视图对象
* 多个视图解析器都会尝试是否能得到视图对象
* 视图对象不同就可以具有不同功能

`mv.handle()` 任何方法值最终被封装成ModelAndView

![](/static/2021-07-31-17-00-26.png)
![](/static/2021-07-31-17-10-39.png)

`view.render()`

视图解析器为了得到View对象，而View对象才能真正的转发（模型数据放在请求域中）、重定向到页面，，即**渲染视图**

## JstlView - 国际化

spring中bean标签配，或者导包

或者指定property - viewClass

![](/static/2021-07-31-17-33-00.png)

---

![](/static/2021-07-31-17-35-46.png)
![](/static/2021-07-31-17-38-22.png)

1. spring中配置国际化资源管理器
   1. ![](/static/2021-07-31-17-37-43.png)
2. 页面中直接取值
   1. ![](/static/2021-07-31-17-39-04.png)

### 坑

![](/static/2021-07-31-17-44-04.png)

要获取到国际化渲染必须走springmvc，，因为mvc里配了管理器，直接访问路径下的首先没有控制器能处理，走的是tomcat直接返回

且不能通过forward:,redirect，这两个不会封装国际化信息

![](/static/2021-07-31-17-47-26.png)
![](/static/2021-07-31-17-50-38.png)

## mvc:view-controller

![](/static/2021-07-31-17-50-38.png)

* 上面虽然可行，但是为了访问一个页面就要写一个方法后期冗余
* 如果发送的请求不想通过controller，只想直接地跳转到目标页面，这时候就可以使用mvc:view-controller标签
  * 对应一些我们不需要其他操作的JSP页面，我们可以使用<mvc:view-controller path=""/>来配置，这样就可以不用再控制器中再去做转发映射，从而减轻我们的部分开发工作量
  * **在SpringMVC中有时候针对一个请求不做任何处理，仅仅只是返回一个视图**
* 使用`view-controller`会走整个springmvc流程，**视图解析，国际化**。。。
  * <font color="deeppink">注意要开启注解驱动的mvc模式，不然会造成其他方法无法处理请求</font> - `mvc:annotation-driven`

![](/static/2021-07-31-17-53-30.png)
![](/static/2021-07-31-17-57-02.png)

## 自定义视图解析器 & 视图

自定义视图解析器实现`ViewResolver`接口，实现方法根据**视图名（包括前缀**）返回视图对象。**完成后在springmvc（ioc容器）中配置**

![](/static/2021-07-31-18-32-53.png)
![](/static/2021-07-31-18-46-35.png)
![](/static/2021-07-31-18-33-29.png)
![](/static/2021-07-31-18-33-43.png)

* 遍历所有视图解析器，看看哪个视图解析器能处理视图名
  * ![](/static/2021-07-31-18-35-05.png)![](/static/2021-07-31-18-36-33.png)发现Internalxxxx解析器不能处理，但是会创建一个普通视图渲染至视图名路径（造成404），**所以要配置优先度**

自定义视图解析器实现`Ordered`接口，确保能保证执行优先级（越小越优先）

![](/static/2021-07-31-18-38-11.png)
![](/static/2021-07-31-18-38-20.png)
![](/static/2021-07-31-18-39-21.png)

* 之后发现自定义视图解析器是第一个能处理该视图名的，返回自定义的视图对象

自定义视图对象自定义渲染逻辑`render()`

![](/static/2021-07-31-18-41-12.png)
![](/static/2021-07-31-18-44-38.png)
![](/static/2021-07-31-18-42-51.png)

* 注意要设置响应类型（字符编码过滤器才能发挥作用）