# Content

* [Content](#content)
* [概述](#概述)
* [基础环境搭建](#基础环境搭建)
	* [Maven](#maven)
	* [Bootstrap引入](#bootstrap引入)
* [配置文件编写](#配置文件编写)
	* [web.xml](#webxml)
	* [springmvc](#springmvc)
	* [spring](#spring)
	* [mybatis](#mybatis)
	* [逆向工程](#逆向工程)
* [mapper文件调整](#mapper文件调整)
* [测试](#测试)
	* [常规](#常规)
	* [spring单元测试](#spring单元测试)
* [资源路径问题](#资源路径问题)
* [查询](#查询)
	* [getAll - 分页查询](#getall---分页查询)
		* [测试](#测试-1)
		* [页面渲染](#页面渲染)
	* [get](#get)
* [查询：ajax半前后分离](#查询ajax半前后分离)
	* [通用返回类：封装状态码&数据](#通用返回类封装状态码数据)
	* [控制器](#控制器)
	* [ajax](#ajax)

# 概述

![](/static/2021-08-08-14-50-09.png)

# 基础环境搭建

![](/static/2021-08-08-14-58-15.png)
![](/static/2021-08-08-16-31-04.png)

## Maven

springmvc

![](/static/2021-08-08-14-59-48.png)

spring（事务）

![](/static/2021-08-08-15-00-18.png)

切面增强

![](/static/2021-08-08-15-00-42.png)

mybatis & mybatis-spring适配包

![](/static/2021-08-08-15-01-40.png)

连接池（c3p0） & 数据库驱动

![](/static/2021-08-08-15-02-21.png)

jstl & servlet-api, junit

![](/static/2021-08-08-15-04-07.png)
![](/static/2021-08-08-15-04-27.png)

* servlet-api，服务器有，项目没有，。设置scope（provided），部署时剔除
  * provided**表明该包只在编译和测试的时候用，所以，当启动tomcat的时候，就不会冲突了**

## Bootstrap引入

![](/static/2021-08-08-15-07-02.png)
![](/static/2021-08-08-15-08-49.png)
![](/static/2021-08-08-15-08-03.png)

# 配置文件编写

## web.xml

spring

![](/static/2021-08-08-16-17-14.png)

* 监听器，启动spring容器

---

springmvc

前端控制器，拦截所有请求

![](/static/2021-08-08-16-19-59.png)

---

字符编码过滤器

```xml
	<!-- 3、字符编码过滤器，一定要放在所有过滤器之前 -->
	<filter>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>utf-8</param-value>
		</init-param>
		<init-param>
			<param-name>forceRequestEncoding</param-name>
			<param-value>true</param-value>
		</init-param>
		<init-param>
			<param-name>forceResponseEncoding</param-name>
			<param-value>true</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
```

---

实现Rest风格的URI

```xml
	<!-- 4、使用Rest风格的URI，将页面普通的post请求转为指定的delete或者put请求 -->
	<filter>
		<filter-name>HiddenHttpMethodFilter</filter-name>
		<filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>HiddenHttpMethodFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	<filter>
		<filter-name>HttpPutFormContentFilter</filter-name>
		<filter-class>org.springframework.web.filter.HttpPutFormContentFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>HttpPutFormContentFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
```

## springmvc

网站跳转逻辑控制 & 配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<!--SpringMVC的配置文件，包含网站跳转逻辑的控制，配置  -->
	<context:component-scan base-package="com.atguigu" use-default-filters="false">
		<!--只扫描控制器。  -->
		<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
	</context:component-scan>
	
	<!--配置视图解析器，方便页面返回  -->
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INFiews/"></property>
		<property name="suffix" value=".jsp"></property>
	</bean>
	
	<!--两个标准配置  -->
	<!-- 将springmvc不能处理的请求交给tomcat -->
	<mvc:default-servlet-handler/>
	<!-- 能支持springmvc更高级的一些功能，JSR303校验，快捷的ajax...映射动态请求 -->
	<mvc:annotation-driven/>

</beans>

```

## spring

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<context:component-scan base-package="com.atguigu">
		<context:exclude-filter type="annotation"
			expression="org.springframework.stereotype.Controller" />
	</context:component-scan>

	<!-- Spring的配置文件，这里主要配置和业务逻辑有关的 -->
	<!--=================== 数据源，事务控制，xxx ================-->
	<context:property-placeholder location="classpath:dbconfig.properties" />
	<bean id="pooledDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="jdbcUrl" value="${jdbc.jdbcUrl}"></property>
		<property name="driverClass" value="${jdbc.driverClass}"></property>
		<property name="user" value="${jdbc.user}"></property>
		<property name="password" value="${jdbc.password}"></property>
	</bean>

	<!--================== 配置和MyBatis的整合=============== -->
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 指定mybatis全局配置文件的位置 -->
		<property name="configLocation" value="classpath:mybatis-config.xml"></property>
		<property name="dataSource" ref="pooledDataSource"></property>
		<!-- 指定mybatis，mapper文件的位置 -->
		<property name="mapperLocations" value="classpath:mapper/*.xml"></property>
	</bean>

	<!-- 配置扫描器，将mybatis接口的实现加入到ioc容器中 -->
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<!--扫描所有dao接口的实现，加入到ioc容器中 -->
		<property name="basePackage" value="com.atguigu.crud.dao"></property>
	</bean>
	
	<!-- 配置一个可以执行批量的sqlSession -->
	<bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate">
		<constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"></constructor-arg>
		<constructor-arg name="executorType" value="BATCH"></constructor-arg>
	</bean>
	<!--=============================================  -->

	<!-- ===============事务控制的配置 ================-->
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<!--控制住数据源  -->
		<property name="dataSource" ref="pooledDataSource"></property>
	</bean>
	<!--开启基于注解的事务，使用xml配置形式的事务（必要主要的都是使用配置式）  -->
	<aop:config>
		<!-- 切入点表达式 -->
		<aop:pointcut expression="execution(* com.atguigu.crud.service..*(..))" id="txPoint"/>
		<!-- 配置事务增强 -->
		<aop:advisor advice-ref="txAdvice" pointcut-ref="txPoint"/>
	</aop:config>
	
	<!--配置事务增强，事务如何切入  -->
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<!-- 所有方法都是事务方法 -->
			<tx:method name="*"/>
			<!--以get开始的所有方法  -->
			<tx:method name="get*" read-only="true"/>
		<:attributes>
	<:advice>
	
	<!-- Spring配置文件的核心点（数据源、与mybatis的整合，事务控制） -->
	
</beans>
```

## mybatis

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
	<settings>
		<setting name="mapUnderscoreToCamelCase" value="true"/>
	</settings>
	
	<typeAliases>
		<package name="com.atguigu.crud.bean"/>
	</typeAliases>
	
	<plugins>
		<plugin interceptor="com.github.pagehelper.PageInterceptor">
			<!--分页参数合理化  -->
			<property name="reasonable" value="true"/>
		</plugin>
	</plugins>

</configuration>

```

## 逆向工程

1.创建db表

![](/static/2021-08-08-17-05-51.png)
![](/static/2021-08-08-17-07-15.png)
![](/static/2021-08-08-17-07-36.png)

2.使用逆向工程生成bean & mapper & dao接口

```xml
<!-- MBG -->
<!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core -->
<dependency>
	<groupId>org.mybatis.generator</groupId>
	<artifactId>mybatis-generator-core</artifactId>
	<version>1.3.5</version>
</dependency>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>

	<context id="DB2Tables" targetRuntime="MyBatis3">
		<commentGenerator>
		<!-- 不会生成注释 -->
			<property name="suppressAllComments" value="true" />
		</commentGenerator>
		<!-- 配置数据库连接 -->
		<jdbcConnection driverClass="com.mysql.jdbc.Driver"
			connectionURL="jdbc:mysql://localhost:3306/ssm_crud" userId="root"
			password="123456">
		</jdbcConnection>

		<javaTypeResolver>
			<property name="forceBigDecimals" value="false" />
		</javaTypeResolver>

		<!-- 指定javaBean生成的位置 -->
		<javaModelGenerator targetPackage="com.atguigu.crud.bean"
			targetProject=".\src\main\java">
			<property name="enableSubPackages" value="true" />
			<property name="trimStrings" value="true" />
		</javaModelGenerator>

		<!--指定sql映射文件生成的位置 -->
		<sqlMapGenerator targetPackage="mapper" targetProject=".\src\main\resources">
			<property name="enableSubPackages" value="true" />
		</sqlMapGenerator>

		<!-- 指定dao接口生成的位置，mapper接口 -->
		<javaClientGenerator type="XMLMAPPER"
			targetPackage="com.atguigu.crud.dao" targetProject=".\src\main\java">
			<property name="enableSubPackages" value="true" />
		</javaClientGenerator>


		<!-- table指定每个表的生成策略
		哪个表对应哪个bean -->
		<table tableName="tbl_emp" domainObjectName="Employee"></table>
		<table tableName="tbl_dept" domainObjectName="Department"></table>
	</context>
</generatorConfiguration>
```

根据MBG配置文件生成

```java
public class MBGTest {

	public static void main(String[] args) throws Exception {
		List<String> warnings = new ArrayList<String>();
		boolean overwrite = true;
		File configFile = new File("mbg.xml");
		ConfigurationParser cp = new ConfigurationParser(warnings);
		Configuration config = cp.parseConfiguration(configFile);
		DefaultShellCallback callback = new DefaultShellCallback(overwrite);
		MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
				callback, warnings);
		myBatisGenerator.generate(null);
	}
}
```

# mapper文件调整

![](/static/2021-08-08-17-19-21.png)

* 新增两个带条件查询，并带部门信息
  * 联合查询，封装FK

![](/static/2021-08-08-17-30-49.png)

# 测试

## 常规

因为SqlSessionFactory已经整合进spring容器了，如果不自动装配要么配置，要么通过继承抽象类获取SqlSessionTemplate然后执行dao操作

![](/static/2021-08-08-17-46-38.png)

---

常规是**自动装配（推荐**），通过映射器来执行dao操作。或者**新建ioc容器，然后从容器里拿**

```java
//1、创建SpringIOC容器
ApplicationContext ioc = new ClassPathXmlApplicationContext("applicationContext.xml");
//2、从容器中获取mapper
DepartmentMapper bean = ioc.getBean(DepartmentMapper.class);*/
System.out.println(departmentMapper)
```

## spring单元测试

*推荐Spring的项目就可以使用Spring的单元测试，可以自动注入我们需要的组件

*1、导入SpringTest模块

```xml
<!--Spring-test -->
		<!-- https://mvnrepository.com/artifact/org.springframework/spring-test -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
			<version>4.3.7.RELEASE</version>
		</dependency>
```

*2、`@ContextConfiguration`指定Spring配置文件的位置，自动创建ioc容器

*3、直接autowired要使用的组件即可

```java
// 指定用哪个单元测试模块运行
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations={"classpath:applicationContext.xml"})
public class MapperTest {
	
	@Autowired
	DepartmentMapper departmentMapper;
	
	@Autowired
	EmployeeMapper employeeMapper; //直接用还是通过默认的sqlsession获取的映射器
	
	@Autowired
	SqlSession sqlSession; // 会自动装配配置文件中批处理的sqlsession，如果没有配用的默认的
	
	/**
	 * 测试DepartmentMapper
	 */
	@Test
	public void testCRUD(){
		System.out.println(departmentMapper);
		
		//1、插入几个部门
		departmentMapper.insertSelective(new Department(null, "开发部"));
		departmentMapper.insertSelective(new Department(null, "测试部"));
		
		//2、生成员工数据，测试员工插入
		employeeMapper.insertSelective(new Employee(null, "Jerry", "M", "Jerry@atguigu.com", 1));
		
		//3、批量插入多个员工；批量，使用可以执行批量操作的sqlSession。
		
//		for(){、、//这个直接用mapper用的还是默认的sqlsession
//			employeeMapper.insertSelective(new Employee(null, , "M", "Jerry@atguigu.com", 1));
//		}
		EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
		for(int i = 0;i<1000;i++){
			String uid = UUID.randomUUID().toString().substring(0,5)+i;
			mapper.insertSelective(new Employee(null,uid, "M", uid+"@atguigu.com", 1));
		}
		System.out.println("批量完成");
		
	}

}
```

# 资源路径问题

![](/static/2021-08-08-20-53-36.png)
![](/static/2021-08-08-20-54-22.png)

# 查询

![](/static/2021-08-08-20-18-02.png)

URI ： `/emps?pn=<int>`

## getAll - 分页查询

引入pagehelper分页插件

```xml
<!--引入pageHelper分页插件 -->
<dependency>
	<groupId>com.github.pagehelper</groupId>
	<artifactId>pagehelper</artifactId>
	<version>5.0.0</version>
</dependency>
```

mybatis全局配置中注册插件

![](/static/2021-08-08-20-28-24.png)

---

service

```java
/**
	* 查询所有员工
	* @return
	*/
public List<Employee> getAll() {
	// TODO Auto-generated method stub
	return employeeMapper.selectByExampleWithDept(null);
}
```

控制器

![](/static/2021-08-08-20-31-03.png)

* 每次连续显示5页

```java
/**
* 查询员工数据（分页查询）
* 默认page number（查询参数） 1
* 
* @return
*/
@RequestMapping("/emps")
public String getEmps(
	@RequestParam(value = "pn", defaultValue = "1") Integer pn,
	Model model) {
// 引入PageHelper分页插件
// 在查询之前只需要调用，传入页码，以及每页的大小（记录数）
PageHelper.startPage(pn, 5);

// startPage后面紧跟的这个查询就是一个分页查询
List<Employee> emps = employeeService.getAll();

// 使用pageInfo包装查询后的结果，只需要将pageInfo交给页面就行了。
// 封装了详细的分页信息,包括有我们查询出来的数据，传入连续显示的页数
PageInfo page = new PageInfo(emps, 5);
// 之后能通过page.getNavigatepageNums()获取连续显示的页码

model.addAttribute("pageInfo", page);

return "list";
}
```

---

### 测试

spring测试，模拟请求

![](/static/2021-08-08-20-50-34.png)

```java
@RunWith(SpringJUnit4ClassRunner.class)
@WebAppConfiguration
@ContextConfiguration(locations = { "classpath:applicationContext.xml",
		"file:src/main/webapp/WEB-INF/dispatcherServlet-servlet.xml" })
public class MvcTest {
	// 传入Springmvc的ioc
	@Autowired
	WebApplicationContext context;
	// 虚拟mvc请求，获取到处理结果。
	MockMvc mockMvc;

	@Before
	public void initMokcMvc() {
		mockMvc = MockMvcBuilders.webAppContextSetup(context).build();
	}

	@Test
	public void testPage() throws Exception {
		//模拟请求拿到返回值
		MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get("/emps").param("pn", "5"))
				.andReturn();
		
		//请求成功以后，请求域中会有pageInfo；我们可以取出pageInfo进行验证
		MockHttpServletRequest request = result.getRequest();
		PageInfo pi = (PageInfo) request.getAttribute("pageInfo");
		System.out.println("当前页码："+pi.getPageNum());
		System.out.println("总页码："+pi.getPages());
		System.out.println("总记录数："+pi.getTotal());
		System.out.println("在页面需要连续显示的页码");
		int[] nums = pi.getNavigatepageNums();
		for (int i : nums) {
			System.out.print(" "+i);
		}
		
		//获取员工数据
		List<Employee> list = pi.getList();
		for (Employee employee : list) {
			System.out.println("ID："+employee.getEmpId()+"==>Name:"+employee.getEmpName());
		}
		
	}

}
```

### 页面渲染

![](/static/2021-08-08-21-11-41.png)

分页信息

![](/static/2021-08-08-21-14-02.png)
![](/static/2021-08-08-21-14-14.png)

分页导航（每一个导航包含5条页码）

![](/static/2021-08-08-21-16-06.png)
![](/static/2021-08-08-21-15-56.png)
![](/static/2021-08-08-21-18-20.png)
![](/static/2021-08-08-21-19-14.png)

分页导航，上一页（第一页不显示上一页）

![](/static/2021-08-08-21-21-01.png)

分页导航，下一页（最后一页不显示下一页）

![](/static/2021-08-08-21-22-27.png)

## get

```java
/**
	* 根据id查询员工
	* @param id
	* @return
	*/
@RequestMapping(value="/emp/{id}",method=RequestMethod.GET)
@ResponseBody
public Msg getEmp(@PathVariable("id")Integer id){
	
	Employee employee = employeeService.getEmp(id);
	return Msg.success().add("emp", employee);
}
```

# 查询：ajax半前后分离

![](/static/2021-08-08-21-24-59.png)

导入jakson包

![](/static/2021-08-08-21-28-38.png)

---

## 通用返回类：封装状态码&数据

设计通用返回，包装状态信息 & 数据

```java
/**
 * 通用的返回的类
 * 
 * @author lfy
 * 
 */
public class Msg {
	//状态码   100-成功    200-失败
	private int code;
	//提示信息
	private String msg;
	
	//用户要返回给浏览器的数据
	private Map<String, Object> extend = new HashMap<String, Object>();

	public static Msg success(){
		Msg result = new Msg();
		result.setCode(100);
		result.setMsg("处理成功！");
		return result;
	}
	
	public static Msg fail(){
		Msg result = new Msg();
		result.setCode(200);
		result.setMsg("处理失败！");
		return result;
	}
	
	public Msg add(String key,Object value){
		this.getExtend().put(key, value);
		return this;
	}
	
	public int getCode() {
		return code;
	}

	public void setCode(int code) {
		this.code = code;
	}

	public String getMsg() {
		return msg;
	}

	public void setMsg(String msg) {
		this.msg = msg;
	}

	public Map<String, Object> getExtend() {
		return extend;
	}

	public void setExtend(Map<String, Object> extend) {
		this.extend = extend;
	}
}
```

## 控制器

控制器，直接返回json序列化数据，`@ResponseBody`

```java
/**
	* 导入jackson包。
	* @param pn
	* @return
	*/
@RequestMapping("/emps")
@ResponseBody
public Msg getEmpsWithJson(
		@RequestParam(value = "pn", defaultValue = "1") Integer pn) {
	// 这不是一个分页查询
	// 引入PageHelper分页插件
	// 在查询之前只需要调用，传入页码，以及每页的大小
	PageHelper.startPage(pn, 5);
	// startPage后面紧跟的这个查询就是一个分页查询
	List<Employee> emps = employeeService.getAll();
	// 使用pageInfo包装查询后的结果，只需要将pageInfo交给页面就行了。
	// 封装了详细的分页信息,包括有我们查询出来的数据，传入连续显示的页数
	PageInfo page = new PageInfo(emps, 5);
	return Msg.success().add("pageInfo", page);
}
```

## ajax

总渲染步骤

```js
function to_page(pn){
	$.ajax({
		url:"${APP_PATH}/emps",
		data:"pn="+pn,
		type:"GET",
		success:function(result){
			//console.log(result);
			//1、解析并显示员工数据
			build_emps_table(result);
			//2、解析并显示分页信息
			build_page_info(result);
			//3、解析显示分页条数据
			build_page_nav(result);
		}
	});
}
```

解析 & 渲染员工表格数据

```js
function build_emps_table(result){
	//清空table表格
	$("#emps_table tbody").empty();
	var emps = result.extend.pageInfo.list;
	$.each(emps,function(index,item){
		var checkBoxTd = $("<td><input type='checkbox' class='check_item'/></td>");
		var empIdTd = $("<td></td>").append(item.empId);
		var empNameTd = $("<td></td>").append(item.empName);
		var genderTd = $("<td></td>").append(item.gender=='M'?"男":"女");
		var emailTd = $("<td></td>").append(item.email);
		var deptNameTd = $("<td></td>").append(item.department.deptName);
		/**
		<button class="">
							<span class="" aria-hidden="true"></span>
							编辑
						</button>
		*/
		var editBtn = $("<button></button>").addClass("btn btn-primary btn-sm edit_btn")
						.append($("<span></span>").addClass("glyphicon glyphicon-pencil")).append("编辑");
		//为编辑按钮添加一个自定义的属性，来表示当前员工id
		editBtn.attr("edit-id",item.empId);
		var delBtn =  $("<button></button>").addClass("btn btn-danger btn-sm delete_btn")
						.append($("<span></span>").addClass("glyphicon glyphicon-trash")).append("删除");
		//为删除按钮添加一个自定义的属性来表示当前删除的员工id
		delBtn.attr("del-id",item.empId);
		var btnTd = $("<td></td>").append(editBtn).append(" ").append(delBtn);
		//var delBtn = 
		//append方法执行完成以后还是返回原来的元素（链式调用）
		$("<tr></tr>").append(checkBoxTd)
			.append(empIdTd)
			.append(empNameTd)
			.append(genderTd)
			.append(emailTd)
			.append(deptNameTd)
			.append(btnTd)
			.appendTo("#emps_table tbody");
	});
}
```

解析分页信息

```js
//解析显示分页信息
function build_page_info(result){
	$("#page_info_area").empty();
	$("#page_info_area").append("当前"+result.extend.pageInfo.pageNum+"页,总"+
			result.extend.pageInfo.pages+"页,总"+
			result.extend.pageInfo.total+"条记录");
	totalRecord = result.extend.pageInfo.total;
	currentPage = result.extend.pageInfo.pageNum;
}
```

分页导航

```js
//解析显示分页条，点击分页要能去下一页....
function build_page_nav(result){
	//page_nav_area
	$("#page_nav_area").empty();
	var ul = $("<ul></ul>").addClass("pagination");
	
	//构建元素
	var firstPageLi = $("<li></li>").append($("<a></a>").append("首页").attr("href","#"));
	var prePageLi = $("<li></li>").append($("<a></a>").append("&laquo;"));
	if(result.extend.pageInfo.hasPreviousPage == false){
		firstPageLi.addClass("disabled");
		prePageLi.addClass("disabled");
	}else{
		//为元素添加点击翻页的事件
		firstPageLi.click(function(){
			to_page(1);
		});
		prePageLi.click(function(){
			to_page(result.extend.pageInfo.pageNum -1);
		});
	}
	
	
	
	var nextPageLi = $("<li></li>").append($("<a></a>").append("&raquo;"));
	var lastPageLi = $("<li></li>").append($("<a></a>").append("末页").attr("href","#"));
	if(result.extend.pageInfo.hasNextPage == false){
		nextPageLi.addClass("disabled");
		lastPageLi.addClass("disabled");
	}else{
		nextPageLi.click(function(){
			to_page(result.extend.pageInfo.pageNum +1);
		});
		lastPageLi.click(function(){
			to_page(result.extend.pageInfo.pages);
		});
	}
	
	
	
	//添加首页和前一页 的提示
	ul.append(firstPageLi).append(prePageLi);
	//1,2，3遍历给ul中添加页码提示
	$.each(result.extend.pageInfo.navigatepageNums,function(index,item){
		
		var numLi = $("<li></li>").append($("<a></a>").append(item));
		if(result.extend.pageInfo.pageNum == item){
			numLi.addClass("active");
		}
		numLi.click(function(){
			to_page(item);
		});
		ul.append(numLi);
	});
	//添加下一页和末页 的提示
	ul.append(nextPageLi).append(lastPageLi);
	
	//把ul加入到nav
	var navEle = $("<nav></nav>").append(ul);
	navEle.appendTo("#page_nav_area");
}
```